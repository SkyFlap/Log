2024-12-17 11:06:55,273 - INFO Retriever 0 - Init Retriever.
2024-12-17 11:07:20,505 - INFO Retriever 0 - keywords:“['Battle animation', '技能招式', 'skill move', '技能', 'role', 'stuck', 'skill', 'fixed', '动画', '角色', 'animation', 'move', 'talent', 'Combat animation', '战斗', '招式', 'battle', '固定', '战斗动画', 'warfare', 'character']”，“['Battle animation', '技能招式', 'skill move', '技能', 'role', 'stuck', 'combat', 'skill', 'fixed', '动画', '角色', 'animation', 'move', 'talent', 'Combat animation', '战斗', '招式', 'battle', '固定', '战斗动画', 'character']”，“['combat animation', '技能招式', 'skill move', '技能', 'role', 'stuck', 'skill', 'fixed', '动画', '角色', 'animation', 'move', 'battle animation', 'talent', '战斗', '招式', 'battle', '固定', '战斗动画', 'warfare', 'character']”
2024-12-17 11:07:20,505 - INFO Retriever 0 - deep_think_conent
:在获取了项目文件的顶层结构后，我还需要结合待查询的问题描述，对于项目中的文件和目录进行一些深度关键词检索。根据任务描述：“请在D:/Unity/jyx2\Assets下各级目录中寻找：我想指定某个角色的所有战斗动画为固定的,而不是跟随技能招式变化应该修改哪个脚本”，我总结出如下可能会出现在各个文件名或者文件内容中的关键词：“['Battle animation', '技能招式', 'skill move', '技能', 'role', 'stuck', 'skill', 'fixed', '动画', '角色', 'animation', 'move', 'talent', 'Combat animation', '战斗', '招式', 'battle', '固定', '战斗动画', 'warfare', 'character']”，“['Battle animation', '技能招式', 'skill move', '技能', 'role', 'stuck', 'combat', 'skill', 'fixed', '动画', '角色', 'animation', 'move', 'talent', 'Combat animation', '战斗', '招式', 'battle', '固定', '战斗动画', 'character']”，“['combat animation', '技能招式', 'skill move', '技能', 'role', 'stuck', 'skill', 'fixed', '动画', '角色', 'animation', 'move', 'battle animation', 'talent', '战斗', '招式', 'battle', '固定', '战斗动画', 'warfare', 'character']”。
接下来，我将使用retrieve_keywords操作，在项目顶层路径“D:/Unity/jyx2\Assets”下检索这些关键词，从而大致把握可能与问题描述相关的文件或目录的路径。
2024-12-17 11:07:20,506 - INFO Retriever 0 - ——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
2024-12-17 11:07:20,507 - INFO Retriever 0 - Assistant:
2024-12-17 11:07:20,507 - INFO Retriever 0 - {
    "deep_think": {
        "thoughts": "好的，接下来我将通过深度思考、仔细计划以及逐步执行的方式，来完成该任务。\n\n首先，在阅读详细的代码细节之前，应该先整体把握整个项目。\n\n在提供的可选的action中，可以通过get_folder_info操作，通过将项目顶层路径作为target_folder_path参数进行传入，来获取获取项目中主要文件夹和主要文件的描述，从而能够先大致把握项目文件的主要文件的文件树结构、基本内容、主要代码概述以及大致功能板块的分布。"
    }
}
2024-12-17 11:07:20,507 - INFO Retriever 0 - 
Observer:
2024-12-17 11:07:20,507 - INFO Retriever 0 - 好的，请继续你的下一步行动或思考。
2024-12-17 11:07:20,509 - INFO Retriever 0 - 
2024-12-17 11:07:20,592 - INFO Retriever 0 - ——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
2024-12-17 11:07:20,593 - INFO Retriever 0 - Assistant:
2024-12-17 11:07:20,605 - INFO Retriever 0 - {
    "get_folder_info": {
        "target_folder_path": "D:/Unity/jyx2\\Assets"
    }
}
2024-12-17 11:07:20,605 - INFO Retriever 0 - 
Observer:
2024-12-17 11:07:20,606 - INFO Retriever 0 - 目标文件夹路径：D:/Unity/jyx2\Assets
文件结构树（该结构树可能不完整，仅返回深度小于等于1层的子文件以及文件夹）：
├── 3D
│   ├── Animal pack deluxe
│   ...
│   ├── juese2
├── 3DScene
│   ├── Animation
│   ├── COMMUNITY_LICENSE_FOR_JYX2.md
│   ...
│   ├── timg.jpg
├── 3rd
│   ├── AmplifyShaderEditor
│   ├── Animancer
│   ...
│   ├── xNode-1.8.0
├── BuildSource
│   ├── AnimationControllers
│   ├── Animations
│   ...
│   ├── sound
├── Easy Save 3
│   ├── Types
├── Editor
│   ├── .DS_Store
│   ├── AddScenesToBuild.cs
│   ...
│   ├── ToolbarExtender
├── Gizmos
├── IFix
│   ├── Editor
├── Jyx2Tools
├── Jyx2UI
│   ├── Res
│   ├── gameicon1.png
│   ...
│   ├── theend.png
├── LuaScripts
│   ├── InitLuaScripts.lua
│   ├── Jyx2Battle
│   ...
│   ├── testLua.lua
├── Mods
│   ├── .gitignore
│   ├── JYX2
│   ├── README.txt
│   ├── SAMPLE
│   ├── xiastart_roguelike
├── Plugins
│   ├── 3rd
│   ├── Android
│   ...
│   ├── xlua.bundle
├── Prefabs
│   ├── BattleRole.prefab
│   ├── BattleboxBlock.prefab
│   ...
│   ├── StorySelectionItem.prefab
├── Resources
│   ├── ABMD5.txt
│   ├── BattleboxBlock.prefab
│   ...
│   ├── icon.jpg
├── Scripts
│   ├── AudioManager.cs
│   ├── BattleBlockData.cs
│   ...
│   ├── VCamManage
├── StaticBakeObj.shader
├── StreamingAssets
│   ├── build_info
├── TapTap
├── TapTapSlogan.png
├── Terrain
│   ├── Terrain Mat.mat
│   ├── Terrain_0_0-20210221-192230.asset
│   ├── Terrain_Copy.asset
├── Terrain2Mesh
│   ├── NewMeshTerrain2
│   ├── NewMeshTerrain3
│   ...
│   ├── Terrain_LOD_2.obj
├── VFX
│   ├── DragonVFX
│   ├── EffectsPackage
│   ├── Hovl Studio
│   ├── JMO Assets
│   ├── Jyx2Effect
│   ├── Toon_Explosion_V1
│   ├── UNAUTH_ASSETS_FOR_JYX2.md
├── XLua
│   ├── CHANGELOG.txt
│   ├── Doc
│   ...
│   ├── util
├── _TerrainAutoUpgrade
│   ├── layer_119f68b03b8b7e8e.terrainlayer
│   ├── layer_793646612c42751.terrainlayer
│   ...
│   ├── layer_stone3d3aba195e4d26ee.terrainlayer
├── csc.rsp
├── icon.jpg
├── link.xml
├── mcs.rsp


其中，部分主要文件及文件夹的信息如下：
1. 3D
# 路径:D:/Unity/jyx2/Assets\3D
# 内容概述:### 文件夹内容概要

“COMMUNITY_LICENSE_FOR_JYX2.md”文件是金庸群侠传3D重制版项目的授权声明，明确指出文件夹内所有内容受特定社区素材协议保护，并要求用户查阅相关协议以了解使用规则，强调未经授权不得使用。

2. 3DScene
# 路径:D:/Unity/jyx2/Assets\3DScene
# 内容概述:在“3DScene”文件夹中，包含了多种动画和控制脚本文件，如“camera.anim”和“Main Camera (1).controller”，用于定义摄像机运动。此外，存在版权声明文件“COMMUNITY_LICENSE_FOR_JYX2.md”，保护了金庸群侠传3D重制版项目的素材使用。图像文件“map.jpg”和“timg.jpg”可能作为视觉参考，而“New Material 1.mat”和“New Material.mat”则是Unity材质文件，用于定义物体外观。

3. 3rd
# 路径:D:/Unity/jyx2/Assets\3rd
# 内容概述:“UNAUTH_ASSETS_FOR_JYX2.md”文件声明，放置该文件目录及其子目录中的素材未经授权，并提醒用户遵守版权规范。此声明与金庸群侠传3D重制版项目无关，如对素材有异议，请与项目方联系。

4. BuildSource
# 路径:D:/Unity/jyx2/Assets\BuildSource
# 内容概述:“BuildSource”文件夹汇集了金庸群侠传3D重制版项目的核心资源，包括动画控制器和动作资源、事件图和Lua脚本、游戏控制器和用户界面设计、角色与武器模型、音乐与音效等。这些资源相互关联，共同支撑起游戏的整体架构，从动画到交互，从视觉到听觉，确保了游戏体验的丰富性和连贯性。此外，文件夹中还包含了必要的文档和授权声明，确保了项目资源的合法使用和标准遵循。

5. Easy Save 3
# 路径:D:/Unity/jyx2/Assets\Easy Save 3
# 内容概述:### 总体概述
“Easy Save 3”文件夹汇集了Unity游戏开发中用于数据持久化的C#脚本，专注于角色、技能和地图等游戏对象的序列化与反序列化，确保游戏数据在保存与加载过程中的稳定性和一致性。

### 目录结构
文件夹内包含针对角色物品、游戏运行数据、角色实例、技能实例、子地图和世界地图数据序列化的脚本。

### 内容关联
这些脚本通过继承通用序列化类，共同构成了一个数据序列化系统，确保不同游戏数据结构在保存和加载过程中的正确转换。

6. Editor
# 路径:D:/Unity/jyx2/Assets\Editor
# 内容概述:### 文件夹内容总结

“Editor”文件夹汇集了Unity编辑器扩展工具，旨在提升开发效率。它包含动画配置工具、贴图格式检查、构建自动化、热更新配置、资源引用查找、工具栏扩展、场景切换、烘培节点控制、纹理格式转换等子文件夹和脚本。这些工具如AnimationTools、AssetToolkits、BuildTools等，通过增强编辑器功能，简化了动画处理、资源管理和构建流程，同时提供了如热修复配置、资源引用查找等特定工具，以优化开发体验。

7. Gizmos
# 路径:D:/Unity/jyx2/Assets\Gizmos
# 内容概述:该文件夹内容为空。

8. IFix
# 路径:D:/Unity/jyx2/Assets\IFix
# 内容概述:“IFix”文件夹汇集了Unity编辑器脚本，专注于实现热补丁注入与资源备份，通过`Configure.cs`定义配置属性和方法，`ILFixEditor.cs`则作为编辑器扩展，利用这些配置来管理热补丁和资源，从而提升游戏开发和维护的效率。

9. Jyx2Tools
# 路径:D:/Unity/jyx2/Assets\Jyx2Tools
# 内容概述:Jyx2Tools文件夹是一个综合性的工具集文件夹，主要包含用于不同目的的工具文件和资源。其目录结构清晰，包括多个子文件和子文件夹，如“add git 指定类型文件夹”提供Git版本控制相关工具，“RTMPose关键点检测-安装MMDetection和MMPose-总结”涉及计算机视觉算法的安装与使用指南，“文言文内容分析概括题”课件则针对文言文学习提供教学材料，“construction worker safety dataset (cws)”则是一个用于AI风险评估的数据集。这些文件和子文件夹相互关联，共同构成了一个支持多种应用场景的工具和资源集合。

10. Jyx2UI
# 路径:D:/Unity/jyx2/Assets\Jyx2UI
# 内容概述:### 总体概述
“Jyx2UI”文件夹汇集了游戏或软件UI设计的视觉资源，包括装饰贴图、纹理图像以及一系列图标，如游戏图标、主菜单和结束画面等，旨在增强界面美观和用户体验。

### 目录结构
- **Decal文件夹**：存储游戏装饰和标识的贴图及预制体，如不同颜色和形状的装饰元素。
- **Textures文件夹**：包含用于界面背景和环境的颜色块纹理图像。
- **新增文件**：包括游戏图标、主菜单、结束画面等图标文件，用于界面关键元素和提示。

### 内容关联
文件夹内文件共同服务于游戏或软件的界面设计，其中“Decal”和“Textures”提供装饰和纹理，而新增图标文件则丰富了UI元素，确保了视觉元素的协调一致。

11. LuaScripts
# 路径:D:/Unity/jyx2/Assets\LuaScripts
# 内容概述:该Lua脚本执行了简单的数学运算和打印输出。变量`mm`被赋值为`-4`，随后`uu`和`pp`分别通过取反和减法运算得到`4`。脚本还打印了`uu`的值`4`，一个介于0和0.5之间的随机数（实际输出为`0`），以及字符串`"test end"`。

12. Mods
# 路径:D:/Unity/jyx2/Assets\Mods
# 内容概述:### 文件夹内容总结

“Mods”文件夹汇集了多个游戏开发资源，包括更新日志、配置文件、地图、模型、预制体、脚本和Mod设置等。主要子文件夹如“JYX2”包含游戏资源与更新记录，“SAMPLE”提供动画、配置和脚本资源，“xiastart_roguelike”则聚焦于“roguelike武侠战斗”的游戏开发资源。此外，存在Git忽略文件和README.txt，分别用于版本控制和MOD编辑指导。这些资源相互关联，共同支持游戏开发流程。

13. Plugins
# 路径:D:/Unity/jyx2/Assets\Plugins
# 内容概述:“Plugins”文件夹汇集了Unity游戏开发所需的多样化工具和插件，包括日志报告工具、Android应用开发资源、辅助开发组件、图像处理和动画库、数据管理插件、后处理效果插件、Excel支持库、Steamworks集成、iOS开发工具、UI组件资源包、响应式编程库、异步任务管理工具、WebGL交互接口、Lua脚本支持库等。这些资源覆盖了从设计到发布的各个阶段，旨在提升开发效率和游戏质量。

14. Prefabs
# 路径:D:/Unity/jyx2/Assets\Prefabs
# 内容概述:### 总体概述：
“Prefabs”文件夹汇集了游戏开发所需的各种预制体资源，包括角色、场景元素、用户界面和控制组件，旨在支持游戏场景的构建和交互设计。

### 目录结构：
文件夹内包含多种预制体，如**BattleboxBlock**、**BattleRole**、**DialogPanel**等，涵盖了角色、UI、灯光和导航指针等元素。

### 内容关联：
这些预制体相互关联，共同构成了游戏的核心元素，从角色和场景到用户界面和交互控制，为游戏开发提供了全面的资源支持。

15. Resources
# 路径:D:/Unity/jyx2/Assets\Resources
# 内容概述:### 文本分析员AI

#### 文本文件内容总结

该“RewiredInputManager”文件是Unity3D预制体配置，定义了Rewired输入管理器的设置和映射。它包含预制体基本信息，如名称和版本，以及详细的输入管理器配置，包括输入轴、按钮和摇杆等，以及针对不同玩家ID和控制器的输入映射。此文件便于Unity3D开发者集成Rewired，以实现复杂的输入处理。

16. Scripts
# 路径:D:/Unity/jyx2/Assets\Scripts
# 内容概述:“Scripts”文件夹汇集了Unity游戏开发的核心脚本，涵盖战斗管理、地图交互、角色控制、UI开发、资源管理和编辑器工具。其中，战斗系统涉及战斗区域设置、战斗逻辑与角色控制；地图交互和导航则通过角色移动、地图宝箱和地点名称显示实现；玩家输入与UI交互通过角色选择、物品管理和UI导航脚本处理；资源管理和工具函数则支持游戏资源的加载与辅助功能实现。此外，编辑器插件、控制台命令、日志记录、技能播放、游戏设置等关键功能也在此文件夹中得到了体现。

17. StreamingAssets
# 路径:D:/Unity/jyx2/Assets\StreamingAssets
# 内容概述:“StreamingAssets”文件夹主要存放流媒体资源，其中包含一个名为“build_info”的文件，可能记录构建配置信息。

18. TapTap
# 路径:D:/Unity/jyx2/Assets\TapTap
# 内容概述:该文件夹内容为空。

19. Terrain
# 路径:D:/Unity/jyx2/Assets\Terrain
# 内容概述:“Terrain”文件夹汇集了与地形处理相关的文件，包括Terrain Mat.mat可能的地形材质数据，以及两个遭遇解码错误的资产文件Terrain_0_0-20210221-192230.asset和Terrain_Copy.asset，后者可能为前者的副本。这些文件关联紧密，均涉及地形数据的处理，但存在编码问题。

20. Terrain2Mesh
# 路径:D:/Unity/jyx2/Assets\Terrain2Mesh
# 内容概述:## 文件夹内容总结

“Terrain2Mesh”文件夹汇集了多个与3D地形模型相关的文件，旨在支持游戏开发与3D动画项目。包含地形模型的基本几何数据（如NewMeshTerrain2.obj和Terrain2Mesh.obj），配置文件（如NewMeshTerrain2.prefab和Terrain2Mesh.prefab），以及用于优化渲染性能的LOD（Level of Detail）模型（如TerrainLOD.FBX）。此外，还有纹理贴图（如SplatAlpha 0.png）和材质文件（如Terrain2Mesh.mat），共同构成了一个完整的地形模型资源集。

21. VFX
# 路径:D:/Unity/jyx2/Assets\VFX
# 内容概述:“VFX”文件夹汇集了多种游戏和动画制作资源，包括3D模型、动画、特效和预制体。其中，“DragonVFX”提供黑色龙的详细模型与动画，“Hovl Studio”和“JMO Assets”分别包含动画、游戏开发与视觉效果资源，而“Jyx2Effect”和“Toon_Explosion_V1”则专注于特定效果的资源包。此外，文件夹中还包含版权声明文件，如“UNAUTH_ASSETS_FOR_JYX2.md”，提醒用户注意授权和使用规范。

22. XLua
# 路径:D:/Unity/jyx2/Assets\XLua
# 内容概述:“XLua”文件夹是Unity游戏开发者的宝贵资源库，集成了xLua框架的文档、配置、示例代码和工具类。其中，文档详细介绍了xLua的配置和使用方法；编辑器文件夹提供了Unity编辑器相关的配置资源；示例文件夹则通过实际案例展示了xLua在Unity项目中的应用；生成文件夹包含用于生成Lua代码的工具；资源文件夹汇集了性能分析、内存管理和TDR库交互的Lua脚本；核心资源库提供了Unity项目开发所需的脚本和工具；教程文件夹则提供了xLua在Unity中使用的教学示例；加密工具文件夹实现了XXTEA加密算法；更新日志文件则记录了xLua库的版本更新和改进。这些内容相互关联，共同构成了一个全面、实用的xLua开发资源集合。

23. _TerrainAutoUpgrade
# 路径:D:/Unity/jyx2/Assets\_TerrainAutoUpgrade
# 内容概述:该文件夹“_TerrainAutoUpgrade”内含多个地形层文件，用于游戏或模拟环境的地形数据更新。文件包括不同地形元素如草地、泥土、山和石头，以及特定纹理和示例层，旨在创建或升级地形环境。

24. 0_GameStart.unity
# 路径:D:/Unity/jyx2/Assets\0_GameStart.unity
# 内容概述:这是一个名为“0_GameStart.unity”的文件。

25. 0_Init.unity
# 路径:D:/Unity/jyx2/Assets\0_Init.unity
# 内容概述:这是一个名为“0_Init.unity”的文件。

26. 0_MainMenu.unity
# 路径:D:/Unity/jyx2/Assets\0_MainMenu.unity
# 内容概述:这是一个名为“0_MainMenu.unity”的文件。

27. 0_MODLoaderScene.unity
# 路径:D:/Unity/jyx2/Assets\0_MODLoaderScene.unity
# 内容概述:这是一个名为“0_MODLoaderScene.unity”的文件。

28. csc.rsp
# 路径:D:/Unity/jyx2/Assets\csc.rsp
# 内容概述:这是一个名为“csc.rsp”的文件。

29. icon.jpg
# 路径:D:/Unity/jyx2/Assets\icon.jpg
# 内容概述:这是一个名为“icon.jpg”的文件。

30. link.xml
# 路径:D:/Unity/jyx2/Assets\link.xml
# 内容概述:这是一个名为“link.xml”的文件。

31. mcs.rsp
# 路径:D:/Unity/jyx2/Assets\mcs.rsp
# 内容概述:这是一个名为“mcs.rsp”的文件。

32. StaticBakeObj.shader
# 路径:D:/Unity/jyx2/Assets\StaticBakeObj.shader
# 内容概述:该Shader文件“StaticBakeObj.shader”为Unity引擎中的自定义材质着色器，主要功能包括定义一系列视觉属性如轮廓颜色、宽度、发射纹理等，并在SubShader模块中实现渲染逻辑。它通过顶点处理和表面处理计算，结合Perlin噪声生成复杂纹理效果，支持轮廓、发光和溶解等视觉效果的渲染。


33. TapTapSlogan.png
# 路径:D:/Unity/jyx2/Assets\TapTapSlogan.png
# 内容概述:这是一个名为“TapTapSlogan.png”的文件。


2024-12-17 11:07:20,608 - INFO Retriever 0 - 
2024-12-17 11:07:20,610 - INFO Retriever 0 - ——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
2024-12-17 11:07:20,611 - INFO Retriever 0 - Assistant:
2024-12-17 11:07:20,611 - INFO Retriever 0 - {
    "deep_think": {
        "thoughts": "在获取了项目文件的顶层结构后，我还需要结合待查询的问题描述，对于项目中的文件和目录进行一些深度关键词检索。根据任务描述：“请在D:/Unity/jyx2\\Assets下各级目录中寻找：我想指定某个角色的所有战斗动画为固定的,而不是跟随技能招式变化应该修改哪个脚本”，我总结出如下可能会出现在各个文件名或者文件内容中的关键词：“['Battle animation', '技能招式', 'skill move', '技能', 'role', 'stuck', 'skill', 'fixed', '动画', '角色', 'animation', 'move', 'talent', 'Combat animation', '战斗', '招式', 'battle', '固定', '战斗动画', 'warfare', 'character']”，“['Battle animation', '技能招式', 'skill move', '技能', 'role', 'stuck', 'combat', 'skill', 'fixed', '动画', '角色', 'animation', 'move', 'talent', 'Combat animation', '战斗', '招式', 'battle', '固定', '战斗动画', 'character']”，“['combat animation', '技能招式', 'skill move', '技能', 'role', 'stuck', 'skill', 'fixed', '动画', '角色', 'animation', 'move', 'battle animation', 'talent', '战斗', '招式', 'battle', '固定', '战斗动画', 'warfare', 'character']”。\n接下来，我将使用retrieve_keywords操作，在项目顶层路径“D:/Unity/jyx2\\Assets”下检索这些关键词，从而大致把握可能与问题描述相关的文件或目录的路径。"
    }
}
2024-12-17 11:07:20,612 - INFO Retriever 0 - 
Observer:
2024-12-17 11:07:20,614 - INFO Retriever 0 - 好的，请继续你的下一步行动或思考。
2024-12-17 11:07:20,614 - INFO Retriever 0 - 
2024-12-17 11:07:20,637 - INFO Retriever 0 - ——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
2024-12-17 11:07:20,637 - INFO Retriever 0 - Assistant:
2024-12-17 11:07:20,643 - INFO Retriever 0 - {
    "retrieve_keywords": {
        "keyword_list": [
            [
                "Battle animation",
                "技能招式",
                "skill move",
                "技能",
                "role",
                "stuck",
                "skill",
                "fixed",
                "动画",
                "角色",
                "animation",
                "move",
                "talent",
                "Combat animation",
                "战斗",
                "招式",
                "battle",
                "固定",
                "战斗动画",
                "warfare",
                "character"
            ],
            [
                "Battle animation",
                "技能招式",
                "skill move",
                "技能",
                "role",
                "stuck",
                "combat",
                "skill",
                "fixed",
                "动画",
                "角色",
                "animation",
                "move",
                "talent",
                "Combat animation",
                "战斗",
                "招式",
                "battle",
                "固定",
                "战斗动画",
                "character"
            ],
            [
                "combat animation",
                "技能招式",
                "skill move",
                "技能",
                "role",
                "stuck",
                "skill",
                "fixed",
                "动画",
                "角色",
                "animation",
                "move",
                "battle animation",
                "talent",
                "战斗",
                "招式",
                "battle",
                "固定",
                "战斗动画",
                "warfare",
                "character"
            ]
        ]
    }
}
2024-12-17 11:07:20,648 - INFO Retriever 0 - 
Observer:
2024-12-17 11:07:20,649 - INFO Retriever 0 - * 文件一：
    * 文件绝对路径：D:\Unity\jyx2\Assets\Scripts\GameSave\RoleInstance.cs
    * 文件内容概述：该脚本定义了`RoleInstance`类，用于管理游戏中的角色实例，涵盖属性、技能、装备和战斗状态。类中方法包括初始化、属性调整、技能学习、装备使用、战斗准备和状态更新等。角色属性如等级、攻击力、防御力等通过`InitData`和`AddAttr`等方法管理，技能和装备通过`GetSkillsList`和`AddItem`等方法操作。战斗状态通过`EnterBattle`和`LeaveBattle`等方法控制，同时处理晕眩、复活和休息等状态变化。
    * 是否与问题相关：相关
    * 具体分析：该脚本负责管理角色实例，包括属性、技能、装备和战斗状态。虽然直接修改该脚本可能无法直接实现固定战斗动画，但了解角色实例的属性和技能管理机制有助于进一步分析其他相关脚本。

* 文件二：
    * 文件绝对路径：D:\Unity\jyx2\Assets\LuaScripts\Jyx2Battle\AIManager.lua
    * 文件内容概述：该脚本是金庸群侠传3D重制版游戏的Lua战斗AI模块，负责角色AI逻辑。模块初始化和反初始化，更新角色位置，并通过`GetAIResult`函数决策角色行动，如移动、攻击或休息。核心功能包括物品和技能管理，以及与敌人交互的策略计算。
    * 是否与问题相关：相关
    * 具体分析：该脚本负责角色AI逻辑，包括决策角色行动，如移动、攻击或休息。了解角色AI的逻辑有助于分析如何修改角色行动以实现固定战斗动画。

* 文件三：
    * 文件绝对路径：D:\Unity\jyx2\Assets\3rd\Animancer\Internal\Core\AnimancerState.cs
    * 文件内容概述：该脚本定义了`AnimancerState`类，作为动画状态管理的基类，它继承自`AnimancerNode`并实现`IAnimationClipCollection`接口。主要功能包括动画的播放控制、时间管理以及与动画图（Graph）的交互。类中实现了设置根节点、父节点、播放、停止动画，以及获取和设置动画时间等核心方法，支持动画的精确控制。此外，还定义了`Transition<TState>`类用于创建和管理特定类型的动画状态转换。
    * 是否与问题相关：相关
    * 具体分析：该脚本负责动画状态管理，包括动画的播放控制、时间管理以及与动画图（Graph）的交互。了解动画状态管理机制有助于分析如何修改动画状态以实现固定战斗动画。

* 文件四：
    * 文件绝对路径：D:\Unity\jyx2\Assets\Mods\JYX2\Skills\降龙十八掌.asset
    * 文件内容概述：该文件为Unity游戏中的“降龙十八掌”技能脚本，详细配置了动画（包括攻击、移动、闲置和受击动画）、特效（粒子效果及其参数）和音效（攻击和防御时的音效及其播放延迟）。此外，还设置了控制器和鬼影效果等属性。
    * 是否与问题相关：相关
    * 具体分析：该文件详细配置了“降龙十八掌”技能的动画、特效和音效，了解该技能的配置有助于分析如何修改其他技能的配置以实现固定战斗动画。

* 文件五：
    * 文件绝对路径：D:\Unity\jyx2\Assets\LuaScripts\Jyx2Battle\BattleInit.lua
    * 文件内容概述：该Lua脚本“BattleInit.lua”是金庸群侠传3D重制版战斗模块的初始化脚本。脚本中定义了技能覆盖类型常量，并通过`jy_utils.prequire`加载了伤害计算器、范围逻辑、AI管理和战斗管理器等模块，以供战斗逻辑使用。这些模块和常量被封装在`battle`表中，便于后续在游戏中调用。
    * 是否与问题相关：相关
    * 具体分析：该脚本负责战斗模块的初始化，加载了伤害计算器、范围逻辑、AI管理和战斗管理器等模块。了解战斗模块的初始化过程有助于分析如何修改相关模块以实现固定战斗动画。
2024-12-17 11:07:20,650 - INFO Retriever 0 - 
2024-12-17 11:07:30,367 - INFO Retriever 0 - Agent主脑给出的回答为：根据检索到的关键词，我找到了几个可能与问题描述相关的文件。接下来，我将使用read_file操作，读取这些文件的详细内容，以便进一步分析它们是否与指定角色战斗动画为固定的问题相关。
2024-12-17 11:07:30,367 - INFO Retriever 0 - 是否成功解析：True
2024-12-17 11:07:30,367 - INFO Retriever 0 - operation_type (__det_dir_action):
2024-12-17 11:07:30,367 - INFO Retriever 0 - 根据检索到的关键词，我找到了几个可能与问题描述相关的文件。
2024-12-17 11:07:30,368 - INFO Retriever 0 - 

——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
2024-12-17 11:07:30,368 - INFO Retriever 0 - Assistant:
2024-12-17 11:07:30,368 - INFO Retriever 0 - {
  "根据检索到的关键词，我找到了几个可能与问题描述相关的文件。": "接下来，我将使用read_file操作，读取这些文件的详细内容，以便进一步分析它们是否与指定角色战斗动画为固定的问题相关。"
}
2024-12-17 11:07:30,368 - INFO Retriever 0 - dict_keys(['根据检索到的关键词，我找到了几个可能与问题描述相关的文件。'])
2024-12-17 11:07:30,369 - WARNING Retriever 0 - 你给出的操作类型不属于指定的操作类型。可以进行的操作类型有：['get_folder_info', 'read_file', 'read_long_details', 'retrieve_keywords', 'deep_think']，请重新给出你的操作。
2024-12-17 11:07:30,370 - INFO Retriever 0 - 

————————————————————————————————————————————————————————————————
2024-12-17 11:07:30,370 - INFO Retriever 0 - 当前窗口总长度：11
2024-12-17 11:07:30,370 - INFO Retriever 0 - 当前更新窗口长度：2
2024-12-17 11:07:30,371 - INFO Retriever 0 - 当前更新窗口长度：2
2024-12-17 11:07:30,371 - INFO Retriever 0 - ————————————————————————————————————————————————————————————————


2024-12-17 11:07:34,494 - INFO Retriever 0 - Agent主脑给出的回答为：{
    "deep_think": {
        "thoughts": "根据检索到的关键词，我找到了几个可能与问题描述相关的文件。接下来，我将使用read_file操作，读取这些文件的详细内容，以便进一步分析它们是否与指定角色战斗动画为固定的问题相关。"
    }
}
2024-12-17 11:07:34,494 - INFO Retriever 0 - 是否成功解析：True
2024-12-17 11:07:34,494 - INFO Retriever 0 - operation_type (__det_dir_action):
2024-12-17 11:07:34,495 - INFO Retriever 0 - deep_think
2024-12-17 11:07:34,495 - INFO Retriever 0 - 

——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
2024-12-17 11:07:34,495 - INFO Retriever 0 - Assistant:
2024-12-17 11:07:34,495 - INFO Retriever 0 - {
    "deep_think": {
        "thoughts": "根据检索到的关键词，我找到了几个可能与问题描述相关的文件。接下来，我将使用read_file操作，读取这些文件的详细内容，以便进一步分析它们是否与指定角色战斗动画为固定的问题相关。"
    }
}
2024-12-17 11:07:34,495 - INFO Retriever 0 - dict_keys(['deep_think'])
2024-12-17 11:07:34,496 - INFO Retriever 0 - Agent主脑给出的行动：deep_think
参数：{'thoughts': '根据检索到的关键词，我找到了几个可能与问题描述相关的文件。接下来，我将使用read_file操作，读取这些文件的详细内容，以便进一步分析它们是否与指定角色战斗动画为固定的问题相关。', 'repeat_counter': 1, 'continue_think_counter': 1}
2024-12-17 11:07:34,496 - INFO Retriever 0 - Observer: 好的，请继续你的下一步行动或思考。
2024-12-17 11:07:34,497 - INFO Retriever 0 - 

————————————————————————————————————————————————————————————————
2024-12-17 11:07:34,498 - INFO Retriever 0 - 当前窗口总长度：13
2024-12-17 11:07:34,498 - INFO Retriever 0 - 当前更新窗口长度：4
2024-12-17 11:07:34,498 - INFO Retriever 0 - 当前更新窗口长度：4
2024-12-17 11:07:34,498 - INFO Retriever 0 - ————————————————————————————————————————————————————————————————


2024-12-17 11:07:37,682 - INFO Retriever 0 - Agent主脑给出的回答为：{
    "read_file": {
        "file_path": "D:\\Unity\\jyx2\\Assets\\Scripts\\GameSave\\RoleInstance.cs"
    }
}
2024-12-17 11:07:37,682 - INFO Retriever 0 - 是否成功解析：True
2024-12-17 11:07:37,682 - INFO Retriever 0 - operation_type (__det_dir_action):
2024-12-17 11:07:37,683 - INFO Retriever 0 - read_file
2024-12-17 11:07:37,683 - INFO Retriever 0 - 

——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
2024-12-17 11:07:37,683 - INFO Retriever 0 - Assistant:
2024-12-17 11:07:37,683 - INFO Retriever 0 - {
    "read_file": {
        "file_path": "D:\\Unity\\jyx2\\Assets\\Scripts\\GameSave\\RoleInstance.cs"
    }
}
2024-12-17 11:07:37,683 - INFO Retriever 0 - dict_keys(['read_file'])
2024-12-17 11:07:37,684 - INFO Retriever 0 - Agent主脑给出的行动：read_file
参数：{'file_path': 'D:\\Unity\\jyx2\\Assets\\Scripts\\GameSave\\RoleInstance.cs', 'top_path': 'D:/Unity/jyx2\\Assets', 'return_file_sum': <bound method TreeGenerationAction.return_file_sum of <Action.tree_gen_action.TreeGenerationAction object at 0x0000027D71AB0D90>>}
2024-12-17 11:07:37,729 - INFO Retriever 0 - Observer: 这是一个名为“RoleInstance.cs”的文件，该文件里的内容为：
由于脚本文件内容过长，暂时仅给出该脚本文件的内容总结:
- ### 总体概述
- **框架和模块化结构**：该脚本定义了一个名为 `RoleInstance` 的类，该类似乎用于管理游戏中的角色实例，包括其属性、技能、装备和状态。代码使用了模块化结构，通过使用不同的方法和属性来管理角色实例的不同方面。
- **主要功能和目标**：该脚本的主要功能是创建和管理游戏中的角色实例，包括角色的初始化、属性管理、技能学习、装备使用、战斗状态和状态更新。

### 模块和功能
- **角色属性管理**：管理角色的基础属性，如ID、姓名、等级、经验、攻击力、防御力等。
- **技能管理**：管理角色的技能列表，包括初始化、学习、升级和重置。
- **装备管理**：管理角色的装备，包括武器、防具和修炼物品。
- **战斗状态**：处理角色的战斗状态，包括进入战斗、退出战斗、集气槽增长、移动能力和行动力。
- **状态相关**：处理角色的状态，如晕眩、复活和休息。

### 类和函数
- **类**：`RoleInstance`
  - **作用**：表示游戏中的角色实例。
  - **关键功能**：属性管理、技能管理、装备管理、战斗状态和状态更新。
- **函数**：
  - `BindKey`：绑定角色ID并初始化数据。
  - `InitData`：初始化角色数据。
  - `ResetForBattle`：为战斗重置角色状态。
  - `Recover`：恢复角色生命值和体力。
  - `LevelUp`：角色升级。
  - `LimitAllAttrs`：限制所有属性的范围。
  - `AddAttr`：增加角色属性。
  - `GetSkillsList`：获取角色技能列表。
  - `ResetItems`：重置角色物品。
  - `AddItem`：为角色添加物品。
  - `CanUseItem`：判断角色是否可以使用道具。
  - `UseItem`：使用道具。
  - `UnequipItem`：卸下装备。
  - `LianZhiItem`：炼制物品。
  - `EnterBattle`：进入战斗。
  - `LeaveBattle`：退出战斗。
  - `TimeRun`：时间运行。
  - `IncSp`：集气槽增长。
  - `GetMoveAbility`：获取移动能力。
  - `IsDead`：判断角色是否死亡。
  - `Resurrect`：复活角色。
  - `Stun`：使角色晕眩。
  - `StopStun`：停止晕眩。
  - `OnRest`：休息逻辑。
  - `LearnMagic`：学习武学。
  - `Clone`：克隆角色实例。

### 实现逻辑
- **初始化**：通过 `BindKey` 方法绑定角色ID，并通过 `InitData` 方法初始化角色数据。
- **属性管理**：通过 `AddAttr` 方法增加角色属性，并通过 `LimitAllAttrs` 方法限制属性范围。
- **技能管理**：通过 `GetSkillsList` 方法获取角色技能列表，并通过 `LearnMagic` 方法学习新技能。
- **装备管理**：通过 `AddItem` 和 `UnequipItem` 方法管理角色装备。
- **战斗状态**：通过 `EnterBattle` 和 `LeaveBattle` 方法管理角色的战斗状态，并通过 `IncSp` 和 `GetMoveAbility` 方法管理移动能力和行动力。
- **状态相关**：通过 `Stun` 和 `StopStun` 方法管理角色的晕眩状态，并通过 `OnRest` 方法处理休息逻辑。
在这个脚本中存在如下的一些函数：AddAttr、AddItem、Anqi、AntiPoison、Armor、Attack、AttackPoison、BattleModel、BindKey、CanFinishedItem、CanLevelUp、CanUseItem、CanUseItem、Clone、CompareTo、CurrentSkill、Data、DePoison、Defence、EnterBattle、Exp、ExpForItem、ExpForMakeItem、ExpGot、GetArmor、GetArmorProperty、GetExtraAttack、GetFinishedExpForItem、GetFinishedExpForItem、GetHPColor1、GetHPColor2、GetJyx2RoleId、GetLevelUpExp、GetMPColor、GetMoveAbility、GetPic、GetSkillsList、GetWeapon、GetWeaponProperty、GetWugongLevel、GetXiulianItem、HaveItemBool、Heal、Hp、HpInc、Hurt、IQ、IncSp、InitData、InitData、IsAI、IsDead、IsPlayerRole、IsStun、Items、Jyx2、Key、LearnMagic、LeaveBattle、Level、LevelUp、LianZhiItem、LimitAllAttrs、LimitAttr、MaxHp、MaxMp、Model、Mp、MpType、Name、OnRest、Pinde、Poison、Pos、PreviousRoundHp、Qimen、Qinggong、Quanzhang、Random、Recover、ResetForBattle、ResetItems、ResetSkillCasts、Resurrect、RoleInstance、RoleInstance、RoleInstance、SetHPAndRefreshHudBar、Sex、Shengwang、Shuadao、Skills、StopStun、Stun、SwitchAnimationToSkill、Tili、TimeRun、UnequipItem、UpdateViewPostion、UseItem、UsePoison、View、Weapon、Wugongs、Wuxuechangshi、Xiulianwupin、Yujian、Zuoyouhubo、_currentSkill、_data、_isInBattle、_isStun、_pos、_thisType、checkUp、getLevelUpExp、isAI、isActed、isWaiting、movedStep、runtime、sp、team、testAttr
这些函数有以下详细信息：
- <summary> 升级属性计算公式可以参考：https://github.com/ZhanruiLiang/jinyong-legend </summary> <returns></returns> <summary> 限制属性范围 Attack、Defence、Qinggong为最终状态：原始属性 + 此刻使用的装备属性的总值 </summary> <summary> 角色专用的属性范围限制 </summary> <summary> 增加角色属性的API </summary> <param name="attrName">属性名</param> <param name="delta">属性增量</param> <returns>属性实际增量</returns> <summary> 战斗中使用的招式 </summary> <summary> 获取该角色所有的招式，（如果有医疗、用毒、解毒，也封装成招式） </summary> <returns></returns> <summary> 为角色添加物品 </summary> <param name="itemId"></param> <param name="count"></param> <summary> 判断角色是否可以使用道具 对应kyscpp：bool GameUtil::canUseItem(Role* r, Item* i) </summary> <param name="item"></param> <returns></returns> <summary> 炼制物品 计算公式可以参考：https://github.com/ZhanruiLiang/jinyong-legend </summary> <param name="item"></param> <summary> 使用物品 </summary> <param name="item"></param> <summary> 卸下物品（装备） </summary> <param name="item"></param> <summary> 获得修炼所需经验 </summary> <param name="item"></param> <returns></returns> <summary> 晕眩 </summary> <param name="duration">等于0时不晕眩；大于0时晕眩{duration}秒；小于0时永久晕眩</param> <summary> 获取武器武功配合加攻击力 计算方法参考：https://github.com/ZhanruiLiang/jinyong-legend 玄铁剑+玄铁剑法 攻击+100 君子剑+玉女素心剑 攻击+50 淑女剑+玉女素心剑 攻击+50 血刀+血刀大法 攻击+50 冷月宝刀+胡家刀法 攻击+70 金蛇剑+金蛇剑法 攻击力+80 霹雳狂刀+霹雳刀法 攻击+100 </summary> <param name="wugong"></param> <returns></returns>
- <summary> 升级属性计算公式可以参考：https://github.com/ZhanruiLiang/jinyong-legend </summary> <returns></returns> <summary> 限制属性范围 Attack、Defence、Qinggong为最终状态：原始属性 + 此刻使用的装备属性的总值 </summary> <summary> 角色专用的属性范围限制 </summary> <summary> 增加角色属性的API </summary> <param name="attrName">属性名</param> <param name="delta">属性增量</param> <returns>属性实际增量</returns> <summary> 战斗中使用的招式 </summary> <summary> 获取该角色所有的招式，（如果有医疗、用毒、解毒，也封装成招式） </summary> <returns></returns> <summary> 为角色添加物品 </summary> <param name="itemId"></param> <param name="count"></param> <summary> 判断角色是否可以使用道具 对应kyscpp：bool GameUtil::canUseItem(Role* r, Item* i) </summary> <param name="item"></param> <returns></returns> <summary> 炼制物品 计算公式可以参考：https://github.com/ZhanruiLiang/jinyong-legend </summary> <param name="item"></param> <summary> 使用物品 </summary> <param name="item"></param> <summary> 卸下物品（装备） </summary> <param name="item"></param> <summary> 获得修炼所需经验 </summary> <param name="item"></param> <returns></returns> <summary> 晕眩 </summary> <param name="duration">等于0时不晕眩；大于0时晕眩{duration}秒；小于0时永久晕眩</param> <summary> 获取武器武功配合加攻击力 计算方法参考：https://github.com/ZhanruiLiang/jinyong-legend 玄铁剑+玄铁剑法 攻击+100 君子剑+玉女素心剑 攻击+50 淑女剑+玉女素心剑 攻击+50 血刀+血刀大法 攻击+50 冷月宝刀+胡家刀法 攻击+70 金蛇剑+金蛇剑法 攻击力+80 霹雳狂刀+霹雳刀法 攻击+100 </summary> <param name="wugong"></param> <returns></returns>
- <summary> 升级属性计算公式可以参考：https://github.com/ZhanruiLiang/jinyong-legend </summary> <returns></returns> <summary> 限制属性范围 Attack、Defence、Qinggong为最终状态：原始属性 + 此刻使用的装备属性的总值 </summary> <summary> 角色专用的属性范围限制 </summary> <summary> 增加角色属性的API </summary> <param name="attrName">属性名</param> <param name="delta">属性增量</param> <returns>属性实际增量</returns> <summary> 战斗中使用的招式 </summary> <summary> 获取该角色所有的招式，（如果有医疗、用毒、解毒，也封装成招式） </summary> <returns></returns> <summary> 为角色添加物品 </summary> <param name="itemId"></param> <param name="count"></param> <summary> 判断角色是否可以使用道具 对应kyscpp：bool GameUtil::canUseItem(Role* r, Item* i) </summary> <param name="item"></param> <returns></returns> <summary> 炼制物品 计算公式可以参考：https://github.com/ZhanruiLiang/jinyong-legend </summary> <param name="item"></param> <summary> 使用物品 </summary> <param name="item"></param> <summary> 卸下物品（装备） </summary> <param name="item"></param> <summary> 获得修炼所需经验 </summary> <param name="item"></param> <returns></returns> <summary> 晕眩 </summary> <param name="duration">等于0时不晕眩；大于0时晕眩{duration}秒；小于0时永久晕眩</param> <summary> 获取武器武功配合加攻击力 计算方法参考：https://github.com/ZhanruiLiang/jinyong-legend 玄铁剑+玄铁剑法 攻击+100 君子剑+玉女素心剑 攻击+50 淑女剑+玉女素心剑 攻击+50 血刀+血刀大法 攻击+50 冷月宝刀+胡家刀法 攻击+70 金蛇剑+金蛇剑法 攻击力+80 霹雳狂刀+霹雳刀法 攻击+100 </summary> <param name="wugong"></param> <returns></returns>
- <summary> 获取该角色所有的招式，（如果有医疗、用毒、解毒，也封装成招式） </summary> <returns></returns>
- <summary> 晕眩 </summary> <param name="duration">等于0时不晕眩；大于0时晕眩{duration}秒；小于0时永久晕眩</param>
- <summary> 增加角色属性的API </summary> <param name="attrName">属性名</param> <param name="delta">属性增量</param> <returns>属性实际增量</returns>
2024-12-17 11:07:37,731 - INFO Retriever 0 - 

————————————————————————————————————————————————————————————————
2024-12-17 11:07:37,732 - INFO Retriever 0 - 当前窗口总长度：15
2024-12-17 11:07:37,732 - INFO Retriever 0 - 当前更新窗口长度：6
2024-12-17 11:07:37,732 - INFO Retriever 0 - 当前更新窗口长度：6
2024-12-17 11:07:37,732 - INFO Retriever 0 - ————————————————————————————————————————————————————————————————


2024-12-17 11:07:46,160 - INFO Retriever 0 - Agent主脑给出的回答为：根据文件内容概述，`RoleInstance.cs` 脚本似乎负责管理游戏中的角色实例，包括其属性、技能、装备和状态。虽然该脚本没有直接涉及动画控制，但了解角色实例的属性和技能管理机制对于分析如何修改角色行动以实现固定战斗动画是有帮助的。接下来，我将读取其他可能与问题描述相关的文件，以便进一步分析。
2024-12-17 11:07:46,160 - INFO Retriever 0 - 是否成功解析：True
2024-12-17 11:07:46,160 - INFO Retriever 0 - operation_type (__det_dir_action):
2024-12-17 11:07:46,161 - INFO Retriever 0 - 根据文件内容概述
2024-12-17 11:07:46,161 - INFO Retriever 0 - 

——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
2024-12-17 11:07:46,161 - INFO Retriever 0 - Assistant:
2024-12-17 11:07:46,161 - INFO Retriever 0 - {
  "根据文件内容概述": "RoleInstance.cs 脚本似乎负责管理游戏中的角色实例，包括其属性、技能、装备和状态。虽然该脚本没有直接涉及动画控制，但了解角色实例的属性和技能管理机制对于分析如何修改角色行动以实现固定战斗动画是有帮助的。接下来，我将读取其他可能与问题描述相关的文件，以便进一步分析。"
}
2024-12-17 11:07:46,161 - INFO Retriever 0 - dict_keys(['根据文件内容概述'])
2024-12-17 11:07:46,162 - WARNING Retriever 0 - 你给出的操作类型不属于指定的操作类型。可以进行的操作类型有：['get_folder_info', 'read_file', 'read_long_details', 'retrieve_keywords', 'deep_think']，请重新给出你的操作。
2024-12-17 11:07:46,164 - INFO Retriever 0 - 

————————————————————————————————————————————————————————————————
2024-12-17 11:07:46,164 - INFO Retriever 0 - 当前窗口总长度：17
2024-12-17 11:07:46,164 - INFO Retriever 0 - 当前更新窗口长度：8
2024-12-17 11:07:46,165 - INFO Retriever 0 - 当前更新窗口长度：8
2024-12-17 11:07:46,165 - INFO Retriever 0 - ————————————————————————————————————————————————————————————————


2024-12-17 11:07:50,403 - INFO Retriever 0 - Agent主脑给出的回答为：{
    "read_file": {
        "file_path": "D:\\Unity\\jyx2\\Assets\\LuaScripts\\Jyx2Battle\\AIManager.lua"
    }
}
2024-12-17 11:07:50,403 - INFO Retriever 0 - 是否成功解析：True
2024-12-17 11:07:50,403 - INFO Retriever 0 - operation_type (__det_dir_action):
2024-12-17 11:07:50,404 - INFO Retriever 0 - read_file
2024-12-17 11:07:50,404 - INFO Retriever 0 - 

——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
2024-12-17 11:07:50,404 - INFO Retriever 0 - Assistant:
2024-12-17 11:07:50,405 - INFO Retriever 0 - {
    "read_file": {
        "file_path": "D:\\Unity\\jyx2\\Assets\\LuaScripts\\Jyx2Battle\\AIManager.lua"
    }
}
2024-12-17 11:07:50,405 - INFO Retriever 0 - dict_keys(['read_file'])
2024-12-17 11:07:50,405 - INFO Retriever 0 - Agent主脑给出的行动：read_file
参数：{'file_path': 'D:\\Unity\\jyx2\\Assets\\LuaScripts\\Jyx2Battle\\AIManager.lua', 'top_path': 'D:/Unity/jyx2\\Assets', 'return_file_sum': <bound method TreeGenerationAction.return_file_sum of <Action.tree_gen_action.TreeGenerationAction object at 0x0000027D71AB0D90>>}
2024-12-17 11:07:50,449 - INFO Retriever 0 - Observer: 这是一个名为“AIManager.lua”的文件，该文件里的内容为：
由于脚本文件内容过长，暂时仅给出该脚本文件的内容总结:
- ### 总体概述
该脚本是一个Lua编写的游戏战斗AI模块，用于金庸群侠传3D重制版游戏中。它主要负责处理游戏中的角色AI逻辑，包括初始化、角色位置更新、AI决策和结果反馈。

### 模块和功能
- **初始化和反初始化**：`Init`和`DeInit`函数用于初始化和反初始化AI模块。
- **角色位置更新**：`RefreshRolePos`函数用于更新存活角色的位置信息。
- **AI决策**：`GetAIResult`函数是核心，它根据角色的状态和周围环境做出决策。
- **物品和技能管理**：包括获取可用物品、获取最近敌人、获取技能释放评分等功能。

### 类和函数
- **`ai`**：主要类，包含所有AI相关的函数和方法。
- **`Init`**：初始化AI模块，设置随机种子，加载技能和伤害计算器。
- **`DeInit`**：反初始化AI模块，清除资源。
- **`GetAIResult`**：获取AI决策结果，包括移动、攻击或休息。
- **`GetAvailableItems`**：获取角色可用的物品。
- **`GetNearestEnemy`**：获取最近的敌人角色。
- **`GetNearestEnemyBlock`**：获取最近的敌人位置。
- **`GetFarestEnemyBlock`**：获取离敌人最远的点。
- **`GetMoveAndCastPos`**：获取移动和施放技能的位置。
- **`GetSkillCastResultScore`**：计算技能释放的评分。
- **`MoveToNearestEnemy`**：移动到最近的敌人。
- **`Rest`**：原地休息。

### 实现逻辑
- **初始化**：加载必要的组件和资源。
- **角色位置更新**：定期更新存活角色的位置信息。
- **AI决策**：根据角色状态和周围环境，通过穷举搜索等方式，决定角色的下一步行动（移动、攻击或休息）。
- **结果反馈**：将AI决策的结果反馈给游戏引擎，以执行相应的动作。
在这个脚本中存在如下的一些函数：CheckPosRole、CheckRoleTeam、DeInit、GetAIResult、GetAvailableItems、GetCastScore、GetFarestEnemyBlock、GetMoveAndCastPos、GetNearestEnemy、GetNearestEnemyBlock、GetSkillCastResultScore、Init、MoveToNearestEnemy、RefreshRolePos、Rest、checkTeam
这些函数有以下详细信息：
- 技能是攻击技能时 如果目标位置没有人或者是队友，则跳过 目标格子和移动位置相同，自己包含在施放范围中 如果目标位置有人且是队友 获取技能释放评分 获取场上角色 角色位置 获取场上角色 角色位置 获取攻击方向 技能覆盖的坐标 四个方向循环 普通攻击伤害与距离成反比，需要寻找最近点放 用毒的时候根据角色血量选择策略 丢给自己的，随便乱跑一个地方丢 缓存常用数据 如果是点攻击，使用简化方案 尽量离非目标敌人远 与全部敌人的距离 技能施放位置与移动后位置之距离 如果aimpos == -1，说明这个位置打不到人 如果是攻击型，则远离敌人 非攻击型，靠近队友 如果是攻击型，则优先靠近目标，再次远离其他敌人 非攻击型，靠近队友 带攻击范围的，找最多人丢 最短距离乘以策略，只有策略不是0时，才考虑最短距离问题 打敌人时不打到队友 给队友加血不能加到敌人 还活着 local result = CS.AIManager.Instance:GetSkillResult(caster, targetRole, skill, blockVector); 解毒算分 医疗算分 用毒算分 暗器算分
- print(role.Name) 获得角色移动能力 行动范围 可使用招式 AI算法：穷举每个点，使用招式，取最大收益 profiler.start() 考虑吃药 如果身上有物品，进行物品相关初始化 使用体力药 使用生命药 如果血量太少，吃药优先级将特别高，防止npc沉迷打怪 使用内力药 使用解毒药 使用暗器 print("aqName"..anqiSkillCast.Anqi.Name.."score"..score.."mpos"..tmp[1]:ToInt().."cpos"..tmp[2]:ToInt()) print("No Item Use") 使用武学 print("skname:"..skill.Data.Name.." score"..score.."mpos"..tmp[1]:ToInt().."cpos"..tmp[2]:ToInt()) 如果前面可以得出结果，就反馈 否则靠近自己最近的敌人 否则原地休息 如果角色是玩家战友且是玩家队伍里面的 如果没有给被寻找的角色表，那就获取一份 寻找离自己最近的敌人 寻找离对手最近的一点 寻找一个点离敌人最远 遍历时过滤不可达的位置，以免引发异常 检查格子上是否有角色 返回0表示没有，返回1表示队友，返回2表示敌人 技能是攻击技能时 如果目标位置没有人或者是队友，则跳过 目标格子和移动位置相同，自己包含在施放范围中 如果目标位置有人且是队友 获取技能释放评分 获取场上角色 角色位置 获取场上角色 角色位置 获取攻击方向 技能覆盖的坐标 四个方向循环 普通攻击伤害与距离成反比，需要寻找最近点放 用毒的时候根据角色血量选择策略 丢给自己的，随便乱跑一个地方丢 缓存常用数据 如果是点攻击，使用简化方案 尽量离非目标敌人远 与全部敌人的距离 技能施放位置与移动后位置之距离 如果aimpos == -1，说明这个位置打不到人 如果是攻击型，则远离敌人 非攻击型，靠近队友 如果是攻击型，则优先靠近目标，再次远离其他敌人 非攻击型，靠近队友 带攻击范围的，找最多人丢 最短距离乘以策略，只有策略不是0时，才考虑最短距离问题 打敌人时不打到队友 给队友加血不能加到敌人 还活着 local result = CS.AIManager.Instance:GetSkillResult(caster, targetRole, skill, blockVector); 解毒算分 医疗算分 用毒算分 暗器算分
- 如果角色是玩家战友且是玩家队伍里面的
- 获取场上角色 角色位置 获取场上角色 角色位置 获取攻击方向 技能覆盖的坐标 四个方向循环 普通攻击伤害与距离成反比，需要寻找最近点放 用毒的时候根据角色血量选择策略 丢给自己的，随便乱跑一个地方丢 缓存常用数据 如果是点攻击，使用简化方案 尽量离非目标敌人远 与全部敌人的距离 技能施放位置与移动后位置之距离 如果aimpos == -1，说明这个位置打不到人 如果是攻击型，则远离敌人 非攻击型，靠近队友 如果是攻击型，则优先靠近目标，再次远离其他敌人 非攻击型，靠近队友 带攻击范围的，找最多人丢 最短距离乘以策略，只有策略不是0时，才考虑最短距离问题 打敌人时不打到队友 给队友加血不能加到敌人 还活着 local result = CS.AIManager.Instance:GetSkillResult(caster, targetRole, skill, blockVector); 解毒算分 医疗算分 用毒算分 暗器算分
- 寻找一个点离敌人最远 遍历时过滤不可达的位置，以免引发异常
- 普通攻击伤害与距离成反比，需要寻找最近点放 用毒的时候根据角色血量选择策略 丢给自己的，随便乱跑一个地方丢 缓存常用数据 如果是点攻击，使用简化方案 尽量离非目标敌人远 与全部敌人的距离 技能施放位置与移动后位置之距离 如果aimpos == -1，说明这个位置打不到人 如果是攻击型，则远离敌人 非攻击型，靠近队友 如果是攻击型，则优先靠近目标，再次远离其他敌人 非攻击型，靠近队友 带攻击范围的，找最多人丢 最短距离乘以策略，只有策略不是0时，才考虑最短距离问题 打敌人时不打到队友 给队友加血不能加到敌人 还活着 local result = CS.AIManager.Instance:GetSkillResult(caster, targetRole, skill, blockVector); 解毒算分 医疗算分 用毒算分 暗器算分
- 如果没有给被寻找的角色表，那就获取一份 寻找离自己最近的敌人
- 寻找离对手最近的一点
- 还活着 local result = CS.AIManager.Instance:GetSkillResult(caster, targetRole, skill, blockVector); 解毒算分 医疗算分 用毒算分 暗器算分
- print(role.Name) 获得角色移动能力 行动范围 可使用招式 AI算法：穷举每个点，使用招式，取最大收益 profiler.start() 考虑吃药 如果身上有物品，进行物品相关初始化 使用体力药 使用生命药 如果血量太少，吃药优先级将特别高，防止npc沉迷打怪 使用内力药 使用解毒药 使用暗器 print("aqName"..anqiSkillCast.Anqi.Name.."score"..score.."mpos"..tmp[1]:ToInt().."cpos"..tmp[2]:ToInt()) print("No Item Use") 使用武学 print("skname:"..skill.Data.Name.." score"..score.."mpos"..tmp[1]:ToInt().."cpos"..tmp[2]:ToInt()) 如果前面可以得出结果，就反馈 否则靠近自己最近的敌人 否则原地休息 如果角色是玩家战友且是玩家队伍里面的 如果没有给被寻找的角色表，那就获取一份 寻找离自己最近的敌人 寻找离对手最近的一点 寻找一个点离敌人最远 遍历时过滤不可达的位置，以免引发异常 检查格子上是否有角色 返回0表示没有，返回1表示队友，返回2表示敌人 技能是攻击技能时 如果目标位置没有人或者是队友，则跳过 目标格子和移动位置相同，自己包含在施放范围中 如果目标位置有人且是队友 获取技能释放评分 获取场上角色 角色位置 获取场上角色 角色位置 获取攻击方向 技能覆盖的坐标 四个方向循环 普通攻击伤害与距离成反比，需要寻找最近点放 用毒的时候根据角色血量选择策略 丢给自己的，随便乱跑一个地方丢 缓存常用数据 如果是点攻击，使用简化方案 尽量离非目标敌人远 与全部敌人的距离 技能施放位置与移动后位置之距离 如果aimpos == -1，说明这个位置打不到人 如果是攻击型，则远离敌人 非攻击型，靠近队友 如果是攻击型，则优先靠近目标，再次远离其他敌人 非攻击型，靠近队友 带攻击范围的，找最多人丢 最短距离乘以策略，只有策略不是0时，才考虑最短距离问题 打敌人时不打到队友 给队友加血不能加到敌人 还活着 local result = CS.AIManager.Instance:GetSkillResult(caster, targetRole, skill, blockVector); 解毒算分 医疗算分 用毒算分 暗器算分
- 打敌人时不打到队友 给队友加血不能加到敌人
2024-12-17 11:07:50,453 - INFO Retriever 0 - 

————————————————————————————————————————————————————————————————
2024-12-17 11:07:50,454 - INFO Retriever 0 - 当前窗口总长度：19
2024-12-17 11:07:50,454 - INFO Retriever 0 - 当前更新窗口长度：10
2024-12-17 11:07:50,454 - INFO Retriever 0 - 当前更新窗口长度：10
2024-12-17 11:07:50,454 - INFO Retriever 0 - ————————————————————————————————————————————————————————————————


2024-12-17 11:07:59,654 - INFO Retriever 0 - Agent主脑给出的回答为：根据文件内容概述，AIManager.lua 脚本负责处理游戏中的角色AI逻辑，包括初始化、角色位置更新、AI决策和结果反馈。虽然该脚本没有直接涉及动画控制，但了解角色AI的逻辑对于分析如何修改角色行动以实现固定战斗动画是有帮助的。接下来，我将读取其他可能与问题描述相关的文件，以便进一步分析。
2024-12-17 11:07:59,654 - INFO Retriever 0 - 是否成功解析：True
2024-12-17 11:07:59,655 - INFO Retriever 0 - operation_type (__det_dir_action):
2024-12-17 11:07:59,655 - INFO Retriever 0 - 根据文件内容概述
2024-12-17 11:07:59,655 - INFO Retriever 0 - 

——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
2024-12-17 11:07:59,655 - INFO Retriever 0 - Assistant:
2024-12-17 11:07:59,656 - INFO Retriever 0 - {
  "根据文件内容概述": "AIManager.lua 脚本负责处理游戏中的角色AI逻辑，包括初始化、角色位置更新、AI决策和结果反馈。虽然该脚本没有直接涉及动画控制，但了解角色AI的逻辑对于分析如何修改角色行动以实现固定战斗动画是有帮助的。接下来，我将读取其他可能与问题描述相关的文件，以便进一步分析。"
}
2024-12-17 11:07:59,656 - INFO Retriever 0 - dict_keys(['根据文件内容概述'])
2024-12-17 11:07:59,656 - WARNING Retriever 0 - 你给出的操作类型不属于指定的操作类型。可以进行的操作类型有：['get_folder_info', 'read_file', 'read_long_details', 'retrieve_keywords', 'deep_think']，请重新给出你的操作。
2024-12-17 11:07:59,657 - INFO Retriever 0 - 

————————————————————————————————————————————————————————————————
2024-12-17 11:07:59,658 - INFO Retriever 0 - 当前窗口总长度：21
2024-12-17 11:07:59,658 - INFO Retriever 0 - 当前更新窗口长度：12
2024-12-17 11:07:59,658 - INFO Retriever 0 - 当前更新窗口长度：12
2024-12-17 11:07:59,658 - INFO Retriever 0 - ————————————————————————————————————————————————————————————————


2024-12-17 11:08:04,560 - INFO Retriever 0 - Agent主脑给出的回答为：{
    "read_file": {
        "file_path": "D:\\Unity\\jyx2\\Assets\\3rd\\Animancer\\Internal\\Core\\AnimancerState.cs"
    }
}
2024-12-17 11:08:04,561 - INFO Retriever 0 - 是否成功解析：True
2024-12-17 11:08:04,561 - INFO Retriever 0 - operation_type (__det_dir_action):
2024-12-17 11:08:04,561 - INFO Retriever 0 - read_file
2024-12-17 11:08:04,561 - INFO Retriever 0 - 

——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
2024-12-17 11:08:04,562 - INFO Retriever 0 - Assistant:
2024-12-17 11:08:04,562 - INFO Retriever 0 - {
    "read_file": {
        "file_path": "D:\\Unity\\jyx2\\Assets\\3rd\\Animancer\\Internal\\Core\\AnimancerState.cs"
    }
}
2024-12-17 11:08:04,562 - INFO Retriever 0 - dict_keys(['read_file'])
2024-12-17 11:08:04,562 - INFO Retriever 0 - Agent主脑给出的行动：read_file
参数：{'file_path': 'D:\\Unity\\jyx2\\Assets\\3rd\\Animancer\\Internal\\Core\\AnimancerState.cs', 'top_path': 'D:/Unity/jyx2\\Assets', 'return_file_sum': <bound method TreeGenerationAction.return_file_sum of <Action.tree_gen_action.TreeGenerationAction object at 0x0000027D71AB0D90>>}
2024-12-17 11:08:04,588 - INFO Retriever 0 - Observer: 这是一个名为“AnimancerState.cs”的文件，该文件里的内容为：
由于脚本文件内容过长，暂时仅给出该脚本文件的内容总结:
- ### 总体概述
- **框架和模块化结构**：该脚本定义了一个名为 `AnimancerState` 的抽象类，它是用于管理动画播放状态的基类。该类继承自 `AnimancerNode` 并实现了 `IAnimationClipCollection` 接口。
- **主要功能和目标**：该脚本的主要目标是提供一个框架，用于在 `AnimancerPlayable` 图中管理一个或多个 `Playable` 对象，以控制动画的播放、暂停、停止和淡入淡出。

### 模块和功能
- **Graph 模块**：管理 `AnimancerPlayable` 图中的节点和连接。
- **Key and Clip 模块**：处理与动画剪辑相关的键和剪辑对象。
- **Playing 模块**：控制动画的播放、暂停和停止。
- **Timing 模块**：处理动画的时间控制和持续时间。
- **Methods 模块**：包含用于更新、销毁和收集动画剪辑的方法。

### 类和函数
- **类**：
  - `AnimancerState`：管理动画状态的基类。
  - `Transition<TState>`：用于创建特定类型 `AnimancerState` 的可序列化转换基类。
- **函数**：
  - `SetRoot`：设置动画图根节点。
  - `SetParent`：设置动画状态的父节点。
  - `Play`：立即播放动画。
  - `Stop`：停止动画。
  - `Time`：获取或设置动画的当前时间。
  - `Duration`：获取或设置动画的持续时间。

### 实现逻辑
- `AnimancerState` 类通过继承 `AnimancerNode` 和实现 `IAnimationClipCollection` 接口，提供了管理动画状态所需的基本功能。
- 通过 `SetRoot` 和 `SetParent` 方法，可以构建和管理动画图。
- `Play` 和 `Stop` 方法控制动画的播放状态。
- `Time` 和 `Duration` 属性允许精确控制动画的时间进度和持续时间。
在这个脚本中存在如下的一些函数：Animancer、AnimancerState、AppendDetails、AppendPath、AppendPortAndType、Apply、AverageAngularSpeed、AverageVelocity、AverageVelocity、BaseState、CancelSetTime、ClearParent、Clip、CreateDrawer、CreatePlayable、CreateState、Destroy、Duration、EffectiveWeight、Events、FadeDuration、FadeMode、GatherAnimationClips、GetPath、ITransition.CreateState、IsActive、IsLooping、IsLooping、IsPlaying、IsPlayingAndNotEnding、IsStopped、IsValid、Key、Key、Layer、LayerIndex、Length、MainObject、MainObject、MaximumDuration、Name、NestedObjectDrawers、NormalizedEndTime、NormalizedStartTime、NormalizedTime、Object、Object、OnSetIsPlaying、OnStartFade、Parent、Play、RawTime、RemainingDuration、SerializedEvents、SetParent、SetRoot、Speed、State、Stop、Time、ToString、ToString、Transition、Update、_Events、_FadeDuration、_IsPlaying、_IsPlayingDirty、_Key、_MustSetTime、_Parent、_State、_Time、_TimeFrameID
这些函数有以下详细信息：
- <summary> Base class for all states in an <see cref="AnimancerPlayable"/> graph which manages one or more <see cref="Playable"/>s. </summary> <remarks> This class can be used as a custom yield instruction to wait until the animation either stops playing or reaches its end. <para></para> Documentation: <see href="https://kybernetik.com.au/animancer/docs/manual/playing/states">States</see> </remarks> https://kybernetik.com.au/animancer/api/Animancer/AnimancerState <summary>The <see cref="AnimancerPlayable"/> at the root of the graph.</summary> <summary>The object which receives the output of the <see cref="Playable"/>.</summary> <summary>Connects this state to the `parent` mixer at the specified `index`.</summary> <remarks> Use <see cref="AnimancerLayer.AddChild(AnimancerState)"/> instead of this method to connect a state to an available port on a layer. </remarks> <summary>[Internal] Called by <see cref="AnimancerNode.OnAddChild(IList{AnimancerState}, AnimancerState)"/> if the specified port is already occupied so it can be cleared without triggering any other calls. </summary> <summary> The <see cref="AnimancerNode.Weight"/> of this state multiplied by the <see cref="AnimancerNode.Weight"/> of each of its parents down the hierarchy to determine how much this state affects the final output. </summary> <exception cref="NullReferenceException">This state has no <see cref="AnimancerNode.Parent"/>.</exception> <inheritdoc/> <summary> The index of the <see cref="AnimancerLayer"/> this state is connected to (determined by the <see cref="Parent"/>). </summary> <summary> The object used to identify this state in the root <see cref="AnimancerPlayable.States"/> dictionary. Can be null. </summary> <summary>The <see cref="AnimationClip"/> which this state plays (if any).</summary> <exception cref="NotSupportedException">This state type doesn't have a clip and you try to set it.</exception> <summary>The main object to show in the Inspector for this state (if any).</summary> <exception cref="NotSupportedException">This state type doesn't have a main object and you try to set it.</exception> <exception cref="InvalidCastException">This state can't use the assigned value.</exception> <summary> Sets the `currentObject` and calls <see cref="AnimancerNode.RecreatePlayable"/>. If the `currentObject` was being used as the <see cref="Key"/> then it is changed as well. </summary> <exception cref="ArgumentNullException">The `newObject` is null.</exception> <summary>The average velocity of the root motion caused by this state.</summary> <summary>Is the <see cref="Time"/> automatically advancing?</summary> <summary>Has <see cref="_IsPlaying"/> changed since it was last applied to the <see cref="Playable"/>.</summary> <remarks> Playables start playing by default so we start dirty to pause it during the first update (unless <see cref="IsPlaying"/> is set to true before that). </remarks> <summary>Is the <see cref="Time"/> automatically advancing?</summary> <example><code> void IsPlayingExample(AnimancerComponent animancer, AnimationClip clip) { var state = animancer.States.GetOrCreate(clip); if (state.IsPlaying) Debug.Log(clip + " is playing"); else Debug.Log(clip + " is paused"); state.IsPlaying = false;// Pause the animation. state.IsPlaying = true;// Unpause the animation. } </code></example> <summary>Called when the value of <see cref="IsPlaying"/> is changed.</summary> <summary>Creates and assigns the <see cref="Playable"/> managed by this state.</summary> <remarks>This method also applies the <see cref="AnimancerNode.Speed"/> and <see cref="IsPlaying"/>.</remarks> <summary> Returns true if this state is playing and is at or fading towards a non-zero <see cref="AnimancerNode.Weight"/>. </summary> <summary> Returns true if this state is not playing and is at 0 <see cref="AnimancerNode.Weight"/>. </summary> <summary>Plays this state immediately, without any blending.</summary> <remarks> Sets <see cref="IsPlaying"/> = true, <see cref="AnimancerNode.Weight"/> = 1, and clears the <see cref="Events"/> (unless <see cref="AutomaticallyClearEvents"/> is disabled). <para></para> This method does not change the <see cref="Time"/> so it will continue from its current value. </remarks> <summary>Stops the animation and makes it inactive immediately so it no longer affects the output.</summary> <remarks> Sets <see cref="AnimancerNode.Weight"/> = 0, <see cref="IsPlaying"/> = false, <see cref="Time"/> = 0, and clears the <see cref="Events"/> (unless <see cref="AutomaticallyClearEvents"/> is disabled). <para></para> To freeze the animation in place without ending it, you only need to set <see cref="IsPlaying"/> = false instead. Or to freeze all animations, you can call <see cref="AnimancerPlayable.PauseGraph"/>. </remarks> <summary> Called by <see cref="AnimancerNode.StartFade"/>. Clears the <see cref="Events"/> (unless <see cref="AutomaticallyClearEvents"/> is disabled). </summary> <summary> The current time of the <see cref="Playable"/>, retrieved by <see cref="Time"/> whenever the <see cref="_TimeFrameID"/> is different from the <see cref="AnimancerPlayable.FrameID"/>. </summary> <summary> Indicates whether the <see cref="_Time"/> needs to be assigned to the <see cref="Playable"/> next update. </summary> <remarks> <see cref="EventDispatcher"/> executes after all other playables, at which point changes can still be made to their time but not their weight which means that if we set the time immediately then it can be out of sync with the weight. For example, if an animation ends and you play another, the first animation would be stopped and rewinded to the start but would still be at full weight so it would show its first frame before the new animation actually takes effect (even if the previous animation was not looping). <para></para> So instead, we simply delay setting the actual playable time until the next update so that time and weight are always in sync. </remarks> <summary> The <see cref="AnimancerPlayable.FrameID"/> from when the <see cref="Time"/> was last retrieved from the <see cref="Playable"/>. </summary> <summary>The number of seconds that have passed since the start of this animation.</summary> <remarks> This value will continue increasing after the animation passes the end of its <see cref="Length"/> while the animated object either freezes in place or starts again from the beginning according to whether it is looping or not. <para></para> This property internally uses <see cref="RawTime"/> whenever the value is out of date or gets changed. <para></para> <em>Animancer Lite does not allow this value to be changed in runtime builds (except resetting it to 0).</em> </remarks> <example><code> void PlayAnimation(AnimancerComponent animancer, AnimationClip clip) { var state = animancer.Play(clip); // Skip 0.5 seconds into the animation: state.Time = 0.5f; // Skip 50% of the way through the animation (0.5 in a range of 0 to 1): state.NormalizedTime = 0.5f; // Skip to the end of the animation and play backwards. state.NormalizedTime = 1; state.Speed = -1; } </code></example> <summary> The internal implementation of <see cref="Time"/> which directly gets and sets the underlying value. </summary> <remarks> Setting this value actually calls <see cref="PlayableExtensions.SetTime"/> twice to ensure that animation events aren't triggered incorrectly. Calling it only once would trigger any animation events between the previous time and the new time. So if an animation plays to the end and you set the time back to 0 (such as by calling <see cref="Stop"/> or playing a different animation), the next time that animation played it would immediately trigger all of its events, then play through and trigger them normally as well. </remarks> <summary> The <see cref="Time"/> of this state as a portion of the animation's <see cref="Length"/>, meaning the value goes from 0 to 1 as it plays from start to end, regardless of how long that actually takes. </summary> <remarks> This value will continue increasing after the animation passes the end of its <see cref="Length"/> while the animated object either freezes in place or starts again from the beginning according to whether it is looping or not. <para></para> The fractional part of the value (<c>NormalizedTime % 1</c>) is the percentage (0-1) of progress in the current loop while the integer part (<c>(int)NormalizedTime</c>) is the number of times the animation has been looped. <para></para> <em>Animancer Lite does not allow this value to be changed to a value other than 0 in runtime builds.</em> </remarks> <example><code> void PlayAnimation(AnimancerComponent animancer, AnimationClip clip) { var state = animancer.Play(clip); // Skip 0.5 seconds into the animation: state.Time = 0.5f; // Skip 50% of the way through the animation (0.5 in a range of 0 to 1): state.NormalizedTime = 0.5f; // Skip to the end of the animation and play backwards. state.NormalizedTime = 1; state.Speed = -1; } </code></example> <summary>Prevents the <see cref="RawTime"/> from being applied.</summary> <summary>[Pro-Only] The <see cref="NormalizedTime"/> after which the <see cref="AnimancerEvent.Sequence.OnEnd"/> callback will be invoked every frame. </summary> <remarks> This is a wrapper around <see cref="AnimancerEvent.Sequence.NormalizedEndTime"/> so that if the value has not been set (<see cref="float.NaN"/>) it can be determined based on the <see cref="AnimancerNode.EffectiveSpeed"/>: positive speed ends at 1 and negative speed ends at 0. <para></para> <em>Animancer Lite does not allow this value to be changed in runtime builds.</em> </remarks> <summary> The number of seconds the animation will take to play fully at its current <see cref="AnimancerNode.EffectiveSpeed"/>. </summary> <remarks> For the time remaining from now until it reaches the end, use <see cref="RemainingDuration"/> instead. <para></para> Setting this value modifies the <see cref="AnimancerNode.EffectiveSpeed"/>, not the <see cref="Length"/>. <para></para> <em>Animancer Lite does not allow this value to be changed in runtime builds.</em> </remarks> <example><code> void PlayAnimation(AnimancerComponent animancer, AnimationClip clip) { var state = animancer.Play(clip); state.Duration = 1;// Play fully in 1 second. state.Duration = 2;// Play fully in 2 seconds. state.Duration = 0.5f;// Play fully in half a second. state.Duration = -1;// Play backwards fully in 1 second. state.NormalizedTime = 1; state.Duration = -1;// Play backwards from the end in 1 second. } </code></example> <summary> The number of seconds this state will take to go from its current <see cref="NormalizedTime"/> to the <see cref="NormalizedEndTime"/> at its current <see cref="AnimancerNode.EffectiveSpeed"/>. </summary> <remarks> For the time it would take to play fully from the start, use the <see cref="Duration"/> instead. <para></para> Setting this value modifies the <see cref="AnimancerNode.EffectiveSpeed"/>, not the <see cref="Length"/>. <para></para> <em>Animancer Lite does not allow this value to be changed in runtime builds.</em> </remarks> <example><code> void PlayAnimation(AnimancerComponent animancer, AnimationClip clip) { var state = animancer.Play(clip); state.RemainingDuration = 1;// Play from the current time to the end in 1 second. state.RemainingDuration = 2;// Play from the current time to the end in 2 seconds. state.RemainingDuration = 0.5f;// Play from the current time to the end in half a second. state.RemainingDuration = -1;// Play from the current time away from the end. } </code></example> <summary>The total time this state would take to play in seconds when <see cref="AnimancerNode.Speed"/> = 1.</summary> <summary>Will this state loop back to the start when it reaches the end?</summary> <summary> Updates the <see cref="AnimancerNode.Weight"/> for fading, applies it to this state's port on the parent mixer, and plays or pauses the <see cref="Playable"/> if its state is dirty. </summary> <remarks> If the <see cref="Parent"/>'s <see cref="AnimancerNode.KeepChildrenConnected"/> is set to false, this method will also connect/disconnect this node from the <see cref="Parent"/> in the playable graph. </remarks> <summary>Destroys the <see cref="Playable"/> and cleans up this state.</summary> <remarks> This method is NOT called automatically, so when implementing a custom state type you must use <see cref="AnimancerPlayable.Disposables"/> if you need to guarantee that things will get cleaned up. </remarks> <summary>[<see cref="IAnimationClipCollection"/>] Gathers all the animations in this state.</summary> <summary> Returns true if the animation is playing and has not yet passed the <see cref="AnimancerEvent.Sequence.endEvent"/>. </summary> <remarks> This method is called by <see cref="IEnumerator.MoveNext"/> so this object can be used as a custom yield instruction to wait until it finishes. </remarks> <summary> Returns the <see cref="AnimancerNode.DebugName"/> if one is set, otherwise a string describing the type of this state and the name of the <see cref="MainObject"/>. </summary> <summary>[Editor-Only] Returns a custom drawer for this state.</summary> <inheritdoc/> <summary>Returns the hierarchy path of this state through its <see cref="Parent"/>s.</summary> <summary>Appends the hierarchy path of this state through its <see cref="Parent"/>s.</summary> <summary>Appends "[Index] -> GetType().Name".</summary> <summary> Base class for serializable <see cref="ITransition"/>s which can create a particular type of <see cref="AnimancerState"/> when passed into <see cref="AnimancerPlayable.Play(ITransition)"/>. </summary> <remarks> Unfortunately the tool used to generate this documentation does not currently support nested types with identical names, so only one <c>Transition</c> class will actually have a documentation page. <para></para> Even though it has the <see cref="SerializableAttribute"/>, this class won't actually get serialized by Unity because it's generic and abstract. Each child class still needs to include the attribute. <para></para> Documentation: <see href="https://kybernetik.com.au/animancer/docs/manual/transitions">Transitions</see> </remarks> https://kybernetik.com.au/animancer/api/Animancer/Transition_1 <summary>[<see cref="SerializeField"/>] The amount of time the transition will take (in seconds).</summary> <exception cref="ArgumentOutOfRangeException">Thrown when setting the value to a negative number.</exception> <summary>[<see cref="ITransitionDetailed"/>] Indicates what the value of <see cref="AnimancerState.IsLooping"/> will be for the created state. Returns false unless overridden. </summary> <summary>[<see cref="ITransitionDetailed"/>] Determines what <see cref="NormalizedTime"/> to start the animation at. Returns <see cref="float.NaN"/> unless overridden. </summary> <summary>[<see cref="ITransitionDetailed"/>] Determines how fast the animation plays (1x = normal speed). Returns 1 unless overridden. </summary> <summary>[<see cref="ITransitionDetailed"/>] The maximum amount of time the animation is expected to take (in seconds). </summary> <remarks>The actual duration can vary in states like <see cref="MixerState"/>.</remarks> <summary>[<see cref="ITransitionDetailed"/>] The <see cref="Motion.averageAngularSpeed"/> that the created state will have. </summary> <remarks>The actual average velocity can vary in states like <see cref="MixerState"/>.</remarks> <summary>[<see cref="ITransitionDetailed"/>] The <see cref="Motion.averageSpeed"/> that the created state will have. </summary> <remarks>The actual average velocity can vary in states like <see cref="MixerState"/>.</remarks> <summary>[<see cref="SerializeField"/>] [<see cref="ITransitionDetailed"/>] Events which will be triggered as the animation plays. </summary> <remarks>This property returns the <see cref="AnimancerEvent.Sequence.Serializable.Sequence"/>.</remarks> <summary>[<see cref="SerializeField"/>] [<see cref="ITransitionDetailed"/>] Events which will be triggered as the animation plays. </summary> <summary> The state that was created by this object. Specifically, this is the state that was most recently passed into <see cref="Apply"/> (usually by <see cref="AnimancerPlayable.Play(ITransition)"/>). <para></para> You can use <see cref="AnimancerPlayable.StateDictionary.GetOrCreate(ITransition)"/> or <see cref="AnimancerLayer.GetOrCreateState(ITransition)"/> to get or create the state for a specific object. <para></para> <see cref="State"/> is simply a shorthand for casting this to <typeparamref name="TState"/>. </summary> <summary> The state that was created by this object. Specifically, this is the state that was most recently passed into <see cref="Apply"/> (usually by <see cref="AnimancerPlayable.Play(ITransition)"/>). </summary> <remarks> You can use <see cref="AnimancerPlayable.StateDictionary.GetOrCreate(ITransition)"/> or <see cref="AnimancerLayer.GetOrCreateState(ITransition)"/> to get or create the state for a specific object. <para></para> This property is shorthand for casting the <see cref="BaseState"/> to <typeparamref name="TState"/>. </remarks> <exception cref="InvalidCastException"> The <see cref="BaseState"/> is not actually a <typeparamref name="TState"/>. This should only happen if a different type of state was created by something else and registered using the <see cref="Key"/>, causing this <see cref="AnimancerPlayable.Play(ITransition)"/> to pass that state into <see cref="Apply"/> instead of calling <see cref="CreateState"/> to make the correct type of state. </exception> <summary>Indicates whether this transition can create a valid <see cref="AnimancerState"/>.</summary> <summary>The <see cref="AnimancerState.Key"/> which the created state will be registered with.</summary> <remarks>Returns <c>this</c> unless overridden.</remarks> <summary> When a transition is passed into <see cref="AnimancerPlayable.Play(ITransition)"/>, this property determines which <see cref="Animancer.FadeMode"/> will be used. </summary> <summary>Creates and returns a new <typeparamref name="TState"/>.</summary> <remarks> Note that using methods like <see cref="AnimancerPlayable.Play(ITransition)"/> will also call <see cref="Apply"/>, so if you call this method manually you may want to call that method as well. Or you can just use <see cref="AnimancerUtilities.CreateStateAndApply"/>. </remarks> <summary>Creates and returns a new <typeparamref name="TState"/>.</summary> <remarks> Note that using methods like <see cref="AnimancerPlayable.Play(ITransition)"/> will also call <see cref="Apply"/>, so if you call this method manually you may want to call that method as well. Or you can just use <see cref="AnimancerUtilities.CreateStateAndApply"/>. </remarks> <summary>[<see cref="ITransition"/>] Sets the <see cref="BaseState"/> and applies any other modifications to the `state`. </summary> <remarks> Called by <see cref="AnimancerPlayable.Play(ITransition)"/>. <para></para> This method also clears the <see cref="State"/> if necessary, so it will re-cast the <see cref="BaseState"/> when it gets accessed again. </remarks> <summary>The <see cref="AnimancerState.MainObject"/> that the created state will have.</summary> <summary>The display name of this transition.</summary> <summary>Returns the <see cref="Name"/> and type of this transition.</summary> <summary>[Editor-Only] Don't use Inspector Gadgets Nested Object Drawers.</summary>
- <summary>The <see cref="AnimancerPlayable"/> at the root of the graph.</summary> <summary>The object which receives the output of the <see cref="Playable"/>.</summary> <summary>Connects this state to the `parent` mixer at the specified `index`.</summary> <remarks> Use <see cref="AnimancerLayer.AddChild(AnimancerState)"/> instead of this method to connect a state to an available port on a layer. </remarks> <summary>[Internal] Called by <see cref="AnimancerNode.OnAddChild(IList{AnimancerState}, AnimancerState)"/> if the specified port is already occupied so it can be cleared without triggering any other calls. </summary> <summary> The <see cref="AnimancerNode.Weight"/> of this state multiplied by the <see cref="AnimancerNode.Weight"/> of each of its parents down the hierarchy to determine how much this state affects the final output. </summary> <exception cref="NullReferenceException">This state has no <see cref="AnimancerNode.Parent"/>.</exception> <inheritdoc/> <summary> The index of the <see cref="AnimancerLayer"/> this state is connected to (determined by the <see cref="Parent"/>). </summary> <summary> The object used to identify this state in the root <see cref="AnimancerPlayable.States"/> dictionary. Can be null. </summary> <summary>The <see cref="AnimationClip"/> which this state plays (if any).</summary> <exception cref="NotSupportedException">This state type doesn't have a clip and you try to set it.</exception> <summary>The main object to show in the Inspector for this state (if any).</summary> <exception cref="NotSupportedException">This state type doesn't have a main object and you try to set it.</exception> <exception cref="InvalidCastException">This state can't use the assigned value.</exception> <summary> Sets the `currentObject` and calls <see cref="AnimancerNode.RecreatePlayable"/>. If the `currentObject` was being used as the <see cref="Key"/> then it is changed as well. </summary> <exception cref="ArgumentNullException">The `newObject` is null.</exception> <summary>The average velocity of the root motion caused by this state.</summary> <summary>Is the <see cref="Time"/> automatically advancing?</summary> <summary>Has <see cref="_IsPlaying"/> changed since it was last applied to the <see cref="Playable"/>.</summary> <remarks> Playables start playing by default so we start dirty to pause it during the first update (unless <see cref="IsPlaying"/> is set to true before that). </remarks> <summary>Is the <see cref="Time"/> automatically advancing?</summary> <example><code> void IsPlayingExample(AnimancerComponent animancer, AnimationClip clip) { var state = animancer.States.GetOrCreate(clip); if (state.IsPlaying) Debug.Log(clip + " is playing"); else Debug.Log(clip + " is paused"); state.IsPlaying = false;// Pause the animation. state.IsPlaying = true;// Unpause the animation. } </code></example> <summary>Called when the value of <see cref="IsPlaying"/> is changed.</summary> <summary>Creates and assigns the <see cref="Playable"/> managed by this state.</summary> <remarks>This method also applies the <see cref="AnimancerNode.Speed"/> and <see cref="IsPlaying"/>.</remarks> <summary> Returns true if this state is playing and is at or fading towards a non-zero <see cref="AnimancerNode.Weight"/>. </summary> <summary> Returns true if this state is not playing and is at 0 <see cref="AnimancerNode.Weight"/>. </summary> <summary>Plays this state immediately, without any blending.</summary> <remarks> Sets <see cref="IsPlaying"/> = true, <see cref="AnimancerNode.Weight"/> = 1, and clears the <see cref="Events"/> (unless <see cref="AutomaticallyClearEvents"/> is disabled). <para></para> This method does not change the <see cref="Time"/> so it will continue from its current value. </remarks> <summary>Stops the animation and makes it inactive immediately so it no longer affects the output.</summary> <remarks> Sets <see cref="AnimancerNode.Weight"/> = 0, <see cref="IsPlaying"/> = false, <see cref="Time"/> = 0, and clears the <see cref="Events"/> (unless <see cref="AutomaticallyClearEvents"/> is disabled). <para></para> To freeze the animation in place without ending it, you only need to set <see cref="IsPlaying"/> = false instead. Or to freeze all animations, you can call <see cref="AnimancerPlayable.PauseGraph"/>. </remarks> <summary> Called by <see cref="AnimancerNode.StartFade"/>. Clears the <see cref="Events"/> (unless <see cref="AutomaticallyClearEvents"/> is disabled). </summary> <summary> The current time of the <see cref="Playable"/>, retrieved by <see cref="Time"/> whenever the <see cref="_TimeFrameID"/> is different from the <see cref="AnimancerPlayable.FrameID"/>. </summary> <summary> Indicates whether the <see cref="_Time"/> needs to be assigned to the <see cref="Playable"/> next update. </summary> <remarks> <see cref="EventDispatcher"/> executes after all other playables, at which point changes can still be made to their time but not their weight which means that if we set the time immediately then it can be out of sync with the weight. For example, if an animation ends and you play another, the first animation would be stopped and rewinded to the start but would still be at full weight so it would show its first frame before the new animation actually takes effect (even if the previous animation was not looping). <para></para> So instead, we simply delay setting the actual playable time until the next update so that time and weight are always in sync. </remarks> <summary> The <see cref="AnimancerPlayable.FrameID"/> from when the <see cref="Time"/> was last retrieved from the <see cref="Playable"/>. </summary> <summary>The number of seconds that have passed since the start of this animation.</summary> <remarks> This value will continue increasing after the animation passes the end of its <see cref="Length"/> while the animated object either freezes in place or starts again from the beginning according to whether it is looping or not. <para></para> This property internally uses <see cref="RawTime"/> whenever the value is out of date or gets changed. <para></para> <em>Animancer Lite does not allow this value to be changed in runtime builds (except resetting it to 0).</em> </remarks> <example><code> void PlayAnimation(AnimancerComponent animancer, AnimationClip clip) { var state = animancer.Play(clip); // Skip 0.5 seconds into the animation: state.Time = 0.5f; // Skip 50% of the way through the animation (0.5 in a range of 0 to 1): state.NormalizedTime = 0.5f; // Skip to the end of the animation and play backwards. state.NormalizedTime = 1; state.Speed = -1; } </code></example> <summary> The internal implementation of <see cref="Time"/> which directly gets and sets the underlying value. </summary> <remarks> Setting this value actually calls <see cref="PlayableExtensions.SetTime"/> twice to ensure that animation events aren't triggered incorrectly. Calling it only once would trigger any animation events between the previous time and the new time. So if an animation plays to the end and you set the time back to 0 (such as by calling <see cref="Stop"/> or playing a different animation), the next time that animation played it would immediately trigger all of its events, then play through and trigger them normally as well. </remarks> <summary> The <see cref="Time"/> of this state as a portion of the animation's <see cref="Length"/>, meaning the value goes from 0 to 1 as it plays from start to end, regardless of how long that actually takes. </summary> <remarks> This value will continue increasing after the animation passes the end of its <see cref="Length"/> while the animated object either freezes in place or starts again from the beginning according to whether it is looping or not. <para></para> The fractional part of the value (<c>NormalizedTime % 1</c>) is the percentage (0-1) of progress in the current loop while the integer part (<c>(int)NormalizedTime</c>) is the number of times the animation has been looped. <para></para> <em>Animancer Lite does not allow this value to be changed to a value other than 0 in runtime builds.</em> </remarks> <example><code> void PlayAnimation(AnimancerComponent animancer, AnimationClip clip) { var state = animancer.Play(clip); // Skip 0.5 seconds into the animation: state.Time = 0.5f; // Skip 50% of the way through the animation (0.5 in a range of 0 to 1): state.NormalizedTime = 0.5f; // Skip to the end of the animation and play backwards. state.NormalizedTime = 1; state.Speed = -1; } </code></example> <summary>Prevents the <see cref="RawTime"/> from being applied.</summary> <summary>[Pro-Only] The <see cref="NormalizedTime"/> after which the <see cref="AnimancerEvent.Sequence.OnEnd"/> callback will be invoked every frame. </summary> <remarks> This is a wrapper around <see cref="AnimancerEvent.Sequence.NormalizedEndTime"/> so that if the value has not been set (<see cref="float.NaN"/>) it can be determined based on the <see cref="AnimancerNode.EffectiveSpeed"/>: positive speed ends at 1 and negative speed ends at 0. <para></para> <em>Animancer Lite does not allow this value to be changed in runtime builds.</em> </remarks> <summary> The number of seconds the animation will take to play fully at its current <see cref="AnimancerNode.EffectiveSpeed"/>. </summary> <remarks> For the time remaining from now until it reaches the end, use <see cref="RemainingDuration"/> instead. <para></para> Setting this value modifies the <see cref="AnimancerNode.EffectiveSpeed"/>, not the <see cref="Length"/>. <para></para> <em>Animancer Lite does not allow this value to be changed in runtime builds.</em> </remarks> <example><code> void PlayAnimation(AnimancerComponent animancer, AnimationClip clip) { var state = animancer.Play(clip); state.Duration = 1;// Play fully in 1 second. state.Duration = 2;// Play fully in 2 seconds. state.Duration = 0.5f;// Play fully in half a second. state.Duration = -1;// Play backwards fully in 1 second. state.NormalizedTime = 1; state.Duration = -1;// Play backwards from the end in 1 second. } </code></example> <summary> The number of seconds this state will take to go from its current <see cref="NormalizedTime"/> to the <see cref="NormalizedEndTime"/> at its current <see cref="AnimancerNode.EffectiveSpeed"/>. </summary> <remarks> For the time it would take to play fully from the start, use the <see cref="Duration"/> instead. <para></para> Setting this value modifies the <see cref="AnimancerNode.EffectiveSpeed"/>, not the <see cref="Length"/>. <para></para> <em>Animancer Lite does not allow this value to be changed in runtime builds.</em> </remarks> <example><code> void PlayAnimation(AnimancerComponent animancer, AnimationClip clip) { var state = animancer.Play(clip); state.RemainingDuration = 1;// Play from the current time to the end in 1 second. state.RemainingDuration = 2;// Play from the current time to the end in 2 seconds. state.RemainingDuration = 0.5f;// Play from the current time to the end in half a second. state.RemainingDuration = -1;// Play from the current time away from the end. } </code></example> <summary>The total time this state would take to play in seconds when <see cref="AnimancerNode.Speed"/> = 1.</summary> <summary>Will this state loop back to the start when it reaches the end?</summary> <summary> Updates the <see cref="AnimancerNode.Weight"/> for fading, applies it to this state's port on the parent mixer, and plays or pauses the <see cref="Playable"/> if its state is dirty. </summary> <remarks> If the <see cref="Parent"/>'s <see cref="AnimancerNode.KeepChildrenConnected"/> is set to false, this method will also connect/disconnect this node from the <see cref="Parent"/> in the playable graph. </remarks> <summary>Destroys the <see cref="Playable"/> and cleans up this state.</summary> <remarks> This method is NOT called automatically, so when implementing a custom state type you must use <see cref="AnimancerPlayable.Disposables"/> if you need to guarantee that things will get cleaned up. </remarks> <summary>[<see cref="IAnimationClipCollection"/>] Gathers all the animations in this state.</summary> <summary> Returns true if the animation is playing and has not yet passed the <see cref="AnimancerEvent.Sequence.endEvent"/>. </summary> <remarks> This method is called by <see cref="IEnumerator.MoveNext"/> so this object can be used as a custom yield instruction to wait until it finishes. </remarks> <summary> Returns the <see cref="AnimancerNode.DebugName"/> if one is set, otherwise a string describing the type of this state and the name of the <see cref="MainObject"/>. </summary> <summary>[Editor-Only] Returns a custom drawer for this state.</summary> <inheritdoc/> <summary>Returns the hierarchy path of this state through its <see cref="Parent"/>s.</summary> <summary>Appends the hierarchy path of this state through its <see cref="Parent"/>s.</summary> <summary>Appends "[Index] -> GetType().Name".</summary> <summary> Base class for serializable <see cref="ITransition"/>s which can create a particular type of <see cref="AnimancerState"/> when passed into <see cref="AnimancerPlayable.Play(ITransition)"/>. </summary> <remarks> Unfortunately the tool used to generate this documentation does not currently support nested types with identical names, so only one <c>Transition</c> class will actually have a documentation page. <para></para> Even though it has the <see cref="SerializableAttribute"/>, this class won't actually get serialized by Unity because it's generic and abstract. Each child class still needs to include the attribute. <para></para> Documentation: <see href="https://kybernetik.com.au/animancer/docs/manual/transitions">Transitions</see> </remarks> https://kybernetik.com.au/animancer/api/Animancer/Transition_1 <summary>[<see cref="SerializeField"/>] The amount of time the transition will take (in seconds).</summary> <exception cref="ArgumentOutOfRangeException">Thrown when setting the value to a negative number.</exception> <summary>[<see cref="ITransitionDetailed"/>] Indicates what the value of <see cref="AnimancerState.IsLooping"/> will be for the created state. Returns false unless overridden. </summary> <summary>[<see cref="ITransitionDetailed"/>] Determines what <see cref="NormalizedTime"/> to start the animation at. Returns <see cref="float.NaN"/> unless overridden. </summary> <summary>[<see cref="ITransitionDetailed"/>] Determines how fast the animation plays (1x = normal speed). Returns 1 unless overridden. </summary> <summary>[<see cref="ITransitionDetailed"/>] The maximum amount of time the animation is expected to take (in seconds). </summary> <remarks>The actual duration can vary in states like <see cref="MixerState"/>.</remarks> <summary>[<see cref="ITransitionDetailed"/>] The <see cref="Motion.averageAngularSpeed"/> that the created state will have. </summary> <remarks>The actual average velocity can vary in states like <see cref="MixerState"/>.</remarks> <summary>[<see cref="ITransitionDetailed"/>] The <see cref="Motion.averageSpeed"/> that the created state will have. </summary> <remarks>The actual average velocity can vary in states like <see cref="MixerState"/>.</remarks> <summary>[<see cref="SerializeField"/>] [<see cref="ITransitionDetailed"/>] Events which will be triggered as the animation plays. </summary> <remarks>This property returns the <see cref="AnimancerEvent.Sequence.Serializable.Sequence"/>.</remarks> <summary>[<see cref="SerializeField"/>] [<see cref="ITransitionDetailed"/>] Events which will be triggered as the animation plays. </summary> <summary> The state that was created by this object. Specifically, this is the state that was most recently passed into <see cref="Apply"/> (usually by <see cref="AnimancerPlayable.Play(ITransition)"/>). <para></para> You can use <see cref="AnimancerPlayable.StateDictionary.GetOrCreate(ITransition)"/> or <see cref="AnimancerLayer.GetOrCreateState(ITransition)"/> to get or create the state for a specific object. <para></para> <see cref="State"/> is simply a shorthand for casting this to <typeparamref name="TState"/>. </summary> <summary> The state that was created by this object. Specifically, this is the state that was most recently passed into <see cref="Apply"/> (usually by <see cref="AnimancerPlayable.Play(ITransition)"/>). </summary> <remarks> You can use <see cref="AnimancerPlayable.StateDictionary.GetOrCreate(ITransition)"/> or <see cref="AnimancerLayer.GetOrCreateState(ITransition)"/> to get or create the state for a specific object. <para></para> This property is shorthand for casting the <see cref="BaseState"/> to <typeparamref name="TState"/>. </remarks> <exception cref="InvalidCastException"> The <see cref="BaseState"/> is not actually a <typeparamref name="TState"/>. This should only happen if a different type of state was created by something else and registered using the <see cref="Key"/>, causing this <see cref="AnimancerPlayable.Play(ITransition)"/> to pass that state into <see cref="Apply"/> instead of calling <see cref="CreateState"/> to make the correct type of state. </exception> <summary>Indicates whether this transition can create a valid <see cref="AnimancerState"/>.</summary> <summary>The <see cref="AnimancerState.Key"/> which the created state will be registered with.</summary> <remarks>Returns <c>this</c> unless overridden.</remarks> <summary> When a transition is passed into <see cref="AnimancerPlayable.Play(ITransition)"/>, this property determines which <see cref="Animancer.FadeMode"/> will be used. </summary> <summary>Creates and returns a new <typeparamref name="TState"/>.</summary> <remarks> Note that using methods like <see cref="AnimancerPlayable.Play(ITransition)"/> will also call <see cref="Apply"/>, so if you call this method manually you may want to call that method as well. Or you can just use <see cref="AnimancerUtilities.CreateStateAndApply"/>. </remarks> <summary>Creates and returns a new <typeparamref name="TState"/>.</summary> <remarks> Note that using methods like <see cref="AnimancerPlayable.Play(ITransition)"/> will also call <see cref="Apply"/>, so if you call this method manually you may want to call that method as well. Or you can just use <see cref="AnimancerUtilities.CreateStateAndApply"/>. </remarks> <summary>[<see cref="ITransition"/>] Sets the <see cref="BaseState"/> and applies any other modifications to the `state`. </summary> <remarks> Called by <see cref="AnimancerPlayable.Play(ITransition)"/>. <para></para> This method also clears the <see cref="State"/> if necessary, so it will re-cast the <see cref="BaseState"/> when it gets accessed again. </remarks> <summary>The <see cref="AnimancerState.MainObject"/> that the created state will have.</summary> <summary>The display name of this transition.</summary> <summary>Returns the <see cref="Name"/> and type of this transition.</summary> <summary>[Editor-Only] Don't use Inspector Gadgets Nested Object Drawers.</summary>
- <summary>[<see cref="ITransitionDetailed"/>] The <see cref="Motion.averageSpeed"/> that the created state will have. </summary> <remarks>The actual average velocity can vary in states like <see cref="MixerState"/>.</remarks> <summary>[<see cref="SerializeField"/>] [<see cref="ITransitionDetailed"/>] Events which will be triggered as the animation plays. </summary> <remarks>This property returns the <see cref="AnimancerEvent.Sequence.Serializable.Sequence"/>.</remarks> <summary>[<see cref="SerializeField"/>] [<see cref="ITransitionDetailed"/>] Events which will be triggered as the animation plays. </summary> <summary> The state that was created by this object. Specifically, this is the state that was most recently passed into <see cref="Apply"/> (usually by <see cref="AnimancerPlayable.Play(ITransition)"/>). <para></para> You can use <see cref="AnimancerPlayable.StateDictionary.GetOrCreate(ITransition)"/> or <see cref="AnimancerLayer.GetOrCreateState(ITransition)"/> to get or create the state for a specific object. <para></para> <see cref="State"/> is simply a shorthand for casting this to <typeparamref name="TState"/>. </summary>
- <summary>[<see cref="SerializeField"/>] [<see cref="ITransitionDetailed"/>] Events which will be triggered as the animation plays. </summary> <remarks>This property returns the <see cref="AnimancerEvent.Sequence.Serializable.Sequence"/>.</remarks> <summary>[<see cref="SerializeField"/>] [<see cref="ITransitionDetailed"/>] Events which will be triggered as the animation plays. </summary> <summary> The state that was created by this object. Specifically, this is the state that was most recently passed into <see cref="Apply"/> (usually by <see cref="AnimancerPlayable.Play(ITransition)"/>). <para></para> You can use <see cref="AnimancerPlayable.StateDictionary.GetOrCreate(ITransition)"/> or <see cref="AnimancerLayer.GetOrCreateState(ITransition)"/> to get or create the state for a specific object. <para></para> <see cref="State"/> is simply a shorthand for casting this to <typeparamref name="TState"/>. </summary>
- <summary>Is the <see cref="Time"/> automatically advancing?</summary> <summary>Has <see cref="_IsPlaying"/> changed since it was last applied to the <see cref="Playable"/>.</summary> <remarks> Playables start playing by default so we start dirty to pause it during the first update (unless <see cref="IsPlaying"/> is set to true before that). </remarks> <summary>Is the <see cref="Time"/> automatically advancing?</summary> <example><code> void IsPlayingExample(AnimancerComponent animancer, AnimationClip clip) { var state = animancer.States.GetOrCreate(clip); if (state.IsPlaying) Debug.Log(clip + " is playing"); else Debug.Log(clip + " is paused"); state.IsPlaying = false;// Pause the animation. state.IsPlaying = true;// Unpause the animation. }
- <summary>[Pro-Only] The <see cref="NormalizedTime"/> after which the <see cref="AnimancerEvent.Sequence.OnEnd"/> callback will be invoked every frame. </summary> <remarks> This is a wrapper around <see cref="AnimancerEvent.Sequence.NormalizedEndTime"/> so that if the value has not been set (<see cref="float.NaN"/>) it can be determined based on the <see cref="AnimancerNode.EffectiveSpeed"/>: positive speed ends at 1 and negative speed ends at 0. <para></para> <em>Animancer Lite does not allow this value to be changed in runtime builds.</em> </remarks>
- <inheritdoc/>
- <summary>Creates and returns a new <typeparamref name="TState"/>.</summary> <remarks> Note that using methods like <see cref="AnimancerPlayable.Play(ITransition)"/> will also call <see cref="Apply"/>, so if you call this method manually you may want to call that method as well. Or you can just use <see cref="AnimancerUtilities.CreateStateAndApply"/>. </remarks> <summary>[<see cref="ITransition"/>] Sets the <see cref="BaseState"/> and applies any other modifications to the `state`. </summary> <remarks> Called by <see cref="AnimancerPlayable.Play(ITransition)"/>. <para></para> This method also clears the <see cref="State"/> if necessary, so it will re-cast the <see cref="BaseState"/> when it gets accessed again. </remarks>
- <summary>[<see cref="SerializeField"/>] [<see cref="ITransitionDetailed"/>] Events which will be triggered as the animation plays. </summary> <summary> The state that was created by this object. Specifically, this is the state that was most recently passed into <see cref="Apply"/> (usually by <see cref="AnimancerPlayable.Play(ITransition)"/>). <para></para> You can use <see cref="AnimancerPlayable.StateDictionary.GetOrCreate(ITransition)"/> or <see cref="AnimancerLayer.GetOrCreateState(ITransition)"/> to get or create the state for a specific object. <para></para> <see cref="State"/> is simply a shorthand for casting this to <typeparamref name="TState"/>. </summary>
- <summary>Creates and returns a new <typeparamref name="TState"/>.</summary> <remarks> Note that using methods like <see cref="AnimancerPlayable.Play(ITransition)"/> will also call <see cref="Apply"/>, so if you call this method manually you may want to call that method as well. Or you can just use <see cref="AnimancerUtilities.CreateStateAndApply"/>. </remarks> <summary>Creates and returns a new <typeparamref name="TState"/>.</summary> <remarks> Note that using methods like <see cref="AnimancerPlayable.Play(ITransition)"/> will also call <see cref="Apply"/>, so if you call this method manually you may want to call that method as well. Or you can just use <see cref="AnimancerUtilities.CreateStateAndApply"/>. </remarks> <summary>[<see cref="ITransition"/>] Sets the <see cref="BaseState"/> and applies any other modifications to the `state`. </summary> <remarks> Called by <see cref="AnimancerPlayable.Play(ITransition)"/>. <para></para> This method also clears the <see cref="State"/> if necessary, so it will re-cast the <see cref="BaseState"/> when it gets accessed again. </remarks>
- <summary> Returns true if the animation is playing and has not yet passed the <see cref="AnimancerEvent.Sequence.endEvent"/>. </summary> <remarks> This method is called by <see cref="IEnumerator.MoveNext"/> so this object can be used as a custom yield instruction to wait until it finishes. </remarks>
- <summary>[<see cref="ITransition"/>] Sets the <see cref="BaseState"/> and applies any other modifications to the `state`. </summary> <remarks> Called by <see cref="AnimancerPlayable.Play(ITransition)"/>. <para></para> This method also clears the <see cref="State"/> if necessary, so it will re-cast the <see cref="BaseState"/> when it gets accessed again. </remarks>
- <summary> Returns true if this state is not playing and is at 0 <see cref="AnimancerNode.Weight"/>. </summary> <summary>Plays this state immediately, without any blending.</summary> <remarks> Sets <see cref="IsPlaying"/> = true, <see cref="AnimancerNode.Weight"/> = 1, and clears the <see cref="Events"/> (unless <see cref="AutomaticallyClearEvents"/> is disabled). <para></para> This method does not change the <see cref="Time"/> so it will continue from its current value. </remarks>
- <summary>[<see cref="ITransitionDetailed"/>] Determines what <see cref="NormalizedTime"/> to start the animation at. Returns <see cref="float.NaN"/> unless overridden. </summary>
- <summary> Updates the <see cref="AnimancerNode.Weight"/> for fading, applies it to this state's port on the parent mixer, and plays or pauses the <see cref="Playable"/> if its state is dirty. </summary> <remarks> If the <see cref="Parent"/>'s <see cref="AnimancerNode.KeepChildrenConnected"/> is set to false, this method will also connect/disconnect this node from the <see cref="Parent"/> in the playable graph. </remarks>
- <summary>Plays this state immediately, without any blending.</summary> <remarks> Sets <see cref="IsPlaying"/> = true, <see cref="AnimancerNode.Weight"/> = 1, and clears the <see cref="Events"/> (unless <see cref="AutomaticallyClearEvents"/> is disabled). <para></para> This method does not change the <see cref="Time"/> so it will continue from its current value. </remarks>
- <summary>The <see cref="AnimancerState.Key"/> which the created state will be registered with.</summary> <remarks>Returns <c>this</c> unless overridden.</remarks> <summary> When a transition is passed into <see cref="AnimancerPlayable.Play(ITransition)"/>, this property determines which <see cref="Animancer.FadeMode"/> will be used. </summary> <summary>Creates and returns a new <typeparamref name="TState"/>.</summary> <remarks> Note that using methods like <see cref="AnimancerPlayable.Play(ITransition)"/> will also call <see cref="Apply"/>, so if you call this method manually you may want to call that method as well. Or you can just use <see cref="AnimancerUtilities.CreateStateAndApply"/>. </remarks> <summary>Creates and returns a new <typeparamref name="TState"/>.</summary> <remarks> Note that using methods like <see cref="AnimancerPlayable.Play(ITransition)"/> will also call <see cref="Apply"/>, so if you call this method manually you may want to call that method as well. Or you can just use <see cref="AnimancerUtilities.CreateStateAndApply"/>. </remarks> <summary>[<see cref="ITransition"/>] Sets the <see cref="BaseState"/> and applies any other modifications to the `state`. </summary> <remarks> Called by <see cref="AnimancerPlayable.Play(ITransition)"/>. <para></para> This method also clears the <see cref="State"/> if necessary, so it will re-cast the <see cref="BaseState"/> when it gets accessed again. </remarks>
- <summary> When a transition is passed into <see cref="AnimancerPlayable.Play(ITransition)"/>, this property determines which <see cref="Animancer.FadeMode"/> will be used. </summary> <summary>Creates and returns a new <typeparamref name="TState"/>.</summary> <remarks> Note that using methods like <see cref="AnimancerPlayable.Play(ITransition)"/> will also call <see cref="Apply"/>, so if you call this method manually you may want to call that method as well. Or you can just use <see cref="AnimancerUtilities.CreateStateAndApply"/>. </remarks> <summary>Creates and returns a new <typeparamref name="TState"/>.</summary> <remarks> Note that using methods like <see cref="AnimancerPlayable.Play(ITransition)"/> will also call <see cref="Apply"/>, so if you call this method manually you may want to call that method as well. Or you can just use <see cref="AnimancerUtilities.CreateStateAndApply"/>. </remarks> <summary>[<see cref="ITransition"/>] Sets the <see cref="BaseState"/> and applies any other modifications to the `state`. </summary> <remarks> Called by <see cref="AnimancerPlayable.Play(ITransition)"/>. <para></para> This method also clears the <see cref="State"/> if necessary, so it will re-cast the <see cref="BaseState"/> when it gets accessed again. </remarks>
- <summary> The index of the <see cref="AnimancerLayer"/> this state is connected to (determined by the <see cref="Parent"/>). </summary>
- <summary> Base class for all states in an <see cref="AnimancerPlayable"/> graph which manages one or more <see cref="Playable"/>s. </summary> <remarks> This class can be used as a custom yield instruction to wait until the animation either stops playing or reaches its end. <para></para> Documentation: <see href="https://kybernetik.com.au/animancer/docs/manual/playing/states">States</see> </remarks> https://kybernetik.com.au/animancer/api/Animancer/AnimancerState <summary>The <see cref="AnimancerPlayable"/> at the root of the graph.</summary> <summary>The object which receives the output of the <see cref="Playable"/>.</summary> <summary>Connects this state to the `parent` mixer at the specified `index`.</summary> <remarks> Use <see cref="AnimancerLayer.AddChild(AnimancerState)"/> instead of this method to connect a state to an available port on a layer. </remarks> <summary>[Internal] Called by <see cref="AnimancerNode.OnAddChild(IList{AnimancerState}, AnimancerState)"/> if the specified port is already occupied so it can be cleared without triggering any other calls. </summary> <summary> The <see cref="AnimancerNode.Weight"/> of this state multiplied by the <see cref="AnimancerNode.Weight"/> of each of its parents down the hierarchy to determine how much this state affects the final output. </summary> <exception cref="NullReferenceException">This state has no <see cref="AnimancerNode.Parent"/>.</exception> <inheritdoc/> <summary> The index of the <see cref="AnimancerLayer"/> this state is connected to (determined by the <see cref="Parent"/>). </summary> <summary> The object used to identify this state in the root <see cref="AnimancerPlayable.States"/> dictionary. Can be null. </summary> <summary>The <see cref="AnimationClip"/> which this state plays (if any).</summary> <exception cref="NotSupportedException">This state type doesn't have a clip and you try to set it.</exception> <summary>The main object to show in the Inspector for this state (if any).</summary> <exception cref="NotSupportedException">This state type doesn't have a main object and you try to set it.</exception> <exception cref="InvalidCastException">This state can't use the assigned value.</exception> <summary> Sets the `currentObject` and calls <see cref="AnimancerNode.RecreatePlayable"/>. If the `currentObject` was being used as the <see cref="Key"/> then it is changed as well. </summary> <exception cref="ArgumentNullException">The `newObject` is null.</exception> <summary>The average velocity of the root motion caused by this state.</summary> <summary>Is the <see cref="Time"/> automatically advancing?</summary> <summary>Has <see cref="_IsPlaying"/> changed since it was last applied to the <see cref="Playable"/>.</summary> <remarks> Playables start playing by default so we start dirty to pause it during the first update (unless <see cref="IsPlaying"/> is set to true before that). </remarks> <summary>Is the <see cref="Time"/> automatically advancing?</summary> <example><code> void IsPlayingExample(AnimancerComponent animancer, AnimationClip clip) { var state = animancer.States.GetOrCreate(clip); if (state.IsPlaying) Debug.Log(clip + " is playing"); else Debug.Log(clip + " is paused"); state.IsPlaying = false;// Pause the animation. state.IsPlaying = true;// Unpause the animation. } </code></example> <summary>Called when the value of <see cref="IsPlaying"/> is changed.</summary> <summary>Creates and assigns the <see cref="Playable"/> managed by this state.</summary> <remarks>This method also applies the <see cref="AnimancerNode.Speed"/> and <see cref="IsPlaying"/>.</remarks> <summary> Returns true if this state is playing and is at or fading towards a non-zero <see cref="AnimancerNode.Weight"/>. </summary> <summary> Returns true if this state is not playing and is at 0 <see cref="AnimancerNode.Weight"/>. </summary> <summary>Plays this state immediately, without any blending.</summary> <remarks> Sets <see cref="IsPlaying"/> = true, <see cref="AnimancerNode.Weight"/> = 1, and clears the <see cref="Events"/> (unless <see cref="AutomaticallyClearEvents"/> is disabled). <para></para> This method does not change the <see cref="Time"/> so it will continue from its current value. </remarks> <summary>Stops the animation and makes it inactive immediately so it no longer affects the output.</summary> <remarks> Sets <see cref="AnimancerNode.Weight"/> = 0, <see cref="IsPlaying"/> = false, <see cref="Time"/> = 0, and clears the <see cref="Events"/> (unless <see cref="AutomaticallyClearEvents"/> is disabled). <para></para> To freeze the animation in place without ending it, you only need to set <see cref="IsPlaying"/> = false instead. Or to freeze all animations, you can call <see cref="AnimancerPlayable.PauseGraph"/>. </remarks> <summary> Called by <see cref="AnimancerNode.StartFade"/>. Clears the <see cref="Events"/> (unless <see cref="AutomaticallyClearEvents"/> is disabled). </summary> <summary> The current time of the <see cref="Playable"/>, retrieved by <see cref="Time"/> whenever the <see cref="_TimeFrameID"/> is different from the <see cref="AnimancerPlayable.FrameID"/>. </summary> <summary> Indicates whether the <see cref="_Time"/> needs to be assigned to the <see cref="Playable"/> next update. </summary> <remarks> <see cref="EventDispatcher"/> executes after all other playables, at which point changes can still be made to their time but not their weight which means that if we set the time immediately then it can be out of sync with the weight. For example, if an animation ends and you play another, the first animation would be stopped and rewinded to the start but would still be at full weight so it would show its first frame before the new animation actually takes effect (even if the previous animation was not looping). <para></para> So instead, we simply delay setting the actual playable time until the next update so that time and weight are always in sync. </remarks> <summary> The <see cref="AnimancerPlayable.FrameID"/> from when the <see cref="Time"/> was last retrieved from the <see cref="Playable"/>. </summary> <summary>The number of seconds that have passed since the start of this animation.</summary> <remarks> This value will continue increasing after the animation passes the end of its <see cref="Length"/> while the animated object either freezes in place or starts again from the beginning according to whether it is looping or not. <para></para> This property internally uses <see cref="RawTime"/> whenever the value is out of date or gets changed. <para></para> <em>Animancer Lite does not allow this value to be changed in runtime builds (except resetting it to 0).</em> </remarks> <example><code> void PlayAnimation(AnimancerComponent animancer, AnimationClip clip) { var state = animancer.Play(clip); // Skip 0.5 seconds into the animation: state.Time = 0.5f; // Skip 50% of the way through the animation (0.5 in a range of 0 to 1): state.NormalizedTime = 0.5f; // Skip to the end of the animation and play backwards. state.NormalizedTime = 1; state.Speed = -1; } </code></example> <summary> The internal implementation of <see cref="Time"/> which directly gets and sets the underlying value. </summary> <remarks> Setting this value actually calls <see cref="PlayableExtensions.SetTime"/> twice to ensure that animation events aren't triggered incorrectly. Calling it only once would trigger any animation events between the previous time and the new time. So if an animation plays to the end and you set the time back to 0 (such as by calling <see cref="Stop"/> or playing a different animation), the next time that animation played it would immediately trigger all of its events, then play through and trigger them normally as well. </remarks> <summary> The <see cref="Time"/> of this state as a portion of the animation's <see cref="Length"/>, meaning the value goes from 0 to 1 as it plays from start to end, regardless of how long that actually takes. </summary> <remarks> This value will continue increasing after the animation passes the end of its <see cref="Length"/> while the animated object either freezes in place or starts again from the beginning according to whether it is looping or not. <para></para> The fractional part of the value (<c>NormalizedTime % 1</c>) is the percentage (0-1) of progress in the current loop while the integer part (<c>(int)NormalizedTime</c>) is the number of times the animation has been looped. <para></para> <em>Animancer Lite does not allow this value to be changed to a value other than 0 in runtime builds.</em> </remarks> <example><code> void PlayAnimation(AnimancerComponent animancer, AnimationClip clip) { var state = animancer.Play(clip); // Skip 0.5 seconds into the animation: state.Time = 0.5f; // Skip 50% of the way through the animation (0.5 in a range of 0 to 1): state.NormalizedTime = 0.5f; // Skip to the end of the animation and play backwards. state.NormalizedTime = 1; state.Speed = -1; } </code></example> <summary>Prevents the <see cref="RawTime"/> from being applied.</summary> <summary>[Pro-Only] The <see cref="NormalizedTime"/> after which the <see cref="AnimancerEvent.Sequence.OnEnd"/> callback will be invoked every frame. </summary> <remarks> This is a wrapper around <see cref="AnimancerEvent.Sequence.NormalizedEndTime"/> so that if the value has not been set (<see cref="float.NaN"/>) it can be determined based on the <see cref="AnimancerNode.EffectiveSpeed"/>: positive speed ends at 1 and negative speed ends at 0. <para></para> <em>Animancer Lite does not allow this value to be changed in runtime builds.</em> </remarks> <summary> The number of seconds the animation will take to play fully at its current <see cref="AnimancerNode.EffectiveSpeed"/>. </summary> <remarks> For the time remaining from now until it reaches the end, use <see cref="RemainingDuration"/> instead. <para></para> Setting this value modifies the <see cref="AnimancerNode.EffectiveSpeed"/>, not the <see cref="Length"/>. <para></para> <em>Animancer Lite does not allow this value to be changed in runtime builds.</em> </remarks> <example><code> void PlayAnimation(AnimancerComponent animancer, AnimationClip clip) { var state = animancer.Play(clip); state.Duration = 1;// Play fully in 1 second. state.Duration = 2;// Play fully in 2 seconds. state.Duration = 0.5f;// Play fully in half a second. state.Duration = -1;// Play backwards fully in 1 second. state.NormalizedTime = 1; state.Duration = -1;// Play backwards from the end in 1 second. } </code></example> <summary> The number of seconds this state will take to go from its current <see cref="NormalizedTime"/> to the <see cref="NormalizedEndTime"/> at its current <see cref="AnimancerNode.EffectiveSpeed"/>. </summary> <remarks> For the time it would take to play fully from the start, use the <see cref="Duration"/> instead. <para></para> Setting this value modifies the <see cref="AnimancerNode.EffectiveSpeed"/>, not the <see cref="Length"/>. <para></para> <em>Animancer Lite does not allow this value to be changed in runtime builds.</em> </remarks> <example><code> void PlayAnimation(AnimancerComponent animancer, AnimationClip clip) { var state = animancer.Play(clip); state.RemainingDuration = 1;// Play from the current time to the end in 1 second. state.RemainingDuration = 2;// Play from the current time to the end in 2 seconds. state.RemainingDuration = 0.5f;// Play from the current time to the end in half a second. state.RemainingDuration = -1;// Play from the current time away from the end. } </code></example> <summary>The total time this state would take to play in seconds when <see cref="AnimancerNode.Speed"/> = 1.</summary> <summary>Will this state loop back to the start when it reaches the end?</summary> <summary> Updates the <see cref="AnimancerNode.Weight"/> for fading, applies it to this state's port on the parent mixer, and plays or pauses the <see cref="Playable"/> if its state is dirty. </summary> <remarks> If the <see cref="Parent"/>'s <see cref="AnimancerNode.KeepChildrenConnected"/> is set to false, this method will also connect/disconnect this node from the <see cref="Parent"/> in the playable graph. </remarks> <summary>Destroys the <see cref="Playable"/> and cleans up this state.</summary> <remarks> This method is NOT called automatically, so when implementing a custom state type you must use <see cref="AnimancerPlayable.Disposables"/> if you need to guarantee that things will get cleaned up. </remarks> <summary>[<see cref="IAnimationClipCollection"/>] Gathers all the animations in this state.</summary> <summary> Returns true if the animation is playing and has not yet passed the <see cref="AnimancerEvent.Sequence.endEvent"/>. </summary> <remarks> This method is called by <see cref="IEnumerator.MoveNext"/> so this object can be used as a custom yield instruction to wait until it finishes. </remarks> <summary> Returns the <see cref="AnimancerNode.DebugName"/> if one is set, otherwise a string describing the type of this state and the name of the <see cref="MainObject"/>. </summary> <summary>[Editor-Only] Returns a custom drawer for this state.</summary> <inheritdoc/> <summary>Returns the hierarchy path of this state through its <see cref="Parent"/>s.</summary> <summary>Appends the hierarchy path of this state through its <see cref="Parent"/>s.</summary> <summary>Appends "[Index] -> GetType().Name".</summary> <summary> Base class for serializable <see cref="ITransition"/>s which can create a particular type of <see cref="AnimancerState"/> when passed into <see cref="AnimancerPlayable.Play(ITransition)"/>. </summary> <remarks> Unfortunately the tool used to generate this documentation does not currently support nested types with identical names, so only one <c>Transition</c> class will actually have a documentation page. <para></para> Even though it has the <see cref="SerializableAttribute"/>, this class won't actually get serialized by Unity because it's generic and abstract. Each child class still needs to include the attribute. <para></para> Documentation: <see href="https://kybernetik.com.au/animancer/docs/manual/transitions">Transitions</see> </remarks> https://kybernetik.com.au/animancer/api/Animancer/Transition_1 <summary>[<see cref="SerializeField"/>] The amount of time the transition will take (in seconds).</summary> <exception cref="ArgumentOutOfRangeException">Thrown when setting the value to a negative number.</exception> <summary>[<see cref="ITransitionDetailed"/>] Indicates what the value of <see cref="AnimancerState.IsLooping"/> will be for the created state. Returns false unless overridden. </summary> <summary>[<see cref="ITransitionDetailed"/>] Determines what <see cref="NormalizedTime"/> to start the animation at. Returns <see cref="float.NaN"/> unless overridden. </summary> <summary>[<see cref="ITransitionDetailed"/>] Determines how fast the animation plays (1x = normal speed). Returns 1 unless overridden. </summary> <summary>[<see cref="ITransitionDetailed"/>] The maximum amount of time the animation is expected to take (in seconds). </summary> <remarks>The actual duration can vary in states like <see cref="MixerState"/>.</remarks> <summary>[<see cref="ITransitionDetailed"/>] The <see cref="Motion.averageAngularSpeed"/> that the created state will have. </summary> <remarks>The actual average velocity can vary in states like <see cref="MixerState"/>.</remarks> <summary>[<see cref="ITransitionDetailed"/>] The <see cref="Motion.averageSpeed"/> that the created state will have. </summary> <remarks>The actual average velocity can vary in states like <see cref="MixerState"/>.</remarks> <summary>[<see cref="SerializeField"/>] [<see cref="ITransitionDetailed"/>] Events which will be triggered as the animation plays. </summary> <remarks>This property returns the <see cref="AnimancerEvent.Sequence.Serializable.Sequence"/>.</remarks> <summary>[<see cref="SerializeField"/>] [<see cref="ITransitionDetailed"/>] Events which will be triggered as the animation plays. </summary> <summary> The state that was created by this object. Specifically, this is the state that was most recently passed into <see cref="Apply"/> (usually by <see cref="AnimancerPlayable.Play(ITransition)"/>). <para></para> You can use <see cref="AnimancerPlayable.StateDictionary.GetOrCreate(ITransition)"/> or <see cref="AnimancerLayer.GetOrCreateState(ITransition)"/> to get or create the state for a specific object. <para></para> <see cref="State"/> is simply a shorthand for casting this to <typeparamref name="TState"/>. </summary> <summary> The state that was created by this object. Specifically, this is the state that was most recently passed into <see cref="Apply"/> (usually by <see cref="AnimancerPlayable.Play(ITransition)"/>). </summary> <remarks> You can use <see cref="AnimancerPlayable.StateDictionary.GetOrCreate(ITransition)"/> or <see cref="AnimancerLayer.GetOrCreateState(ITransition)"/> to get or create the state for a specific object. <para></para> This property is shorthand for casting the <see cref="BaseState"/> to <typeparamref name="TState"/>. </remarks> <exception cref="InvalidCastException"> The <see cref="BaseState"/> is not actually a <typeparamref name="TState"/>. This should only happen if a different type of state was created by something else and registered using the <see cref="Key"/>, causing this <see cref="AnimancerPlayable.Play(ITransition)"/> to pass that state into <see cref="Apply"/> instead of calling <see cref="CreateState"/> to make the correct type of state. </exception> <summary>Indicates whether this transition can create a valid <see cref="AnimancerState"/>.</summary> <summary>The <see cref="AnimancerState.Key"/> which the created state will be registered with.</summary> <remarks>Returns <c>this</c> unless overridden.</remarks> <summary> When a transition is passed into <see cref="AnimancerPlayable.Play(ITransition)"/>, this property determines which <see cref="Animancer.FadeMode"/> will be used. </summary> <summary>Creates and returns a new <typeparamref name="TState"/>.</summary> <remarks> Note that using methods like <see cref="AnimancerPlayable.Play(ITransition)"/> will also call <see cref="Apply"/>, so if you call this method manually you may want to call that method as well. Or you can just use <see cref="AnimancerUtilities.CreateStateAndApply"/>. </remarks> <summary>Creates and returns a new <typeparamref name="TState"/>.</summary> <remarks> Note that using methods like <see cref="AnimancerPlayable.Play(ITransition)"/> will also call <see cref="Apply"/>, so if you call this method manually you may want to call that method as well. Or you can just use <see cref="AnimancerUtilities.CreateStateAndApply"/>. </remarks> <summary>[<see cref="ITransition"/>] Sets the <see cref="BaseState"/> and applies any other modifications to the `state`. </summary> <remarks> Called by <see cref="AnimancerPlayable.Play(ITransition)"/>. <para></para> This method also clears the <see cref="State"/> if necessary, so it will re-cast the <see cref="BaseState"/> when it gets accessed again. </remarks> <summary>The <see cref="AnimancerState.MainObject"/> that the created state will have.</summary> <summary>The display name of this transition.</summary> <summary>Returns the <see cref="Name"/> and type of this transition.</summary> <summary>[Editor-Only] Don't use Inspector Gadgets Nested Object Drawers.</summary>
- <summary>Connects this state to the `parent` mixer at the specified `index`.</summary> <remarks> Use <see cref="AnimancerLayer.AddChild(AnimancerState)"/> instead of this method to connect a state to an available port on a layer. </remarks>
- <summary> The state that was created by this object. Specifically, this is the state that was most recently passed into <see cref="Apply"/> (usually by <see cref="AnimancerPlayable.Play(ITransition)"/>). <para></para> You can use <see cref="AnimancerPlayable.StateDictionary.GetOrCreate(ITransition)"/> or <see cref="AnimancerLayer.GetOrCreateState(ITransition)"/> to get or create the state for a specific object. <para></para> <see cref="State"/> is simply a shorthand for casting this to <typeparamref name="TState"/>. </summary>
- <summary>[<see cref="SerializeField"/>] The amount of time the transition will take (in seconds).</summary> <exception cref="ArgumentOutOfRangeException">Thrown when setting the value to a negative number.</exception> <summary>[<see cref="ITransitionDetailed"/>] Indicates what the value of <see cref="AnimancerState.IsLooping"/> will be for the created state. Returns false unless overridden. </summary> <summary>[<see cref="ITransitionDetailed"/>] Determines what <see cref="NormalizedTime"/> to start the animation at. Returns <see cref="float.NaN"/> unless overridden. </summary> <summary>[<see cref="ITransitionDetailed"/>] Determines how fast the animation plays (1x = normal speed). Returns 1 unless overridden. </summary> <summary>[<see cref="ITransitionDetailed"/>] The maximum amount of time the animation is expected to take (in seconds). </summary> <remarks>The actual duration can vary in states like <see cref="MixerState"/>.</remarks> <summary>[<see cref="ITransitionDetailed"/>] The <see cref="Motion.averageAngularSpeed"/> that the created state will have. </summary> <remarks>The actual average velocity can vary in states like <see cref="MixerState"/>.</remarks> <summary>[<see cref="ITransitionDetailed"/>] The <see cref="Motion.averageSpeed"/> that the created state will have. </summary> <remarks>The actual average velocity can vary in states like <see cref="MixerState"/>.</remarks> <summary>[<see cref="SerializeField"/>] [<see cref="ITransitionDetailed"/>] Events which will be triggered as the animation plays. </summary> <remarks>This property returns the <see cref="AnimancerEvent.Sequence.Serializable.Sequence"/>.</remarks> <summary>[<see cref="SerializeField"/>] [<see cref="ITransitionDetailed"/>] Events which will be triggered as the animation plays. </summary> <summary> The state that was created by this object. Specifically, this is the state that was most recently passed into <see cref="Apply"/> (usually by <see cref="AnimancerPlayable.Play(ITransition)"/>). <para></para> You can use <see cref="AnimancerPlayable.StateDictionary.GetOrCreate(ITransition)"/> or <see cref="AnimancerLayer.GetOrCreateState(ITransition)"/> to get or create the state for a specific object. <para></para> <see cref="State"/> is simply a shorthand for casting this to <typeparamref name="TState"/>. </summary> <summary> The state that was created by this object. Specifically, this is the state that was most recently passed into <see cref="Apply"/> (usually by <see cref="AnimancerPlayable.Play(ITransition)"/>). </summary> <remarks> You can use <see cref="AnimancerPlayable.StateDictionary.GetOrCreate(ITransition)"/> or <see cref="AnimancerLayer.GetOrCreateState(ITransition)"/> to get or create the state for a specific object. <para></para> This property is shorthand for casting the <see cref="BaseState"/> to <typeparamref name="TState"/>. </remarks> <exception cref="InvalidCastException"> The <see cref="BaseState"/> is not actually a <typeparamref name="TState"/>. This should only happen if a different type of state was created by something else and registered using the <see cref="Key"/>, causing this <see cref="AnimancerPlayable.Play(ITransition)"/> to pass that state into <see cref="Apply"/> instead of calling <see cref="CreateState"/> to make the correct type of state. </exception> <summary>Indicates whether this transition can create a valid <see cref="AnimancerState"/>.</summary> <summary>The <see cref="AnimancerState.Key"/> which the created state will be registered with.</summary> <remarks>Returns <c>this</c> unless overridden.</remarks> <summary> When a transition is passed into <see cref="AnimancerPlayable.Play(ITransition)"/>, this property determines which <see cref="Animancer.FadeMode"/> will be used. </summary> <summary>Creates and returns a new <typeparamref name="TState"/>.</summary> <remarks> Note that using methods like <see cref="AnimancerPlayable.Play(ITransition)"/> will also call <see cref="Apply"/>, so if you call this method manually you may want to call that method as well. Or you can just use <see cref="AnimancerUtilities.CreateStateAndApply"/>. </remarks> <summary>Creates and returns a new <typeparamref name="TState"/>.</summary> <remarks> Note that using methods like <see cref="AnimancerPlayable.Play(ITransition)"/> will also call <see cref="Apply"/>, so if you call this method manually you may want to call that method as well. Or you can just use <see cref="AnimancerUtilities.CreateStateAndApply"/>. </remarks> <summary>[<see cref="ITransition"/>] Sets the <see cref="BaseState"/> and applies any other modifications to the `state`. </summary> <remarks> Called by <see cref="AnimancerPlayable.Play(ITransition)"/>. <para></para> This method also clears the <see cref="State"/> if necessary, so it will re-cast the <see cref="BaseState"/> when it gets accessed again. </remarks> <summary>The <see cref="AnimancerState.MainObject"/> that the created state will have.</summary> <summary>The display name of this transition.</summary> <summary>Returns the <see cref="Name"/> and type of this transition.</summary> <summary>[Editor-Only] Don't use Inspector Gadgets Nested Object Drawers.</summary>
- <summary>[<see cref="SerializeField"/>] [<see cref="ITransitionDetailed"/>] Events which will be triggered as the animation plays. </summary> <remarks>This property returns the <see cref="AnimancerEvent.Sequence.Serializable.Sequence"/>.</remarks> <summary>[<see cref="SerializeField"/>] [<see cref="ITransitionDetailed"/>] Events which will be triggered as the animation plays. </summary> <summary> The state that was created by this object. Specifically, this is the state that was most recently passed into <see cref="Apply"/> (usually by <see cref="AnimancerPlayable.Play(ITransition)"/>). <para></para> You can use <see cref="AnimancerPlayable.StateDictionary.GetOrCreate(ITransition)"/> or <see cref="AnimancerLayer.GetOrCreateState(ITransition)"/> to get or create the state for a specific object. <para></para> <see cref="State"/> is simply a shorthand for casting this to <typeparamref name="TState"/>. </summary>
- <summary>[<see cref="SerializeField"/>] The amount of time the transition will take (in seconds).</summary> <exception cref="ArgumentOutOfRangeException">Thrown when setting the value to a negative number.</exception>
- <summary>Has <see cref="_IsPlaying"/> changed since it was last applied to the <see cref="Playable"/>.</summary> <remarks> Playables start playing by default so we start dirty to pause it during the first update (unless <see cref="IsPlaying"/> is set to true before that). </remarks> <summary>Is the <see cref="Time"/> automatically advancing?</summary> <example><code> void IsPlayingExample(AnimancerComponent animancer, AnimationClip clip) { var state = animancer.States.GetOrCreate(clip); if (state.IsPlaying) Debug.Log(clip + " is playing"); else Debug.Log(clip + " is paused"); state.IsPlaying = false;// Pause the animation. state.IsPlaying = true;// Unpause the animation. }
- <summary>Is the <see cref="Time"/> automatically advancing?</summary> <example><code> void IsPlayingExample(AnimancerComponent animancer, AnimationClip clip) { var state = animancer.States.GetOrCreate(clip); if (state.IsPlaying) Debug.Log(clip + " is playing"); else Debug.Log(clip + " is paused"); state.IsPlaying = false;// Pause the animation. state.IsPlaying = true;// Unpause the animation. }
- <summary> The object used to identify this state in the root <see cref="AnimancerPlayable.States"/> dictionary. Can be null. </summary>
- <summary> The <see cref="AnimancerPlayable.FrameID"/> from when the <see cref="Time"/> was last retrieved from the <see cref="Playable"/>. </summary> <summary>The number of seconds that have passed since the start of this animation.</summary> <remarks> This value will continue increasing after the animation passes the end of its <see cref="Length"/> while the animated object either freezes in place or starts again from the beginning according to whether it is looping or not. <para></para> This property internally uses <see cref="RawTime"/> whenever the value is out of date or gets changed. <para></para> <em>Animancer Lite does not allow this value to be changed in runtime builds (except resetting it to 0).</em> </remarks> <example><code> void PlayAnimation(AnimancerComponent animancer, AnimationClip clip) { var state = animancer.Play(clip); // Skip 0.5 seconds into the animation: state.Time = 0.5f; // Skip 50% of the way through the animation (0.5 in a range of 0 to 1): state.NormalizedTime = 0.5f; // Skip to the end of the animation and play backwards. state.NormalizedTime = 1; state.Speed = -1; }
- <summary>Connects this state to the `parent` mixer at the specified `index`.</summary> <remarks> Use <see cref="AnimancerLayer.AddChild(AnimancerState)"/> instead of this method to connect a state to an available port on a layer. </remarks>
- <summary> The state that was created by this object. Specifically, this is the state that was most recently passed into <see cref="Apply"/> (usually by <see cref="AnimancerPlayable.Play(ITransition)"/>). </summary> <remarks> You can use <see cref="AnimancerPlayable.StateDictionary.GetOrCreate(ITransition)"/> or <see cref="AnimancerLayer.GetOrCreateState(ITransition)"/> to get or create the state for a specific object. <para></para> This property is shorthand for casting the <see cref="BaseState"/> to <typeparamref name="TState"/>. </remarks> <exception cref="InvalidCastException"> The <see cref="BaseState"/> is not actually a <typeparamref name="TState"/>. This should only happen if a different type of state was created by something else and registered using the <see cref="Key"/>, causing this <see cref="AnimancerPlayable.Play(ITransition)"/> to pass that state into <see cref="Apply"/> instead of calling <see cref="CreateState"/> to make the correct type of state. </exception>
- <summary> Indicates whether the <see cref="_Time"/> needs to be assigned to the <see cref="Playable"/> next update. </summary> <remarks> <see cref="EventDispatcher"/> executes after all other playables, at which point changes can still be made to their time but not their weight which means that if we set the time immediately then it can be out of sync with the weight. For example, if an animation ends and you play another, the first animation would be stopped and rewinded to the start but would still be at full weight so it would show its first frame before the new animation actually takes effect (even if the previous animation was not looping). <para></para> So instead, we simply delay setting the actual playable time until the next update so that time and weight are always in sync. </remarks> <summary> The <see cref="AnimancerPlayable.FrameID"/> from when the <see cref="Time"/> was last retrieved from the <see cref="Playable"/>. </summary> <summary>The number of seconds that have passed since the start of this animation.</summary> <remarks> This value will continue increasing after the animation passes the end of its <see cref="Length"/> while the animated object either freezes in place or starts again from the beginning according to whether it is looping or not. <para></para> This property internally uses <see cref="RawTime"/> whenever the value is out of date or gets changed. <para></para> <em>Animancer Lite does not allow this value to be changed in runtime builds (except resetting it to 0).</em> </remarks> <example><code> void PlayAnimation(AnimancerComponent animancer, AnimationClip clip) { var state = animancer.Play(clip); // Skip 0.5 seconds into the animation: state.Time = 0.5f; // Skip 50% of the way through the animation (0.5 in a range of 0 to 1): state.NormalizedTime = 0.5f; // Skip to the end of the animation and play backwards. state.NormalizedTime = 1; state.Speed = -1; }
- <summary>The number of seconds that have passed since the start of this animation.</summary> <remarks> This value will continue increasing after the animation passes the end of its <see cref="Length"/> while the animated object either freezes in place or starts again from the beginning according to whether it is looping or not. <para></para> This property internally uses <see cref="RawTime"/> whenever the value is out of date or gets changed. <para></para> <em>Animancer Lite does not allow this value to be changed in runtime builds (except resetting it to 0).</em> </remarks> <example><code> void PlayAnimation(AnimancerComponent animancer, AnimationClip clip) { var state = animancer.Play(clip); // Skip 0.5 seconds into the animation: state.Time = 0.5f; // Skip 50% of the way through the animation (0.5 in a range of 0 to 1): state.NormalizedTime = 0.5f; // Skip to the end of the animation and play backwards. state.NormalizedTime = 1; state.Speed = -1; }
2024-12-17 11:08:04,598 - INFO Retriever 0 - 

————————————————————————————————————————————————————————————————
2024-12-17 11:08:04,599 - INFO Retriever 0 - 当前窗口总长度：23
2024-12-17 11:08:04,599 - INFO Retriever 0 - 当前更新窗口长度：14
2024-12-17 11:08:04,600 - INFO Retriever 0 - 当前更新窗口长度：14
2024-12-17 11:08:04,600 - INFO Retriever 0 - ————————————————————————————————————————————————————————————————


2024-12-17 11:08:27,924 - INFO Retriever 0 - Agent主脑给出的回答为：{
  "根据文件内容概述": "AnimancerState.cs 脚本定义了一个名为 `AnimancerState` 的抽象类，用于管理动画播放状态的基类。该类继承自 `AnimancerNode` 并实现了 `IAnimationClipCollection` 接口。虽然该脚本没有直接涉及动画控制，但了解动画状态管理机制对于分析如何修改动画状态以实现固定战斗动画是有帮助的。接下来，我将读取其他可能与问题描述相关的文件，以便进一步分析。"
}
2024-12-17 11:08:27,925 - INFO Retriever 0 - 是否成功解析：True
2024-12-17 11:08:27,925 - INFO Retriever 0 - operation_type (__det_dir_action):
2024-12-17 11:08:27,926 - INFO Retriever 0 - 根据文件内容概述
2024-12-17 11:08:27,926 - INFO Retriever 0 - 

——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
2024-12-17 11:08:27,926 - INFO Retriever 0 - Assistant:
2024-12-17 11:08:27,926 - INFO Retriever 0 - {
  "根据文件内容概述": "AnimancerState.cs 脚本定义了一个名为 `AnimancerState` 的抽象类，用于管理动画播放状态的基类。该类继承自 `AnimancerNode` 并实现了 `IAnimationClipCollection` 接口。虽然该脚本没有直接涉及动画控制，但了解动画状态管理机制对于分析如何修改动画状态以实现固定战斗动画是有帮助的。接下来，我将读取其他可能与问题描述相关的文件，以便进一步分析。"
}
2024-12-17 11:08:27,926 - INFO Retriever 0 - dict_keys(['根据文件内容概述'])
2024-12-17 11:08:27,926 - WARNING Retriever 0 - 你给出的操作类型不属于指定的操作类型。可以进行的操作类型有：['get_folder_info', 'read_file', 'read_long_details', 'retrieve_keywords', 'deep_think']，请重新给出你的操作。
2024-12-17 11:08:27,930 - INFO Retriever 0 - 

————————————————————————————————————————————————————————————————
2024-12-17 11:08:27,930 - INFO Retriever 0 - 当前窗口总长度：25
2024-12-17 11:08:27,930 - INFO Retriever 0 - 当前更新窗口长度：16
2024-12-17 11:08:27,930 - INFO Retriever 0 - 当前更新窗口长度：16
2024-12-17 11:08:27,931 - INFO Retriever 0 - ————————————————————————————————————————————————————————————————


2024-12-17 11:08:40,325 - INFO Retriever 0 - Agent主脑给出的回答为：{
    "read_file": {
        "file_path": "D:\\Unity\\jyx2\\Assets\\Mods\\JYX2\\Skills\\降龙十八掌.asset"
    }
}
2024-12-17 11:08:40,326 - INFO Retriever 0 - 是否成功解析：True
2024-12-17 11:08:40,326 - INFO Retriever 0 - operation_type (__det_dir_action):
2024-12-17 11:08:40,326 - INFO Retriever 0 - read_file
2024-12-17 11:08:40,326 - INFO Retriever 0 - 

——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
2024-12-17 11:08:40,327 - INFO Retriever 0 - Assistant:
2024-12-17 11:08:40,327 - INFO Retriever 0 - {
    "read_file": {
        "file_path": "D:\\Unity\\jyx2\\Assets\\Mods\\JYX2\\Skills\\降龙十八掌.asset"
    }
}
2024-12-17 11:08:40,327 - INFO Retriever 0 - dict_keys(['read_file'])
2024-12-17 11:08:40,327 - INFO Retriever 0 - Agent主脑给出的行动：read_file
参数：{'file_path': 'D:\\Unity\\jyx2\\Assets\\Mods\\JYX2\\Skills\\降龙十八掌.asset', 'top_path': 'D:/Unity/jyx2\\Assets', 'return_file_sum': <bound method TreeGenerationAction.return_file_sum of <Action.tree_gen_action.TreeGenerationAction object at 0x0000027D71AB0D90>>}
2024-12-17 11:08:40,333 - INFO Retriever 0 - Observer: 这是一个名为“降龙十八掌.asset”的文件，该文件里的内容为：
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject:
    fileID: 0
  m_PrefabInstance:
    fileID: 0
  m_PrefabAsset:
    fileID: 0
  m_GameObject:
    fileID: 0
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script:
    fileID: 11500000
    guid: 7198f6f3a0b460847b34dadf568f5246
    type: 3
  m_Name: 降龙十八掌
  m_EditorClassIdentifier: None
  weaponCode: 0
  behitClip:
    fileID: 0
  moveClip:
    fileID: 0
  idleClip:
    fileID: 7400000
    guid: 3f927b05cf26fd042b6cd1804c23224b
    type: 2
  attackClip:
    fileID: 7400000
    guid: f7484b2d5cb230a46bc296bf00fc0aec
    type: 2
  stunClip:
    fileID: 0
  animationDelay: 0
  duration: 2.62
  behitDelay: 1.65
  partilePrefab:
    fileID: 5631314690823005590
    guid: 93e3ede1e0fe9204e98e2f967aded69f
    type: 3
  particleDelay: 1.65
  partileOffset:
    x: 0
    y: 0
    z: 0
  particleScale: 1
  blockPartilePrefab:
    fileID: 100000
    guid: f718b88e98f1e1743960b704cb1bbf6b
    type: 3
  blockParticleDelay: 1.54
  blockPartileOffset:
    x: 0
    y: 1
    z: 0
  blockParticleScale: 10
  blockPartilePrefabAdd:
    fileID: 0
  blockParticleDelayAdd: 0.5
  bloackParticleAddDuration: 2
  blockPartileOffsetAdd:
    x: 0
    y: 1
    z: 0
  blockParticleScaleAdd: 1
  audio:
    fileID: 8300000
    guid: a16647f006791444baae1633c048c1a4
    type: 3
  audioDelay: 1.4
  audio2:
    fileID: 8300000
    guid: 8df08fcc08d12914986cbc0904c77f94
    type: 3
  audioDelay2: 0
  controller:
    fileID: 0
  isGhostShadowOn: 1
  ghostShadowColor:
    r: 0.9245283
    g: 0.5545685
    b: 0.047970813
    a: 1
2024-12-17 11:08:40,336 - INFO Retriever 0 - 

————————————————————————————————————————————————————————————————
2024-12-17 11:08:40,336 - INFO Retriever 0 - 当前窗口总长度：27
2024-12-17 11:08:40,337 - INFO Retriever 0 - 当前更新窗口长度：18
2024-12-17 11:08:40,337 - INFO Retriever 0 - 当前更新窗口长度：18
2024-12-17 11:08:40,337 - INFO Retriever 0 - ————————————————————————————————————————————————————————————————


2024-12-17 11:08:47,406 - INFO Retriever 0 - Agent主脑给出的回答为：{
  "根据文件内容概述": "降龙十八掌.asset 文件详细配置了“降龙十八掌”技能的动画、特效和音效。了解该技能的配置有助于分析如何修改其他技能的配置以实现固定战斗动画。接下来，我将读取其他可能与问题描述相关的文件，以便进一步分析。"
}
2024-12-17 11:08:47,406 - INFO Retriever 0 - 是否成功解析：True
2024-12-17 11:08:47,407 - INFO Retriever 0 - operation_type (__det_dir_action):
2024-12-17 11:08:47,407 - INFO Retriever 0 - 根据文件内容概述
2024-12-17 11:08:47,407 - INFO Retriever 0 - 

——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
2024-12-17 11:08:47,408 - INFO Retriever 0 - Assistant:
2024-12-17 11:08:47,408 - INFO Retriever 0 - {
  "根据文件内容概述": "降龙十八掌.asset 文件详细配置了“降龙十八掌”技能的动画、特效和音效。了解该技能的配置有助于分析如何修改其他技能的配置以实现固定战斗动画。接下来，我将读取其他可能与问题描述相关的文件，以便进一步分析。"
}
2024-12-17 11:08:47,408 - INFO Retriever 0 - dict_keys(['根据文件内容概述'])
2024-12-17 11:08:47,409 - WARNING Retriever 0 - 你给出的操作类型不属于指定的操作类型。可以进行的操作类型有：['get_folder_info', 'read_file', 'read_long_details', 'retrieve_keywords', 'deep_think']，请重新给出你的操作。
2024-12-17 11:08:47,413 - INFO Retriever 0 - 

————————————————————————————————————————————————————————————————
2024-12-17 11:08:47,414 - INFO Retriever 0 - 当前窗口总长度：29
2024-12-17 11:08:47,414 - INFO Retriever 0 - 当前更新窗口长度：20
2024-12-17 11:08:47,414 - INFO Retriever 0 - 当前更新窗口长度：20
2024-12-17 11:08:47,415 - INFO Retriever 0 - ————————————————————————————————————————————————————————————————


2024-12-17 11:08:53,469 - INFO Retriever 0 - Agent主脑给出的回答为：{
    "read_file": {
        "file_path": "D:\\Unity\\jyx2\\Assets\\LuaScripts\\Jyx2Battle\\BattleInit.lua"
    }
}
2024-12-17 11:08:53,469 - INFO Retriever 0 - 是否成功解析：True
2024-12-17 11:08:53,469 - INFO Retriever 0 - operation_type (__det_dir_action):
2024-12-17 11:08:53,470 - INFO Retriever 0 - read_file
2024-12-17 11:08:53,470 - INFO Retriever 0 - 

——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
2024-12-17 11:08:53,470 - INFO Retriever 0 - Assistant:
2024-12-17 11:08:53,470 - INFO Retriever 0 - {
    "read_file": {
        "file_path": "D:\\Unity\\jyx2\\Assets\\LuaScripts\\Jyx2Battle\\BattleInit.lua"
    }
}
2024-12-17 11:08:53,470 - INFO Retriever 0 - dict_keys(['read_file'])
2024-12-17 11:08:53,471 - INFO Retriever 0 - Agent主脑给出的行动：read_file
参数：{'file_path': 'D:\\Unity\\jyx2\\Assets\\LuaScripts\\Jyx2Battle\\BattleInit.lua', 'top_path': 'D:/Unity/jyx2\\Assets', 'return_file_sum': <bound method TreeGenerationAction.return_file_sum of <Action.tree_gen_action.TreeGenerationAction object at 0x0000027D71AB0D90>>}
2024-12-17 11:08:53,510 - INFO Retriever 0 - Observer: 这是一个名为“BattleInit.lua”的文件，该文件里的内容为：
由于脚本文件内容过长，暂时仅给出该脚本文件的内容总结:
- ### 总体概述
该脚本名为“BattleInit.lua”，是一个Lua脚本，主要用于初始化金庸群侠传3D重制版游戏中的战斗模块。脚本通过模块化和函数调用的方式，组织了战斗相关的配置和功能。

### 模块和功能
- **战斗配置**：定义了技能覆盖类型，如点、线、交叉等。
- **依赖模块加载**：加载了多个战斗相关的模块，包括伤害计算器、范围逻辑、AI管理和战斗管理器。

### 类和函数
- **`battle.SkillCoverType`**：一个表（table），用于定义技能覆盖的类型常量。
- **`battle.DamageCaculator`**：通过`jy_utils.prequire`加载的伤害计算器模块。
- **`battle.RangeLogic`**：通过`jy_utils.prequire`加载的范围逻辑模块。
- **`battle.AIManager`**：通过`jy_utils.prequire`加载的AI管理模块。
- **`battle.Manager`**：通过`jy_utils.prequire`加载的战斗管理器模块。

### 实现逻辑
1. 定义了一个名为`battle`的表，用于存储战斗模块的相关配置和功能。
2. 在`battle`表中定义了一个名为`SkillCoverType`的表，用于存储技能覆盖类型的常量。
3. 使用`jy_utils.prequire`函数加载了四个战斗相关的模块，并将它们作为属性添加到`battle`表中。
4. 最后，返回`battle`表，以便在游戏中其他Lua脚本中可以使用这些模块和配置。
在这个脚本中存在如下的一些函数：
没有提供详细的函数信息。
2024-12-17 11:08:53,516 - INFO Retriever 0 - 

————————————————————————————————————————————————————————————————
2024-12-17 11:08:53,516 - INFO Retriever 0 - 当前窗口总长度：31
2024-12-17 11:08:53,517 - INFO Retriever 0 - 当前更新窗口长度：22
2024-12-17 11:08:53,517 - INFO Retriever 0 - 当前更新窗口长度：22
2024-12-17 11:08:53,518 - INFO Retriever 0 - ————————————————————————————————————————————————————————————————


2024-12-17 11:09:09,279 - INFO Retriever 0 - Agent主脑给出的回答为：{
  "根据文件内容概述": "BattleInit.lua 脚本负责战斗模块的初始化，加载了伤害计算器、范围逻辑、AI管理和战斗管理器等模块。了解战斗模块的初始化过程有助于分析如何修改相关模块以实现固定战斗动画。接下来，我将读取其他可能与问题描述相关的文件，以便进一步分析。"
}
2024-12-17 11:09:09,280 - INFO Retriever 0 - 是否成功解析：True
2024-12-17 11:09:09,280 - INFO Retriever 0 - operation_type (__det_dir_action):
2024-12-17 11:09:09,280 - INFO Retriever 0 - 根据文件内容概述
2024-12-17 11:09:09,280 - INFO Retriever 0 - 

——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
2024-12-17 11:09:09,281 - INFO Retriever 0 - Assistant:
2024-12-17 11:09:09,281 - INFO Retriever 0 - {
  "根据文件内容概述": "BattleInit.lua 脚本负责战斗模块的初始化，加载了伤害计算器、范围逻辑、AI管理和战斗管理器等模块。了解战斗模块的初始化过程有助于分析如何修改相关模块以实现固定战斗动画。接下来，我将读取其他可能与问题描述相关的文件，以便进一步分析。"
}
2024-12-17 11:09:09,281 - INFO Retriever 0 - dict_keys(['根据文件内容概述'])
2024-12-17 11:09:09,281 - WARNING Retriever 0 - 你给出的操作类型不属于指定的操作类型。可以进行的操作类型有：['get_folder_info', 'read_file', 'read_long_details', 'retrieve_keywords', 'deep_think']，请重新给出你的操作。
2024-12-17 11:09:09,284 - INFO Retriever 0 - 

————————————————————————————————————————————————————————————————
2024-12-17 11:09:09,284 - INFO Retriever 0 - 当前窗口总长度：33
2024-12-17 11:09:09,284 - INFO Retriever 0 - 当前更新窗口长度：24
2024-12-17 11:09:09,284 - INFO Retriever 0 - 当前更新窗口长度：24
2024-12-17 11:09:09,285 - INFO Retriever 0 - ————————————————————————————————————————————————————————————————


2024-12-17 11:09:18,085 - INFO Retriever 0 - Agent主脑给出的回答为：{
    "deep_think": {
        "thoughts": "我已经读取了几个与问题描述相关的文件，并对其内容进行了分析。根据这些文件的内容，我了解到角色实例的管理、AI逻辑、动画状态管理和技能配置等方面。然而，我还没有找到直接指定角色战斗动画为固定的脚本。我需要进一步分析这些文件，特别是与动画状态管理和技能配置相关的部分，以确定是否有任何函数或方法可以用来修改角色的战斗动画。接下来，我将继续读取其他可能与问题描述相关的文件，以便进一步分析。"
    }
}
2024-12-17 11:09:18,086 - INFO Retriever 0 - 是否成功解析：True
2024-12-17 11:09:18,086 - INFO Retriever 0 - operation_type (__det_dir_action):
2024-12-17 11:09:18,086 - INFO Retriever 0 - deep_think
2024-12-17 11:09:18,086 - INFO Retriever 0 - 

——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
2024-12-17 11:09:18,086 - INFO Retriever 0 - Assistant:
2024-12-17 11:09:18,086 - INFO Retriever 0 - {
    "deep_think": {
        "thoughts": "我已经读取了几个与问题描述相关的文件，并对其内容进行了分析。根据这些文件的内容，我了解到角色实例的管理、AI逻辑、动画状态管理和技能配置等方面。然而，我还没有找到直接指定角色战斗动画为固定的脚本。我需要进一步分析这些文件，特别是与动画状态管理和技能配置相关的部分，以确定是否有任何函数或方法可以用来修改角色的战斗动画。接下来，我将继续读取其他可能与问题描述相关的文件，以便进一步分析。"
    }
}
2024-12-17 11:09:18,088 - INFO Retriever 0 - dict_keys(['deep_think'])
2024-12-17 11:09:18,088 - INFO Retriever 0 - Agent主脑给出的行动：deep_think
参数：{'thoughts': '我已经读取了几个与问题描述相关的文件，并对其内容进行了分析。根据这些文件的内容，我了解到角色实例的管理、AI逻辑、动画状态管理和技能配置等方面。然而，我还没有找到直接指定角色战斗动画为固定的脚本。我需要进一步分析这些文件，特别是与动画状态管理和技能配置相关的部分，以确定是否有任何函数或方法可以用来修改角色的战斗动画。接下来，我将继续读取其他可能与问题描述相关的文件，以便进一步分析。', 'repeat_counter': 1, 'continue_think_counter': 1}
2024-12-17 11:09:18,088 - INFO Retriever 0 - Observer: 好的，请继续你的下一步行动或思考。
2024-12-17 11:09:18,090 - INFO Retriever 0 - 

————————————————————————————————————————————————————————————————
2024-12-17 11:09:18,090 - INFO Retriever 0 - 当前窗口总长度：35
2024-12-17 11:09:18,091 - INFO Retriever 0 - 当前更新窗口长度：26
2024-12-17 11:09:18,091 - INFO Retriever 0 - 当前更新窗口长度：26
2024-12-17 11:09:18,091 - INFO Retriever 0 - ————————————————————————————————————————————————————————————————


2024-12-17 11:09:24,192 - INFO Retriever 0 - Agent主脑给出的回答为：{
    "read_file": {
        "file_path": "D:\\Unity\\jyx2\\Assets\\Scripts\\GameSave\\RoleInstance.cs"
    }
}
2024-12-17 11:09:24,194 - INFO Retriever 0 - 是否成功解析：True
2024-12-17 11:09:24,194 - INFO Retriever 0 - operation_type (__det_dir_action):
2024-12-17 11:09:24,194 - INFO Retriever 0 - read_file
2024-12-17 11:09:24,195 - INFO Retriever 0 - 

——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
2024-12-17 11:09:24,195 - INFO Retriever 0 - Assistant:
2024-12-17 11:09:24,195 - INFO Retriever 0 - {
    "read_file": {
        "file_path": "D:\\Unity\\jyx2\\Assets\\Scripts\\GameSave\\RoleInstance.cs"
    }
}
2024-12-17 11:09:24,195 - INFO Retriever 0 - dict_keys(['read_file'])
2024-12-17 11:09:24,195 - INFO Retriever 0 - Agent主脑给出的行动：read_file
参数：{'file_path': 'D:\\Unity\\jyx2\\Assets\\Scripts\\GameSave\\RoleInstance.cs', 'top_path': 'D:/Unity/jyx2\\Assets', 'return_file_sum': <bound method TreeGenerationAction.return_file_sum of <Action.tree_gen_action.TreeGenerationAction object at 0x0000027D71AB0D90>>}
2024-12-17 11:09:24,259 - INFO Retriever 0 - Observer: 这是一个名为“RoleInstance.cs”的文件，该文件里的内容为：
由于脚本文件内容过长，暂时仅给出该脚本文件的内容总结:
- ### 总体概述
- **框架和模块化结构**：该脚本定义了一个名为 `RoleInstance` 的类，该类似乎用于管理游戏中的角色实例，包括其属性、技能、装备和状态。代码使用了模块化结构，通过使用不同的方法和属性来管理角色实例的不同方面。
- **主要功能和目标**：该脚本的主要功能是创建和管理游戏中的角色实例，包括角色的初始化、属性管理、技能学习、装备使用、战斗状态和状态更新。

### 模块和功能
- **角色属性管理**：管理角色的基础属性，如ID、姓名、等级、经验、攻击力、防御力等。
- **技能管理**：管理角色的技能列表，包括初始化、学习、升级和重置。
- **装备管理**：管理角色的装备，包括武器、防具和修炼物品。
- **战斗状态**：处理角色的战斗状态，包括进入战斗、退出战斗、集气槽增长、移动能力和行动力。
- **状态相关**：处理角色的状态，如晕眩、复活和休息。

### 类和函数
- **类**：`RoleInstance`
  - **作用**：表示游戏中的角色实例。
  - **关键功能**：属性管理、技能管理、装备管理、战斗状态和状态更新。
- **函数**：
  - `BindKey`：绑定角色ID并初始化数据。
  - `InitData`：初始化角色数据。
  - `ResetForBattle`：为战斗重置角色状态。
  - `Recover`：恢复角色生命值和体力。
  - `LevelUp`：角色升级。
  - `LimitAllAttrs`：限制所有属性的范围。
  - `AddAttr`：增加角色属性。
  - `GetSkillsList`：获取角色技能列表。
  - `ResetItems`：重置角色物品。
  - `AddItem`：为角色添加物品。
  - `CanUseItem`：判断角色是否可以使用道具。
  - `UseItem`：使用道具。
  - `UnequipItem`：卸下装备。
  - `LianZhiItem`：炼制物品。
  - `EnterBattle`：进入战斗。
  - `LeaveBattle`：退出战斗。
  - `TimeRun`：时间运行。
  - `IncSp`：集气槽增长。
  - `GetMoveAbility`：获取移动能力。
  - `IsDead`：判断角色是否死亡。
  - `Resurrect`：复活角色。
  - `Stun`：使角色晕眩。
  - `StopStun`：停止晕眩。
  - `OnRest`：休息逻辑。
  - `LearnMagic`：学习武学。
  - `Clone`：克隆角色实例。

### 实现逻辑
- **初始化**：通过 `BindKey` 方法绑定角色ID，并通过 `InitData` 方法初始化角色数据。
- **属性管理**：通过 `AddAttr` 方法增加角色属性，并通过 `LimitAllAttrs` 方法限制属性范围。
- **技能管理**：通过 `GetSkillsList` 方法获取角色技能列表，并通过 `LearnMagic` 方法学习新技能。
- **装备管理**：通过 `AddItem` 和 `UnequipItem` 方法管理角色装备。
- **战斗状态**：通过 `EnterBattle` 和 `LeaveBattle` 方法管理角色的战斗状态，并通过 `IncSp` 和 `GetMoveAbility` 方法管理移动能力和行动力。
- **状态相关**：通过 `Stun` 和 `StopStun` 方法管理角色的晕眩状态，并通过 `OnRest` 方法处理休息逻辑。
在这个脚本中存在如下的一些函数：AddAttr、AddItem、Anqi、AntiPoison、Armor、Attack、AttackPoison、BattleModel、BindKey、CanFinishedItem、CanLevelUp、CanUseItem、CanUseItem、Clone、CompareTo、CurrentSkill、Data、DePoison、Defence、EnterBattle、Exp、ExpForItem、ExpForMakeItem、ExpGot、GetArmor、GetArmorProperty、GetExtraAttack、GetFinishedExpForItem、GetFinishedExpForItem、GetHPColor1、GetHPColor2、GetJyx2RoleId、GetLevelUpExp、GetMPColor、GetMoveAbility、GetPic、GetSkillsList、GetWeapon、GetWeaponProperty、GetWugongLevel、GetXiulianItem、HaveItemBool、Heal、Hp、HpInc、Hurt、IQ、IncSp、InitData、InitData、IsAI、IsDead、IsPlayerRole、IsStun、Items、Jyx2、Key、LearnMagic、LeaveBattle、Level、LevelUp、LianZhiItem、LimitAllAttrs、LimitAttr、MaxHp、MaxMp、Model、Mp、MpType、Name、OnRest、Pinde、Poison、Pos、PreviousRoundHp、Qimen、Qinggong、Quanzhang、Random、Recover、ResetForBattle、ResetItems、ResetSkillCasts、Resurrect、RoleInstance、RoleInstance、RoleInstance、SetHPAndRefreshHudBar、Sex、Shengwang、Shuadao、Skills、StopStun、Stun、SwitchAnimationToSkill、Tili、TimeRun、UnequipItem、UpdateViewPostion、UseItem、UsePoison、View、Weapon、Wugongs、Wuxuechangshi、Xiulianwupin、Yujian、Zuoyouhubo、_currentSkill、_data、_isInBattle、_isStun、_pos、_thisType、checkUp、getLevelUpExp、isAI、isActed、isWaiting、movedStep、runtime、sp、team、testAttr
这些函数有以下详细信息：
- <summary> 升级属性计算公式可以参考：https://github.com/ZhanruiLiang/jinyong-legend </summary> <returns></returns> <summary> 限制属性范围 Attack、Defence、Qinggong为最终状态：原始属性 + 此刻使用的装备属性的总值 </summary> <summary> 角色专用的属性范围限制 </summary> <summary> 增加角色属性的API </summary> <param name="attrName">属性名</param> <param name="delta">属性增量</param> <returns>属性实际增量</returns> <summary> 战斗中使用的招式 </summary> <summary> 获取该角色所有的招式，（如果有医疗、用毒、解毒，也封装成招式） </summary> <returns></returns> <summary> 为角色添加物品 </summary> <param name="itemId"></param> <param name="count"></param> <summary> 判断角色是否可以使用道具 对应kyscpp：bool GameUtil::canUseItem(Role* r, Item* i) </summary> <param name="item"></param> <returns></returns> <summary> 炼制物品 计算公式可以参考：https://github.com/ZhanruiLiang/jinyong-legend </summary> <param name="item"></param> <summary> 使用物品 </summary> <param name="item"></param> <summary> 卸下物品（装备） </summary> <param name="item"></param> <summary> 获得修炼所需经验 </summary> <param name="item"></param> <returns></returns> <summary> 晕眩 </summary> <param name="duration">等于0时不晕眩；大于0时晕眩{duration}秒；小于0时永久晕眩</param> <summary> 获取武器武功配合加攻击力 计算方法参考：https://github.com/ZhanruiLiang/jinyong-legend 玄铁剑+玄铁剑法 攻击+100 君子剑+玉女素心剑 攻击+50 淑女剑+玉女素心剑 攻击+50 血刀+血刀大法 攻击+50 冷月宝刀+胡家刀法 攻击+70 金蛇剑+金蛇剑法 攻击力+80 霹雳狂刀+霹雳刀法 攻击+100 </summary> <param name="wugong"></param> <returns></returns>
- <summary> 升级属性计算公式可以参考：https://github.com/ZhanruiLiang/jinyong-legend </summary> <returns></returns> <summary> 限制属性范围 Attack、Defence、Qinggong为最终状态：原始属性 + 此刻使用的装备属性的总值 </summary> <summary> 角色专用的属性范围限制 </summary> <summary> 增加角色属性的API </summary> <param name="attrName">属性名</param> <param name="delta">属性增量</param> <returns>属性实际增量</returns> <summary> 战斗中使用的招式 </summary> <summary> 获取该角色所有的招式，（如果有医疗、用毒、解毒，也封装成招式） </summary> <returns></returns> <summary> 为角色添加物品 </summary> <param name="itemId"></param> <param name="count"></param> <summary> 判断角色是否可以使用道具 对应kyscpp：bool GameUtil::canUseItem(Role* r, Item* i) </summary> <param name="item"></param> <returns></returns> <summary> 炼制物品 计算公式可以参考：https://github.com/ZhanruiLiang/jinyong-legend </summary> <param name="item"></param> <summary> 使用物品 </summary> <param name="item"></param> <summary> 卸下物品（装备） </summary> <param name="item"></param> <summary> 获得修炼所需经验 </summary> <param name="item"></param> <returns></returns> <summary> 晕眩 </summary> <param name="duration">等于0时不晕眩；大于0时晕眩{duration}秒；小于0时永久晕眩</param> <summary> 获取武器武功配合加攻击力 计算方法参考：https://github.com/ZhanruiLiang/jinyong-legend 玄铁剑+玄铁剑法 攻击+100 君子剑+玉女素心剑 攻击+50 淑女剑+玉女素心剑 攻击+50 血刀+血刀大法 攻击+50 冷月宝刀+胡家刀法 攻击+70 金蛇剑+金蛇剑法 攻击力+80 霹雳狂刀+霹雳刀法 攻击+100 </summary> <param name="wugong"></param> <returns></returns>
- <summary> 升级属性计算公式可以参考：https://github.com/ZhanruiLiang/jinyong-legend </summary> <returns></returns> <summary> 限制属性范围 Attack、Defence、Qinggong为最终状态：原始属性 + 此刻使用的装备属性的总值 </summary> <summary> 角色专用的属性范围限制 </summary> <summary> 增加角色属性的API </summary> <param name="attrName">属性名</param> <param name="delta">属性增量</param> <returns>属性实际增量</returns> <summary> 战斗中使用的招式 </summary> <summary> 获取该角色所有的招式，（如果有医疗、用毒、解毒，也封装成招式） </summary> <returns></returns> <summary> 为角色添加物品 </summary> <param name="itemId"></param> <param name="count"></param> <summary> 判断角色是否可以使用道具 对应kyscpp：bool GameUtil::canUseItem(Role* r, Item* i) </summary> <param name="item"></param> <returns></returns> <summary> 炼制物品 计算公式可以参考：https://github.com/ZhanruiLiang/jinyong-legend </summary> <param name="item"></param> <summary> 使用物品 </summary> <param name="item"></param> <summary> 卸下物品（装备） </summary> <param name="item"></param> <summary> 获得修炼所需经验 </summary> <param name="item"></param> <returns></returns> <summary> 晕眩 </summary> <param name="duration">等于0时不晕眩；大于0时晕眩{duration}秒；小于0时永久晕眩</param> <summary> 获取武器武功配合加攻击力 计算方法参考：https://github.com/ZhanruiLiang/jinyong-legend 玄铁剑+玄铁剑法 攻击+100 君子剑+玉女素心剑 攻击+50 淑女剑+玉女素心剑 攻击+50 血刀+血刀大法 攻击+50 冷月宝刀+胡家刀法 攻击+70 金蛇剑+金蛇剑法 攻击力+80 霹雳狂刀+霹雳刀法 攻击+100 </summary> <param name="wugong"></param> <returns></returns>
- <summary> 获取该角色所有的招式，（如果有医疗、用毒、解毒，也封装成招式） </summary> <returns></returns>
- <summary> 晕眩 </summary> <param name="duration">等于0时不晕眩；大于0时晕眩{duration}秒；小于0时永久晕眩</param>
- <summary> 增加角色属性的API </summary> <param name="attrName">属性名</param> <param name="delta">属性增量</param> <returns>属性实际增量</returns>
2024-12-17 11:09:24,263 - INFO Retriever 0 - 

————————————————————————————————————————————————————————————————
2024-12-17 11:09:24,264 - INFO Retriever 0 - 当前窗口总长度：37
2024-12-17 11:09:24,264 - INFO Retriever 0 - 当前更新窗口长度：28
2024-12-17 11:09:24,264 - INFO Retriever 0 - 当前更新窗口长度：28
2024-12-17 11:09:24,264 - INFO Retriever 0 - ————————————————————————————————————————————————————————————————


2024-12-17 11:09:34,877 - INFO Retriever 0 - Agent主脑给出的回答为：{
  "根据文件内容概述": "RoleInstance.cs 脚本负责管理游戏中的角色实例，包括其属性、技能、装备和战斗状态。虽然该脚本没有直接涉及动画控制，但了解角色实例的属性和技能管理机制对于分析如何修改角色行动以实现固定战斗动画是有帮助的。接下来，我将读取其他可能与问题描述相关的文件，以便进一步分析。"
}
2024-12-17 11:09:34,877 - INFO Retriever 0 - 是否成功解析：True
2024-12-17 11:09:34,877 - INFO Retriever 0 - operation_type (__det_dir_action):
2024-12-17 11:09:34,878 - INFO Retriever 0 - 根据文件内容概述
2024-12-17 11:09:34,878 - INFO Retriever 0 - 

——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
2024-12-17 11:09:34,878 - INFO Retriever 0 - Assistant:
2024-12-17 11:09:34,878 - INFO Retriever 0 - {
  "根据文件内容概述": "RoleInstance.cs 脚本负责管理游戏中的角色实例，包括其属性、技能、装备和战斗状态。虽然该脚本没有直接涉及动画控制，但了解角色实例的属性和技能管理机制对于分析如何修改角色行动以实现固定战斗动画是有帮助的。接下来，我将读取其他可能与问题描述相关的文件，以便进一步分析。"
}
2024-12-17 11:09:34,879 - INFO Retriever 0 - dict_keys(['根据文件内容概述'])
2024-12-17 11:09:34,879 - WARNING Retriever 0 - 你给出的操作类型不属于指定的操作类型。可以进行的操作类型有：['get_folder_info', 'read_file', 'read_long_details', 'retrieve_keywords', 'deep_think']，请重新给出你的操作。
2024-12-17 11:09:34,881 - INFO Retriever 0 - 

————————————————————————————————————————————————————————————————
2024-12-17 11:09:34,881 - INFO Retriever 0 - 当前窗口总长度：39
2024-12-17 11:09:34,882 - INFO Retriever 0 - 当前更新窗口长度：30
2024-12-17 11:09:34,882 - INFO Retriever 0 - 当前更新窗口长度：30
2024-12-17 11:09:34,882 - INFO Retriever 0 - ————————————————————————————————————————————————————————————————


2024-12-17 11:09:53,182 - INFO Retriever 0 - Agent主脑给出的回答为：{
    "deep_think": {
        "thoughts": "我已经读取了几个与问题描述相关的文件，并对其内容进行了分析。根据这些文件的内容，我了解到角色实例的管理、AI逻辑、动画状态管理和技能配置等方面。然而，我还没有找到直接指定角色战斗动画为固定的脚本。我需要进一步分析这些文件，特别是与动画状态管理和技能配置相关的部分，以确定是否有任何函数或方法可以用来修改角色的战斗动画。接下来，我将继续读取其他可能与问题描述相关的文件，以便进一步分析。"
    }
}
2024-12-17 11:09:53,182 - INFO Retriever 0 - 是否成功解析：True
2024-12-17 11:09:53,183 - INFO Retriever 0 - operation_type (__det_dir_action):
2024-12-17 11:09:53,183 - INFO Retriever 0 - deep_think
2024-12-17 11:09:53,183 - INFO Retriever 0 - 

——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
2024-12-17 11:09:53,183 - INFO Retriever 0 - Assistant:
2024-12-17 11:09:53,183 - INFO Retriever 0 - {
    "deep_think": {
        "thoughts": "我已经读取了几个与问题描述相关的文件，并对其内容进行了分析。根据这些文件的内容，我了解到角色实例的管理、AI逻辑、动画状态管理和技能配置等方面。然而，我还没有找到直接指定角色战斗动画为固定的脚本。我需要进一步分析这些文件，特别是与动画状态管理和技能配置相关的部分，以确定是否有任何函数或方法可以用来修改角色的战斗动画。接下来，我将继续读取其他可能与问题描述相关的文件，以便进一步分析。"
    }
}
2024-12-17 11:09:53,184 - INFO Retriever 0 - dict_keys(['deep_think'])
2024-12-17 11:09:53,184 - INFO Retriever 0 - Agent主脑给出的行动：deep_think
参数：{'thoughts': '我已经读取了几个与问题描述相关的文件，并对其内容进行了分析。根据这些文件的内容，我了解到角色实例的管理、AI逻辑、动画状态管理和技能配置等方面。然而，我还没有找到直接指定角色战斗动画为固定的脚本。我需要进一步分析这些文件，特别是与动画状态管理和技能配置相关的部分，以确定是否有任何函数或方法可以用来修改角色的战斗动画。接下来，我将继续读取其他可能与问题描述相关的文件，以便进一步分析。', 'repeat_counter': 1, 'continue_think_counter': 1}
2024-12-17 11:09:53,184 - INFO Retriever 0 - Observer: 好的，请继续你的下一步行动或思考。
2024-12-17 11:09:53,187 - INFO Retriever 0 - 

————————————————————————————————————————————————————————————————
2024-12-17 11:09:53,187 - INFO Retriever 0 - 当前窗口总长度：41
2024-12-17 11:09:53,187 - INFO Retriever 0 - 当前更新窗口长度：32
2024-12-17 11:09:53,188 - INFO Retriever 0 - 当前更新窗口长度：32
2024-12-17 11:09:53,188 - INFO Retriever 0 - ————————————————————————————————————————————————————————————————


2024-12-17 11:11:09,069 - INFO Retriever 0 - Agent主脑给出的回答为：{
    "read_file": {
        "file_path": "D:\\Unity\\jyx2\\Assets\\LuaScripts\\Jyx2Battle\\AIManager.lua"
    }
}
2024-12-17 11:11:09,069 - INFO Retriever 0 - 是否成功解析：True
2024-12-17 11:11:09,069 - INFO Retriever 0 - operation_type (__det_dir_action):
2024-12-17 11:11:09,069 - INFO Retriever 0 - read_file
2024-12-17 11:11:09,069 - INFO Retriever 0 - 

——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
2024-12-17 11:11:09,069 - INFO Retriever 0 - Assistant:
2024-12-17 11:11:09,071 - INFO Retriever 0 - {
    "read_file": {
        "file_path": "D:\\Unity\\jyx2\\Assets\\LuaScripts\\Jyx2Battle\\AIManager.lua"
    }
}
2024-12-17 11:11:09,071 - INFO Retriever 0 - dict_keys(['read_file'])
2024-12-17 11:11:09,071 - INFO Retriever 0 - Agent主脑给出的行动：read_file
参数：{'file_path': 'D:\\Unity\\jyx2\\Assets\\LuaScripts\\Jyx2Battle\\AIManager.lua', 'top_path': 'D:/Unity/jyx2\\Assets', 'return_file_sum': <bound method TreeGenerationAction.return_file_sum of <Action.tree_gen_action.TreeGenerationAction object at 0x0000027D71AB0D90>>}
2024-12-17 11:11:09,110 - INFO Retriever 0 - Observer: 这是一个名为“AIManager.lua”的文件，该文件里的内容为：
由于脚本文件内容过长，暂时仅给出该脚本文件的内容总结:
- ### 总体概述
该脚本是一个Lua编写的游戏战斗AI模块，用于金庸群侠传3D重制版游戏中。它主要负责处理游戏中的角色AI逻辑，包括初始化、角色位置更新、AI决策和结果反馈。

### 模块和功能
- **初始化和反初始化**：`Init`和`DeInit`函数用于初始化和反初始化AI模块。
- **角色位置更新**：`RefreshRolePos`函数用于更新存活角色的位置信息。
- **AI决策**：`GetAIResult`函数是核心，它根据角色的状态和周围环境做出决策。
- **物品和技能管理**：包括获取可用物品、获取最近敌人、获取技能释放评分等功能。

### 类和函数
- **`ai`**：主要类，包含所有AI相关的函数和方法。
- **`Init`**：初始化AI模块，设置随机种子，加载技能和伤害计算器。
- **`DeInit`**：反初始化AI模块，清除资源。
- **`GetAIResult`**：获取AI决策结果，包括移动、攻击或休息。
- **`GetAvailableItems`**：获取角色可用的物品。
- **`GetNearestEnemy`**：获取最近的敌人角色。
- **`GetNearestEnemyBlock`**：获取最近的敌人位置。
- **`GetFarestEnemyBlock`**：获取离敌人最远的点。
- **`GetMoveAndCastPos`**：获取移动和施放技能的位置。
- **`GetSkillCastResultScore`**：计算技能释放的评分。
- **`MoveToNearestEnemy`**：移动到最近的敌人。
- **`Rest`**：原地休息。

### 实现逻辑
- **初始化**：加载必要的组件和资源。
- **角色位置更新**：定期更新存活角色的位置信息。
- **AI决策**：根据角色状态和周围环境，通过穷举搜索等方式，决定角色的下一步行动（移动、攻击或休息）。
- **结果反馈**：将AI决策的结果反馈给游戏引擎，以执行相应的动作。
在这个脚本中存在如下的一些函数：CheckPosRole、CheckRoleTeam、DeInit、GetAIResult、GetAvailableItems、GetCastScore、GetFarestEnemyBlock、GetMoveAndCastPos、GetNearestEnemy、GetNearestEnemyBlock、GetSkillCastResultScore、Init、MoveToNearestEnemy、RefreshRolePos、Rest、checkTeam
这些函数有以下详细信息：
- 技能是攻击技能时 如果目标位置没有人或者是队友，则跳过 目标格子和移动位置相同，自己包含在施放范围中 如果目标位置有人且是队友 获取技能释放评分 获取场上角色 角色位置 获取场上角色 角色位置 获取攻击方向 技能覆盖的坐标 四个方向循环 普通攻击伤害与距离成反比，需要寻找最近点放 用毒的时候根据角色血量选择策略 丢给自己的，随便乱跑一个地方丢 缓存常用数据 如果是点攻击，使用简化方案 尽量离非目标敌人远 与全部敌人的距离 技能施放位置与移动后位置之距离 如果aimpos == -1，说明这个位置打不到人 如果是攻击型，则远离敌人 非攻击型，靠近队友 如果是攻击型，则优先靠近目标，再次远离其他敌人 非攻击型，靠近队友 带攻击范围的，找最多人丢 最短距离乘以策略，只有策略不是0时，才考虑最短距离问题 打敌人时不打到队友 给队友加血不能加到敌人 还活着 local result = CS.AIManager.Instance:GetSkillResult(caster, targetRole, skill, blockVector); 解毒算分 医疗算分 用毒算分 暗器算分
- print(role.Name) 获得角色移动能力 行动范围 可使用招式 AI算法：穷举每个点，使用招式，取最大收益 profiler.start() 考虑吃药 如果身上有物品，进行物品相关初始化 使用体力药 使用生命药 如果血量太少，吃药优先级将特别高，防止npc沉迷打怪 使用内力药 使用解毒药 使用暗器 print("aqName"..anqiSkillCast.Anqi.Name.."score"..score.."mpos"..tmp[1]:ToInt().."cpos"..tmp[2]:ToInt()) print("No Item Use") 使用武学 print("skname:"..skill.Data.Name.." score"..score.."mpos"..tmp[1]:ToInt().."cpos"..tmp[2]:ToInt()) 如果前面可以得出结果，就反馈 否则靠近自己最近的敌人 否则原地休息 如果角色是玩家战友且是玩家队伍里面的 如果没有给被寻找的角色表，那就获取一份 寻找离自己最近的敌人 寻找离对手最近的一点 寻找一个点离敌人最远 遍历时过滤不可达的位置，以免引发异常 检查格子上是否有角色 返回0表示没有，返回1表示队友，返回2表示敌人 技能是攻击技能时 如果目标位置没有人或者是队友，则跳过 目标格子和移动位置相同，自己包含在施放范围中 如果目标位置有人且是队友 获取技能释放评分 获取场上角色 角色位置 获取场上角色 角色位置 获取攻击方向 技能覆盖的坐标 四个方向循环 普通攻击伤害与距离成反比，需要寻找最近点放 用毒的时候根据角色血量选择策略 丢给自己的，随便乱跑一个地方丢 缓存常用数据 如果是点攻击，使用简化方案 尽量离非目标敌人远 与全部敌人的距离 技能施放位置与移动后位置之距离 如果aimpos == -1，说明这个位置打不到人 如果是攻击型，则远离敌人 非攻击型，靠近队友 如果是攻击型，则优先靠近目标，再次远离其他敌人 非攻击型，靠近队友 带攻击范围的，找最多人丢 最短距离乘以策略，只有策略不是0时，才考虑最短距离问题 打敌人时不打到队友 给队友加血不能加到敌人 还活着 local result = CS.AIManager.Instance:GetSkillResult(caster, targetRole, skill, blockVector); 解毒算分 医疗算分 用毒算分 暗器算分
- 如果角色是玩家战友且是玩家队伍里面的
- 获取场上角色 角色位置 获取场上角色 角色位置 获取攻击方向 技能覆盖的坐标 四个方向循环 普通攻击伤害与距离成反比，需要寻找最近点放 用毒的时候根据角色血量选择策略 丢给自己的，随便乱跑一个地方丢 缓存常用数据 如果是点攻击，使用简化方案 尽量离非目标敌人远 与全部敌人的距离 技能施放位置与移动后位置之距离 如果aimpos == -1，说明这个位置打不到人 如果是攻击型，则远离敌人 非攻击型，靠近队友 如果是攻击型，则优先靠近目标，再次远离其他敌人 非攻击型，靠近队友 带攻击范围的，找最多人丢 最短距离乘以策略，只有策略不是0时，才考虑最短距离问题 打敌人时不打到队友 给队友加血不能加到敌人 还活着 local result = CS.AIManager.Instance:GetSkillResult(caster, targetRole, skill, blockVector); 解毒算分 医疗算分 用毒算分 暗器算分
- 寻找一个点离敌人最远 遍历时过滤不可达的位置，以免引发异常
- 普通攻击伤害与距离成反比，需要寻找最近点放 用毒的时候根据角色血量选择策略 丢给自己的，随便乱跑一个地方丢 缓存常用数据 如果是点攻击，使用简化方案 尽量离非目标敌人远 与全部敌人的距离 技能施放位置与移动后位置之距离 如果aimpos == -1，说明这个位置打不到人 如果是攻击型，则远离敌人 非攻击型，靠近队友 如果是攻击型，则优先靠近目标，再次远离其他敌人 非攻击型，靠近队友 带攻击范围的，找最多人丢 最短距离乘以策略，只有策略不是0时，才考虑最短距离问题 打敌人时不打到队友 给队友加血不能加到敌人 还活着 local result = CS.AIManager.Instance:GetSkillResult(caster, targetRole, skill, blockVector); 解毒算分 医疗算分 用毒算分 暗器算分
- 如果没有给被寻找的角色表，那就获取一份 寻找离自己最近的敌人
- 寻找离对手最近的一点
- 还活着 local result = CS.AIManager.Instance:GetSkillResult(caster, targetRole, skill, blockVector); 解毒算分 医疗算分 用毒算分 暗器算分
- print(role.Name) 获得角色移动能力 行动范围 可使用招式 AI算法：穷举每个点，使用招式，取最大收益 profiler.start() 考虑吃药 如果身上有物品，进行物品相关初始化 使用体力药 使用生命药 如果血量太少，吃药优先级将特别高，防止npc沉迷打怪 使用内力药 使用解毒药 使用暗器 print("aqName"..anqiSkillCast.Anqi.Name.."score"..score.."mpos"..tmp[1]:ToInt().."cpos"..tmp[2]:ToInt()) print("No Item Use") 使用武学 print("skname:"..skill.Data.Name.." score"..score.."mpos"..tmp[1]:ToInt().."cpos"..tmp[2]:ToInt()) 如果前面可以得出结果，就反馈 否则靠近自己最近的敌人 否则原地休息 如果角色是玩家战友且是玩家队伍里面的 如果没有给被寻找的角色表，那就获取一份 寻找离自己最近的敌人 寻找离对手最近的一点 寻找一个点离敌人最远 遍历时过滤不可达的位置，以免引发异常 检查格子上是否有角色 返回0表示没有，返回1表示队友，返回2表示敌人 技能是攻击技能时 如果目标位置没有人或者是队友，则跳过 目标格子和移动位置相同，自己包含在施放范围中 如果目标位置有人且是队友 获取技能释放评分 获取场上角色 角色位置 获取场上角色 角色位置 获取攻击方向 技能覆盖的坐标 四个方向循环 普通攻击伤害与距离成反比，需要寻找最近点放 用毒的时候根据角色血量选择策略 丢给自己的，随便乱跑一个地方丢 缓存常用数据 如果是点攻击，使用简化方案 尽量离非目标敌人远 与全部敌人的距离 技能施放位置与移动后位置之距离 如果aimpos == -1，说明这个位置打不到人 如果是攻击型，则远离敌人 非攻击型，靠近队友 如果是攻击型，则优先靠近目标，再次远离其他敌人 非攻击型，靠近队友 带攻击范围的，找最多人丢 最短距离乘以策略，只有策略不是0时，才考虑最短距离问题 打敌人时不打到队友 给队友加血不能加到敌人 还活着 local result = CS.AIManager.Instance:GetSkillResult(caster, targetRole, skill, blockVector); 解毒算分 医疗算分 用毒算分 暗器算分
- 打敌人时不打到队友 给队友加血不能加到敌人
2024-12-17 11:11:09,114 - INFO Retriever 0 - 

————————————————————————————————————————————————————————————————
2024-12-17 11:11:09,114 - INFO Retriever 0 - 当前窗口总长度：43
2024-12-17 11:11:09,114 - INFO Retriever 0 - 当前更新窗口长度：34
2024-12-17 11:11:09,114 - INFO Retriever 0 - 当前更新窗口长度：34
2024-12-17 11:11:09,114 - INFO Retriever 0 - ————————————————————————————————————————————————————————————————


2024-12-17 11:11:34,574 - INFO Retriever 0 - Agent主脑给出的回答为：{
  "根据文件内容概述": "AIManager.lua 脚本负责处理游戏中的角色AI逻辑，包括初始化、角色位置更新、AI决策和结果反馈。虽然该脚本没有直接涉及动画控制，但了解角色AI的逻辑对于分析如何修改角色行动以实现固定战斗动画是有帮助的。接下来，我将读取其他可能与问题描述相关的文件，以便进一步分析。"
}
2024-12-17 11:11:34,574 - INFO Retriever 0 - 是否成功解析：True
2024-12-17 11:11:34,574 - INFO Retriever 0 - operation_type (__det_dir_action):
2024-12-17 11:11:34,574 - INFO Retriever 0 - 根据文件内容概述
2024-12-17 11:11:34,575 - INFO Retriever 0 - 

——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
2024-12-17 11:11:34,575 - INFO Retriever 0 - Assistant:
2024-12-17 11:11:34,575 - INFO Retriever 0 - {
  "根据文件内容概述": "AIManager.lua 脚本负责处理游戏中的角色AI逻辑，包括初始化、角色位置更新、AI决策和结果反馈。虽然该脚本没有直接涉及动画控制，但了解角色AI的逻辑对于分析如何修改角色行动以实现固定战斗动画是有帮助的。接下来，我将读取其他可能与问题描述相关的文件，以便进一步分析。"
}
2024-12-17 11:11:34,575 - INFO Retriever 0 - dict_keys(['根据文件内容概述'])
2024-12-17 11:11:34,576 - WARNING Retriever 0 - 你给出的操作类型不属于指定的操作类型。可以进行的操作类型有：['get_folder_info', 'read_file', 'read_long_details', 'retrieve_keywords', 'deep_think']，请重新给出你的操作。
2024-12-17 11:11:34,578 - INFO Retriever 0 - 

————————————————————————————————————————————————————————————————
2024-12-17 11:11:34,578 - INFO Retriever 0 - 当前窗口总长度：45
2024-12-17 11:11:34,579 - INFO Retriever 0 - 当前更新窗口长度：36
2024-12-17 11:11:34,579 - INFO Retriever 0 - 当前更新窗口长度：36
2024-12-17 11:11:34,579 - INFO Retriever 0 - ————————————————————————————————————————————————————————————————


2024-12-17 11:11:47,630 - INFO Retriever 0 - Agent主脑给出的回答为：{
    "read_file": {
        "file_path": "D:\\Unity\\jyx2\\Assets\\3rd\\Animancer\\Internal\\Core\\AnimancerState.cs"
    }
}
2024-12-17 11:11:47,631 - INFO Retriever 0 - 是否成功解析：True
2024-12-17 11:11:47,631 - INFO Retriever 0 - operation_type (__det_dir_action):
2024-12-17 11:11:47,631 - INFO Retriever 0 - read_file
2024-12-17 11:11:47,632 - INFO Retriever 0 - 

——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
2024-12-17 11:11:47,632 - INFO Retriever 0 - Assistant:
2024-12-17 11:11:47,632 - INFO Retriever 0 - {
    "read_file": {
        "file_path": "D:\\Unity\\jyx2\\Assets\\3rd\\Animancer\\Internal\\Core\\AnimancerState.cs"
    }
}
2024-12-17 11:11:47,632 - INFO Retriever 0 - dict_keys(['read_file'])
2024-12-17 11:11:47,632 - INFO Retriever 0 - Agent主脑给出的行动：read_file
参数：{'file_path': 'D:\\Unity\\jyx2\\Assets\\3rd\\Animancer\\Internal\\Core\\AnimancerState.cs', 'top_path': 'D:/Unity/jyx2\\Assets', 'return_file_sum': <bound method TreeGenerationAction.return_file_sum of <Action.tree_gen_action.TreeGenerationAction object at 0x0000027D71AB0D90>>}
2024-12-17 11:11:47,655 - INFO Retriever 0 - Observer: 这是一个名为“AnimancerState.cs”的文件，该文件里的内容为：
由于脚本文件内容过长，暂时仅给出该脚本文件的内容总结:
- ### 总体概述
- **框架和模块化结构**：该脚本定义了一个名为 `AnimancerState` 的抽象类，它是用于管理动画播放状态的基类。该类继承自 `AnimancerNode` 并实现了 `IAnimationClipCollection` 接口。
- **主要功能和目标**：该脚本的主要目标是提供一个框架，用于在 `AnimancerPlayable` 图中管理一个或多个 `Playable` 对象，以控制动画的播放、暂停、停止和淡入淡出。

### 模块和功能
- **Graph 模块**：管理 `AnimancerPlayable` 图中的节点和连接。
- **Key and Clip 模块**：处理与动画剪辑相关的键和剪辑对象。
- **Playing 模块**：控制动画的播放、暂停和停止。
- **Timing 模块**：处理动画的时间控制和持续时间。
- **Methods 模块**：包含用于更新、销毁和收集动画剪辑的方法。

### 类和函数
- **类**：
  - `AnimancerState`：管理动画状态的基类。
  - `Transition<TState>`：用于创建特定类型 `AnimancerState` 的可序列化转换基类。
- **函数**：
  - `SetRoot`：设置动画图根节点。
  - `SetParent`：设置动画状态的父节点。
  - `Play`：立即播放动画。
  - `Stop`：停止动画。
  - `Time`：获取或设置动画的当前时间。
  - `Duration`：获取或设置动画的持续时间。

### 实现逻辑
- `AnimancerState` 类通过继承 `AnimancerNode` 和实现 `IAnimationClipCollection` 接口，提供了管理动画状态所需的基本功能。
- 通过 `SetRoot` 和 `SetParent` 方法，可以构建和管理动画图。
- `Play` 和 `Stop` 方法控制动画的播放状态。
- `Time` 和 `Duration` 属性允许精确控制动画的时间进度和持续时间。
在这个脚本中存在如下的一些函数：Animancer、AnimancerState、AppendDetails、AppendPath、AppendPortAndType、Apply、AverageAngularSpeed、AverageVelocity、AverageVelocity、BaseState、CancelSetTime、ClearParent、Clip、CreateDrawer、CreatePlayable、CreateState、Destroy、Duration、EffectiveWeight、Events、FadeDuration、FadeMode、GatherAnimationClips、GetPath、ITransition.CreateState、IsActive、IsLooping、IsLooping、IsPlaying、IsPlayingAndNotEnding、IsStopped、IsValid、Key、Key、Layer、LayerIndex、Length、MainObject、MainObject、MaximumDuration、Name、NestedObjectDrawers、NormalizedEndTime、NormalizedStartTime、NormalizedTime、Object、Object、OnSetIsPlaying、OnStartFade、Parent、Play、RawTime、RemainingDuration、SerializedEvents、SetParent、SetRoot、Speed、State、Stop、Time、ToString、ToString、Transition、Update、_Events、_FadeDuration、_IsPlaying、_IsPlayingDirty、_Key、_MustSetTime、_Parent、_State、_Time、_TimeFrameID
这些函数有以下详细信息：
- <summary> Base class for all states in an <see cref="AnimancerPlayable"/> graph which manages one or more <see cref="Playable"/>s. </summary> <remarks> This class can be used as a custom yield instruction to wait until the animation either stops playing or reaches its end. <para></para> Documentation: <see href="https://kybernetik.com.au/animancer/docs/manual/playing/states">States</see> </remarks> https://kybernetik.com.au/animancer/api/Animancer/AnimancerState <summary>The <see cref="AnimancerPlayable"/> at the root of the graph.</summary> <summary>The object which receives the output of the <see cref="Playable"/>.</summary> <summary>Connects this state to the `parent` mixer at the specified `index`.</summary> <remarks> Use <see cref="AnimancerLayer.AddChild(AnimancerState)"/> instead of this method to connect a state to an available port on a layer. </remarks> <summary>[Internal] Called by <see cref="AnimancerNode.OnAddChild(IList{AnimancerState}, AnimancerState)"/> if the specified port is already occupied so it can be cleared without triggering any other calls. </summary> <summary> The <see cref="AnimancerNode.Weight"/> of this state multiplied by the <see cref="AnimancerNode.Weight"/> of each of its parents down the hierarchy to determine how much this state affects the final output. </summary> <exception cref="NullReferenceException">This state has no <see cref="AnimancerNode.Parent"/>.</exception> <inheritdoc/> <summary> The index of the <see cref="AnimancerLayer"/> this state is connected to (determined by the <see cref="Parent"/>). </summary> <summary> The object used to identify this state in the root <see cref="AnimancerPlayable.States"/> dictionary. Can be null. </summary> <summary>The <see cref="AnimationClip"/> which this state plays (if any).</summary> <exception cref="NotSupportedException">This state type doesn't have a clip and you try to set it.</exception> <summary>The main object to show in the Inspector for this state (if any).</summary> <exception cref="NotSupportedException">This state type doesn't have a main object and you try to set it.</exception> <exception cref="InvalidCastException">This state can't use the assigned value.</exception> <summary> Sets the `currentObject` and calls <see cref="AnimancerNode.RecreatePlayable"/>. If the `currentObject` was being used as the <see cref="Key"/> then it is changed as well. </summary> <exception cref="ArgumentNullException">The `newObject` is null.</exception> <summary>The average velocity of the root motion caused by this state.</summary> <summary>Is the <see cref="Time"/> automatically advancing?</summary> <summary>Has <see cref="_IsPlaying"/> changed since it was last applied to the <see cref="Playable"/>.</summary> <remarks> Playables start playing by default so we start dirty to pause it during the first update (unless <see cref="IsPlaying"/> is set to true before that). </remarks> <summary>Is the <see cref="Time"/> automatically advancing?</summary> <example><code> void IsPlayingExample(AnimancerComponent animancer, AnimationClip clip) { var state = animancer.States.GetOrCreate(clip); if (state.IsPlaying) Debug.Log(clip + " is playing"); else Debug.Log(clip + " is paused"); state.IsPlaying = false;// Pause the animation. state.IsPlaying = true;// Unpause the animation. } </code></example> <summary>Called when the value of <see cref="IsPlaying"/> is changed.</summary> <summary>Creates and assigns the <see cref="Playable"/> managed by this state.</summary> <remarks>This method also applies the <see cref="AnimancerNode.Speed"/> and <see cref="IsPlaying"/>.</remarks> <summary> Returns true if this state is playing and is at or fading towards a non-zero <see cref="AnimancerNode.Weight"/>. </summary> <summary> Returns true if this state is not playing and is at 0 <see cref="AnimancerNode.Weight"/>. </summary> <summary>Plays this state immediately, without any blending.</summary> <remarks> Sets <see cref="IsPlaying"/> = true, <see cref="AnimancerNode.Weight"/> = 1, and clears the <see cref="Events"/> (unless <see cref="AutomaticallyClearEvents"/> is disabled). <para></para> This method does not change the <see cref="Time"/> so it will continue from its current value. </remarks> <summary>Stops the animation and makes it inactive immediately so it no longer affects the output.</summary> <remarks> Sets <see cref="AnimancerNode.Weight"/> = 0, <see cref="IsPlaying"/> = false, <see cref="Time"/> = 0, and clears the <see cref="Events"/> (unless <see cref="AutomaticallyClearEvents"/> is disabled). <para></para> To freeze the animation in place without ending it, you only need to set <see cref="IsPlaying"/> = false instead. Or to freeze all animations, you can call <see cref="AnimancerPlayable.PauseGraph"/>. </remarks> <summary> Called by <see cref="AnimancerNode.StartFade"/>. Clears the <see cref="Events"/> (unless <see cref="AutomaticallyClearEvents"/> is disabled). </summary> <summary> The current time of the <see cref="Playable"/>, retrieved by <see cref="Time"/> whenever the <see cref="_TimeFrameID"/> is different from the <see cref="AnimancerPlayable.FrameID"/>. </summary> <summary> Indicates whether the <see cref="_Time"/> needs to be assigned to the <see cref="Playable"/> next update. </summary> <remarks> <see cref="EventDispatcher"/> executes after all other playables, at which point changes can still be made to their time but not their weight which means that if we set the time immediately then it can be out of sync with the weight. For example, if an animation ends and you play another, the first animation would be stopped and rewinded to the start but would still be at full weight so it would show its first frame before the new animation actually takes effect (even if the previous animation was not looping). <para></para> So instead, we simply delay setting the actual playable time until the next update so that time and weight are always in sync. </remarks> <summary> The <see cref="AnimancerPlayable.FrameID"/> from when the <see cref="Time"/> was last retrieved from the <see cref="Playable"/>. </summary> <summary>The number of seconds that have passed since the start of this animation.</summary> <remarks> This value will continue increasing after the animation passes the end of its <see cref="Length"/> while the animated object either freezes in place or starts again from the beginning according to whether it is looping or not. <para></para> This property internally uses <see cref="RawTime"/> whenever the value is out of date or gets changed. <para></para> <em>Animancer Lite does not allow this value to be changed in runtime builds (except resetting it to 0).</em> </remarks> <example><code> void PlayAnimation(AnimancerComponent animancer, AnimationClip clip) { var state = animancer.Play(clip); // Skip 0.5 seconds into the animation: state.Time = 0.5f; // Skip 50% of the way through the animation (0.5 in a range of 0 to 1): state.NormalizedTime = 0.5f; // Skip to the end of the animation and play backwards. state.NormalizedTime = 1; state.Speed = -1; } </code></example> <summary> The internal implementation of <see cref="Time"/> which directly gets and sets the underlying value. </summary> <remarks> Setting this value actually calls <see cref="PlayableExtensions.SetTime"/> twice to ensure that animation events aren't triggered incorrectly. Calling it only once would trigger any animation events between the previous time and the new time. So if an animation plays to the end and you set the time back to 0 (such as by calling <see cref="Stop"/> or playing a different animation), the next time that animation played it would immediately trigger all of its events, then play through and trigger them normally as well. </remarks> <summary> The <see cref="Time"/> of this state as a portion of the animation's <see cref="Length"/>, meaning the value goes from 0 to 1 as it plays from start to end, regardless of how long that actually takes. </summary> <remarks> This value will continue increasing after the animation passes the end of its <see cref="Length"/> while the animated object either freezes in place or starts again from the beginning according to whether it is looping or not. <para></para> The fractional part of the value (<c>NormalizedTime % 1</c>) is the percentage (0-1) of progress in the current loop while the integer part (<c>(int)NormalizedTime</c>) is the number of times the animation has been looped. <para></para> <em>Animancer Lite does not allow this value to be changed to a value other than 0 in runtime builds.</em> </remarks> <example><code> void PlayAnimation(AnimancerComponent animancer, AnimationClip clip) { var state = animancer.Play(clip); // Skip 0.5 seconds into the animation: state.Time = 0.5f; // Skip 50% of the way through the animation (0.5 in a range of 0 to 1): state.NormalizedTime = 0.5f; // Skip to the end of the animation and play backwards. state.NormalizedTime = 1; state.Speed = -1; } </code></example> <summary>Prevents the <see cref="RawTime"/> from being applied.</summary> <summary>[Pro-Only] The <see cref="NormalizedTime"/> after which the <see cref="AnimancerEvent.Sequence.OnEnd"/> callback will be invoked every frame. </summary> <remarks> This is a wrapper around <see cref="AnimancerEvent.Sequence.NormalizedEndTime"/> so that if the value has not been set (<see cref="float.NaN"/>) it can be determined based on the <see cref="AnimancerNode.EffectiveSpeed"/>: positive speed ends at 1 and negative speed ends at 0. <para></para> <em>Animancer Lite does not allow this value to be changed in runtime builds.</em> </remarks> <summary> The number of seconds the animation will take to play fully at its current <see cref="AnimancerNode.EffectiveSpeed"/>. </summary> <remarks> For the time remaining from now until it reaches the end, use <see cref="RemainingDuration"/> instead. <para></para> Setting this value modifies the <see cref="AnimancerNode.EffectiveSpeed"/>, not the <see cref="Length"/>. <para></para> <em>Animancer Lite does not allow this value to be changed in runtime builds.</em> </remarks> <example><code> void PlayAnimation(AnimancerComponent animancer, AnimationClip clip) { var state = animancer.Play(clip); state.Duration = 1;// Play fully in 1 second. state.Duration = 2;// Play fully in 2 seconds. state.Duration = 0.5f;// Play fully in half a second. state.Duration = -1;// Play backwards fully in 1 second. state.NormalizedTime = 1; state.Duration = -1;// Play backwards from the end in 1 second. } </code></example> <summary> The number of seconds this state will take to go from its current <see cref="NormalizedTime"/> to the <see cref="NormalizedEndTime"/> at its current <see cref="AnimancerNode.EffectiveSpeed"/>. </summary> <remarks> For the time it would take to play fully from the start, use the <see cref="Duration"/> instead. <para></para> Setting this value modifies the <see cref="AnimancerNode.EffectiveSpeed"/>, not the <see cref="Length"/>. <para></para> <em>Animancer Lite does not allow this value to be changed in runtime builds.</em> </remarks> <example><code> void PlayAnimation(AnimancerComponent animancer, AnimationClip clip) { var state = animancer.Play(clip); state.RemainingDuration = 1;// Play from the current time to the end in 1 second. state.RemainingDuration = 2;// Play from the current time to the end in 2 seconds. state.RemainingDuration = 0.5f;// Play from the current time to the end in half a second. state.RemainingDuration = -1;// Play from the current time away from the end. } </code></example> <summary>The total time this state would take to play in seconds when <see cref="AnimancerNode.Speed"/> = 1.</summary> <summary>Will this state loop back to the start when it reaches the end?</summary> <summary> Updates the <see cref="AnimancerNode.Weight"/> for fading, applies it to this state's port on the parent mixer, and plays or pauses the <see cref="Playable"/> if its state is dirty. </summary> <remarks> If the <see cref="Parent"/>'s <see cref="AnimancerNode.KeepChildrenConnected"/> is set to false, this method will also connect/disconnect this node from the <see cref="Parent"/> in the playable graph. </remarks> <summary>Destroys the <see cref="Playable"/> and cleans up this state.</summary> <remarks> This method is NOT called automatically, so when implementing a custom state type you must use <see cref="AnimancerPlayable.Disposables"/> if you need to guarantee that things will get cleaned up. </remarks> <summary>[<see cref="IAnimationClipCollection"/>] Gathers all the animations in this state.</summary> <summary> Returns true if the animation is playing and has not yet passed the <see cref="AnimancerEvent.Sequence.endEvent"/>. </summary> <remarks> This method is called by <see cref="IEnumerator.MoveNext"/> so this object can be used as a custom yield instruction to wait until it finishes. </remarks> <summary> Returns the <see cref="AnimancerNode.DebugName"/> if one is set, otherwise a string describing the type of this state and the name of the <see cref="MainObject"/>. </summary> <summary>[Editor-Only] Returns a custom drawer for this state.</summary> <inheritdoc/> <summary>Returns the hierarchy path of this state through its <see cref="Parent"/>s.</summary> <summary>Appends the hierarchy path of this state through its <see cref="Parent"/>s.</summary> <summary>Appends "[Index] -> GetType().Name".</summary> <summary> Base class for serializable <see cref="ITransition"/>s which can create a particular type of <see cref="AnimancerState"/> when passed into <see cref="AnimancerPlayable.Play(ITransition)"/>. </summary> <remarks> Unfortunately the tool used to generate this documentation does not currently support nested types with identical names, so only one <c>Transition</c> class will actually have a documentation page. <para></para> Even though it has the <see cref="SerializableAttribute"/>, this class won't actually get serialized by Unity because it's generic and abstract. Each child class still needs to include the attribute. <para></para> Documentation: <see href="https://kybernetik.com.au/animancer/docs/manual/transitions">Transitions</see> </remarks> https://kybernetik.com.au/animancer/api/Animancer/Transition_1 <summary>[<see cref="SerializeField"/>] The amount of time the transition will take (in seconds).</summary> <exception cref="ArgumentOutOfRangeException">Thrown when setting the value to a negative number.</exception> <summary>[<see cref="ITransitionDetailed"/>] Indicates what the value of <see cref="AnimancerState.IsLooping"/> will be for the created state. Returns false unless overridden. </summary> <summary>[<see cref="ITransitionDetailed"/>] Determines what <see cref="NormalizedTime"/> to start the animation at. Returns <see cref="float.NaN"/> unless overridden. </summary> <summary>[<see cref="ITransitionDetailed"/>] Determines how fast the animation plays (1x = normal speed). Returns 1 unless overridden. </summary> <summary>[<see cref="ITransitionDetailed"/>] The maximum amount of time the animation is expected to take (in seconds). </summary> <remarks>The actual duration can vary in states like <see cref="MixerState"/>.</remarks> <summary>[<see cref="ITransitionDetailed"/>] The <see cref="Motion.averageAngularSpeed"/> that the created state will have. </summary> <remarks>The actual average velocity can vary in states like <see cref="MixerState"/>.</remarks> <summary>[<see cref="ITransitionDetailed"/>] The <see cref="Motion.averageSpeed"/> that the created state will have. </summary> <remarks>The actual average velocity can vary in states like <see cref="MixerState"/>.</remarks> <summary>[<see cref="SerializeField"/>] [<see cref="ITransitionDetailed"/>] Events which will be triggered as the animation plays. </summary> <remarks>This property returns the <see cref="AnimancerEvent.Sequence.Serializable.Sequence"/>.</remarks> <summary>[<see cref="SerializeField"/>] [<see cref="ITransitionDetailed"/>] Events which will be triggered as the animation plays. </summary> <summary> The state that was created by this object. Specifically, this is the state that was most recently passed into <see cref="Apply"/> (usually by <see cref="AnimancerPlayable.Play(ITransition)"/>). <para></para> You can use <see cref="AnimancerPlayable.StateDictionary.GetOrCreate(ITransition)"/> or <see cref="AnimancerLayer.GetOrCreateState(ITransition)"/> to get or create the state for a specific object. <para></para> <see cref="State"/> is simply a shorthand for casting this to <typeparamref name="TState"/>. </summary> <summary> The state that was created by this object. Specifically, this is the state that was most recently passed into <see cref="Apply"/> (usually by <see cref="AnimancerPlayable.Play(ITransition)"/>). </summary> <remarks> You can use <see cref="AnimancerPlayable.StateDictionary.GetOrCreate(ITransition)"/> or <see cref="AnimancerLayer.GetOrCreateState(ITransition)"/> to get or create the state for a specific object. <para></para> This property is shorthand for casting the <see cref="BaseState"/> to <typeparamref name="TState"/>. </remarks> <exception cref="InvalidCastException"> The <see cref="BaseState"/> is not actually a <typeparamref name="TState"/>. This should only happen if a different type of state was created by something else and registered using the <see cref="Key"/>, causing this <see cref="AnimancerPlayable.Play(ITransition)"/> to pass that state into <see cref="Apply"/> instead of calling <see cref="CreateState"/> to make the correct type of state. </exception> <summary>Indicates whether this transition can create a valid <see cref="AnimancerState"/>.</summary> <summary>The <see cref="AnimancerState.Key"/> which the created state will be registered with.</summary> <remarks>Returns <c>this</c> unless overridden.</remarks> <summary> When a transition is passed into <see cref="AnimancerPlayable.Play(ITransition)"/>, this property determines which <see cref="Animancer.FadeMode"/> will be used. </summary> <summary>Creates and returns a new <typeparamref name="TState"/>.</summary> <remarks> Note that using methods like <see cref="AnimancerPlayable.Play(ITransition)"/> will also call <see cref="Apply"/>, so if you call this method manually you may want to call that method as well. Or you can just use <see cref="AnimancerUtilities.CreateStateAndApply"/>. </remarks> <summary>Creates and returns a new <typeparamref name="TState"/>.</summary> <remarks> Note that using methods like <see cref="AnimancerPlayable.Play(ITransition)"/> will also call <see cref="Apply"/>, so if you call this method manually you may want to call that method as well. Or you can just use <see cref="AnimancerUtilities.CreateStateAndApply"/>. </remarks> <summary>[<see cref="ITransition"/>] Sets the <see cref="BaseState"/> and applies any other modifications to the `state`. </summary> <remarks> Called by <see cref="AnimancerPlayable.Play(ITransition)"/>. <para></para> This method also clears the <see cref="State"/> if necessary, so it will re-cast the <see cref="BaseState"/> when it gets accessed again. </remarks> <summary>The <see cref="AnimancerState.MainObject"/> that the created state will have.</summary> <summary>The display name of this transition.</summary> <summary>Returns the <see cref="Name"/> and type of this transition.</summary> <summary>[Editor-Only] Don't use Inspector Gadgets Nested Object Drawers.</summary>
- <summary>The <see cref="AnimancerPlayable"/> at the root of the graph.</summary> <summary>The object which receives the output of the <see cref="Playable"/>.</summary> <summary>Connects this state to the `parent` mixer at the specified `index`.</summary> <remarks> Use <see cref="AnimancerLayer.AddChild(AnimancerState)"/> instead of this method to connect a state to an available port on a layer. </remarks> <summary>[Internal] Called by <see cref="AnimancerNode.OnAddChild(IList{AnimancerState}, AnimancerState)"/> if the specified port is already occupied so it can be cleared without triggering any other calls. </summary> <summary> The <see cref="AnimancerNode.Weight"/> of this state multiplied by the <see cref="AnimancerNode.Weight"/> of each of its parents down the hierarchy to determine how much this state affects the final output. </summary> <exception cref="NullReferenceException">This state has no <see cref="AnimancerNode.Parent"/>.</exception> <inheritdoc/> <summary> The index of the <see cref="AnimancerLayer"/> this state is connected to (determined by the <see cref="Parent"/>). </summary> <summary> The object used to identify this state in the root <see cref="AnimancerPlayable.States"/> dictionary. Can be null. </summary> <summary>The <see cref="AnimationClip"/> which this state plays (if any).</summary> <exception cref="NotSupportedException">This state type doesn't have a clip and you try to set it.</exception> <summary>The main object to show in the Inspector for this state (if any).</summary> <exception cref="NotSupportedException">This state type doesn't have a main object and you try to set it.</exception> <exception cref="InvalidCastException">This state can't use the assigned value.</exception> <summary> Sets the `currentObject` and calls <see cref="AnimancerNode.RecreatePlayable"/>. If the `currentObject` was being used as the <see cref="Key"/> then it is changed as well. </summary> <exception cref="ArgumentNullException">The `newObject` is null.</exception> <summary>The average velocity of the root motion caused by this state.</summary> <summary>Is the <see cref="Time"/> automatically advancing?</summary> <summary>Has <see cref="_IsPlaying"/> changed since it was last applied to the <see cref="Playable"/>.</summary> <remarks> Playables start playing by default so we start dirty to pause it during the first update (unless <see cref="IsPlaying"/> is set to true before that). </remarks> <summary>Is the <see cref="Time"/> automatically advancing?</summary> <example><code> void IsPlayingExample(AnimancerComponent animancer, AnimationClip clip) { var state = animancer.States.GetOrCreate(clip); if (state.IsPlaying) Debug.Log(clip + " is playing"); else Debug.Log(clip + " is paused"); state.IsPlaying = false;// Pause the animation. state.IsPlaying = true;// Unpause the animation. } </code></example> <summary>Called when the value of <see cref="IsPlaying"/> is changed.</summary> <summary>Creates and assigns the <see cref="Playable"/> managed by this state.</summary> <remarks>This method also applies the <see cref="AnimancerNode.Speed"/> and <see cref="IsPlaying"/>.</remarks> <summary> Returns true if this state is playing and is at or fading towards a non-zero <see cref="AnimancerNode.Weight"/>. </summary> <summary> Returns true if this state is not playing and is at 0 <see cref="AnimancerNode.Weight"/>. </summary> <summary>Plays this state immediately, without any blending.</summary> <remarks> Sets <see cref="IsPlaying"/> = true, <see cref="AnimancerNode.Weight"/> = 1, and clears the <see cref="Events"/> (unless <see cref="AutomaticallyClearEvents"/> is disabled). <para></para> This method does not change the <see cref="Time"/> so it will continue from its current value. </remarks> <summary>Stops the animation and makes it inactive immediately so it no longer affects the output.</summary> <remarks> Sets <see cref="AnimancerNode.Weight"/> = 0, <see cref="IsPlaying"/> = false, <see cref="Time"/> = 0, and clears the <see cref="Events"/> (unless <see cref="AutomaticallyClearEvents"/> is disabled). <para></para> To freeze the animation in place without ending it, you only need to set <see cref="IsPlaying"/> = false instead. Or to freeze all animations, you can call <see cref="AnimancerPlayable.PauseGraph"/>. </remarks> <summary> Called by <see cref="AnimancerNode.StartFade"/>. Clears the <see cref="Events"/> (unless <see cref="AutomaticallyClearEvents"/> is disabled). </summary> <summary> The current time of the <see cref="Playable"/>, retrieved by <see cref="Time"/> whenever the <see cref="_TimeFrameID"/> is different from the <see cref="AnimancerPlayable.FrameID"/>. </summary> <summary> Indicates whether the <see cref="_Time"/> needs to be assigned to the <see cref="Playable"/> next update. </summary> <remarks> <see cref="EventDispatcher"/> executes after all other playables, at which point changes can still be made to their time but not their weight which means that if we set the time immediately then it can be out of sync with the weight. For example, if an animation ends and you play another, the first animation would be stopped and rewinded to the start but would still be at full weight so it would show its first frame before the new animation actually takes effect (even if the previous animation was not looping). <para></para> So instead, we simply delay setting the actual playable time until the next update so that time and weight are always in sync. </remarks> <summary> The <see cref="AnimancerPlayable.FrameID"/> from when the <see cref="Time"/> was last retrieved from the <see cref="Playable"/>. </summary> <summary>The number of seconds that have passed since the start of this animation.</summary> <remarks> This value will continue increasing after the animation passes the end of its <see cref="Length"/> while the animated object either freezes in place or starts again from the beginning according to whether it is looping or not. <para></para> This property internally uses <see cref="RawTime"/> whenever the value is out of date or gets changed. <para></para> <em>Animancer Lite does not allow this value to be changed in runtime builds (except resetting it to 0).</em> </remarks> <example><code> void PlayAnimation(AnimancerComponent animancer, AnimationClip clip) { var state = animancer.Play(clip); // Skip 0.5 seconds into the animation: state.Time = 0.5f; // Skip 50% of the way through the animation (0.5 in a range of 0 to 1): state.NormalizedTime = 0.5f; // Skip to the end of the animation and play backwards. state.NormalizedTime = 1; state.Speed = -1; } </code></example> <summary> The internal implementation of <see cref="Time"/> which directly gets and sets the underlying value. </summary> <remarks> Setting this value actually calls <see cref="PlayableExtensions.SetTime"/> twice to ensure that animation events aren't triggered incorrectly. Calling it only once would trigger any animation events between the previous time and the new time. So if an animation plays to the end and you set the time back to 0 (such as by calling <see cref="Stop"/> or playing a different animation), the next time that animation played it would immediately trigger all of its events, then play through and trigger them normally as well. </remarks> <summary> The <see cref="Time"/> of this state as a portion of the animation's <see cref="Length"/>, meaning the value goes from 0 to 1 as it plays from start to end, regardless of how long that actually takes. </summary> <remarks> This value will continue increasing after the animation passes the end of its <see cref="Length"/> while the animated object either freezes in place or starts again from the beginning according to whether it is looping or not. <para></para> The fractional part of the value (<c>NormalizedTime % 1</c>) is the percentage (0-1) of progress in the current loop while the integer part (<c>(int)NormalizedTime</c>) is the number of times the animation has been looped. <para></para> <em>Animancer Lite does not allow this value to be changed to a value other than 0 in runtime builds.</em> </remarks> <example><code> void PlayAnimation(AnimancerComponent animancer, AnimationClip clip) { var state = animancer.Play(clip); // Skip 0.5 seconds into the animation: state.Time = 0.5f; // Skip 50% of the way through the animation (0.5 in a range of 0 to 1): state.NormalizedTime = 0.5f; // Skip to the end of the animation and play backwards. state.NormalizedTime = 1; state.Speed = -1; } </code></example> <summary>Prevents the <see cref="RawTime"/> from being applied.</summary> <summary>[Pro-Only] The <see cref="NormalizedTime"/> after which the <see cref="AnimancerEvent.Sequence.OnEnd"/> callback will be invoked every frame. </summary> <remarks> This is a wrapper around <see cref="AnimancerEvent.Sequence.NormalizedEndTime"/> so that if the value has not been set (<see cref="float.NaN"/>) it can be determined based on the <see cref="AnimancerNode.EffectiveSpeed"/>: positive speed ends at 1 and negative speed ends at 0. <para></para> <em>Animancer Lite does not allow this value to be changed in runtime builds.</em> </remarks> <summary> The number of seconds the animation will take to play fully at its current <see cref="AnimancerNode.EffectiveSpeed"/>. </summary> <remarks> For the time remaining from now until it reaches the end, use <see cref="RemainingDuration"/> instead. <para></para> Setting this value modifies the <see cref="AnimancerNode.EffectiveSpeed"/>, not the <see cref="Length"/>. <para></para> <em>Animancer Lite does not allow this value to be changed in runtime builds.</em> </remarks> <example><code> void PlayAnimation(AnimancerComponent animancer, AnimationClip clip) { var state = animancer.Play(clip); state.Duration = 1;// Play fully in 1 second. state.Duration = 2;// Play fully in 2 seconds. state.Duration = 0.5f;// Play fully in half a second. state.Duration = -1;// Play backwards fully in 1 second. state.NormalizedTime = 1; state.Duration = -1;// Play backwards from the end in 1 second. } </code></example> <summary> The number of seconds this state will take to go from its current <see cref="NormalizedTime"/> to the <see cref="NormalizedEndTime"/> at its current <see cref="AnimancerNode.EffectiveSpeed"/>. </summary> <remarks> For the time it would take to play fully from the start, use the <see cref="Duration"/> instead. <para></para> Setting this value modifies the <see cref="AnimancerNode.EffectiveSpeed"/>, not the <see cref="Length"/>. <para></para> <em>Animancer Lite does not allow this value to be changed in runtime builds.</em> </remarks> <example><code> void PlayAnimation(AnimancerComponent animancer, AnimationClip clip) { var state = animancer.Play(clip); state.RemainingDuration = 1;// Play from the current time to the end in 1 second. state.RemainingDuration = 2;// Play from the current time to the end in 2 seconds. state.RemainingDuration = 0.5f;// Play from the current time to the end in half a second. state.RemainingDuration = -1;// Play from the current time away from the end. } </code></example> <summary>The total time this state would take to play in seconds when <see cref="AnimancerNode.Speed"/> = 1.</summary> <summary>Will this state loop back to the start when it reaches the end?</summary> <summary> Updates the <see cref="AnimancerNode.Weight"/> for fading, applies it to this state's port on the parent mixer, and plays or pauses the <see cref="Playable"/> if its state is dirty. </summary> <remarks> If the <see cref="Parent"/>'s <see cref="AnimancerNode.KeepChildrenConnected"/> is set to false, this method will also connect/disconnect this node from the <see cref="Parent"/> in the playable graph. </remarks> <summary>Destroys the <see cref="Playable"/> and cleans up this state.</summary> <remarks> This method is NOT called automatically, so when implementing a custom state type you must use <see cref="AnimancerPlayable.Disposables"/> if you need to guarantee that things will get cleaned up. </remarks> <summary>[<see cref="IAnimationClipCollection"/>] Gathers all the animations in this state.</summary> <summary> Returns true if the animation is playing and has not yet passed the <see cref="AnimancerEvent.Sequence.endEvent"/>. </summary> <remarks> This method is called by <see cref="IEnumerator.MoveNext"/> so this object can be used as a custom yield instruction to wait until it finishes. </remarks> <summary> Returns the <see cref="AnimancerNode.DebugName"/> if one is set, otherwise a string describing the type of this state and the name of the <see cref="MainObject"/>. </summary> <summary>[Editor-Only] Returns a custom drawer for this state.</summary> <inheritdoc/> <summary>Returns the hierarchy path of this state through its <see cref="Parent"/>s.</summary> <summary>Appends the hierarchy path of this state through its <see cref="Parent"/>s.</summary> <summary>Appends "[Index] -> GetType().Name".</summary> <summary> Base class for serializable <see cref="ITransition"/>s which can create a particular type of <see cref="AnimancerState"/> when passed into <see cref="AnimancerPlayable.Play(ITransition)"/>. </summary> <remarks> Unfortunately the tool used to generate this documentation does not currently support nested types with identical names, so only one <c>Transition</c> class will actually have a documentation page. <para></para> Even though it has the <see cref="SerializableAttribute"/>, this class won't actually get serialized by Unity because it's generic and abstract. Each child class still needs to include the attribute. <para></para> Documentation: <see href="https://kybernetik.com.au/animancer/docs/manual/transitions">Transitions</see> </remarks> https://kybernetik.com.au/animancer/api/Animancer/Transition_1 <summary>[<see cref="SerializeField"/>] The amount of time the transition will take (in seconds).</summary> <exception cref="ArgumentOutOfRangeException">Thrown when setting the value to a negative number.</exception> <summary>[<see cref="ITransitionDetailed"/>] Indicates what the value of <see cref="AnimancerState.IsLooping"/> will be for the created state. Returns false unless overridden. </summary> <summary>[<see cref="ITransitionDetailed"/>] Determines what <see cref="NormalizedTime"/> to start the animation at. Returns <see cref="float.NaN"/> unless overridden. </summary> <summary>[<see cref="ITransitionDetailed"/>] Determines how fast the animation plays (1x = normal speed). Returns 1 unless overridden. </summary> <summary>[<see cref="ITransitionDetailed"/>] The maximum amount of time the animation is expected to take (in seconds). </summary> <remarks>The actual duration can vary in states like <see cref="MixerState"/>.</remarks> <summary>[<see cref="ITransitionDetailed"/>] The <see cref="Motion.averageAngularSpeed"/> that the created state will have. </summary> <remarks>The actual average velocity can vary in states like <see cref="MixerState"/>.</remarks> <summary>[<see cref="ITransitionDetailed"/>] The <see cref="Motion.averageSpeed"/> that the created state will have. </summary> <remarks>The actual average velocity can vary in states like <see cref="MixerState"/>.</remarks> <summary>[<see cref="SerializeField"/>] [<see cref="ITransitionDetailed"/>] Events which will be triggered as the animation plays. </summary> <remarks>This property returns the <see cref="AnimancerEvent.Sequence.Serializable.Sequence"/>.</remarks> <summary>[<see cref="SerializeField"/>] [<see cref="ITransitionDetailed"/>] Events which will be triggered as the animation plays. </summary> <summary> The state that was created by this object. Specifically, this is the state that was most recently passed into <see cref="Apply"/> (usually by <see cref="AnimancerPlayable.Play(ITransition)"/>). <para></para> You can use <see cref="AnimancerPlayable.StateDictionary.GetOrCreate(ITransition)"/> or <see cref="AnimancerLayer.GetOrCreateState(ITransition)"/> to get or create the state for a specific object. <para></para> <see cref="State"/> is simply a shorthand for casting this to <typeparamref name="TState"/>. </summary> <summary> The state that was created by this object. Specifically, this is the state that was most recently passed into <see cref="Apply"/> (usually by <see cref="AnimancerPlayable.Play(ITransition)"/>). </summary> <remarks> You can use <see cref="AnimancerPlayable.StateDictionary.GetOrCreate(ITransition)"/> or <see cref="AnimancerLayer.GetOrCreateState(ITransition)"/> to get or create the state for a specific object. <para></para> This property is shorthand for casting the <see cref="BaseState"/> to <typeparamref name="TState"/>. </remarks> <exception cref="InvalidCastException"> The <see cref="BaseState"/> is not actually a <typeparamref name="TState"/>. This should only happen if a different type of state was created by something else and registered using the <see cref="Key"/>, causing this <see cref="AnimancerPlayable.Play(ITransition)"/> to pass that state into <see cref="Apply"/> instead of calling <see cref="CreateState"/> to make the correct type of state. </exception> <summary>Indicates whether this transition can create a valid <see cref="AnimancerState"/>.</summary> <summary>The <see cref="AnimancerState.Key"/> which the created state will be registered with.</summary> <remarks>Returns <c>this</c> unless overridden.</remarks> <summary> When a transition is passed into <see cref="AnimancerPlayable.Play(ITransition)"/>, this property determines which <see cref="Animancer.FadeMode"/> will be used. </summary> <summary>Creates and returns a new <typeparamref name="TState"/>.</summary> <remarks> Note that using methods like <see cref="AnimancerPlayable.Play(ITransition)"/> will also call <see cref="Apply"/>, so if you call this method manually you may want to call that method as well. Or you can just use <see cref="AnimancerUtilities.CreateStateAndApply"/>. </remarks> <summary>Creates and returns a new <typeparamref name="TState"/>.</summary> <remarks> Note that using methods like <see cref="AnimancerPlayable.Play(ITransition)"/> will also call <see cref="Apply"/>, so if you call this method manually you may want to call that method as well. Or you can just use <see cref="AnimancerUtilities.CreateStateAndApply"/>. </remarks> <summary>[<see cref="ITransition"/>] Sets the <see cref="BaseState"/> and applies any other modifications to the `state`. </summary> <remarks> Called by <see cref="AnimancerPlayable.Play(ITransition)"/>. <para></para> This method also clears the <see cref="State"/> if necessary, so it will re-cast the <see cref="BaseState"/> when it gets accessed again. </remarks> <summary>The <see cref="AnimancerState.MainObject"/> that the created state will have.</summary> <summary>The display name of this transition.</summary> <summary>Returns the <see cref="Name"/> and type of this transition.</summary> <summary>[Editor-Only] Don't use Inspector Gadgets Nested Object Drawers.</summary>
- <summary>[<see cref="ITransitionDetailed"/>] The <see cref="Motion.averageSpeed"/> that the created state will have. </summary> <remarks>The actual average velocity can vary in states like <see cref="MixerState"/>.</remarks> <summary>[<see cref="SerializeField"/>] [<see cref="ITransitionDetailed"/>] Events which will be triggered as the animation plays. </summary> <remarks>This property returns the <see cref="AnimancerEvent.Sequence.Serializable.Sequence"/>.</remarks> <summary>[<see cref="SerializeField"/>] [<see cref="ITransitionDetailed"/>] Events which will be triggered as the animation plays. </summary> <summary> The state that was created by this object. Specifically, this is the state that was most recently passed into <see cref="Apply"/> (usually by <see cref="AnimancerPlayable.Play(ITransition)"/>). <para></para> You can use <see cref="AnimancerPlayable.StateDictionary.GetOrCreate(ITransition)"/> or <see cref="AnimancerLayer.GetOrCreateState(ITransition)"/> to get or create the state for a specific object. <para></para> <see cref="State"/> is simply a shorthand for casting this to <typeparamref name="TState"/>. </summary>
- <summary>[<see cref="SerializeField"/>] [<see cref="ITransitionDetailed"/>] Events which will be triggered as the animation plays. </summary> <remarks>This property returns the <see cref="AnimancerEvent.Sequence.Serializable.Sequence"/>.</remarks> <summary>[<see cref="SerializeField"/>] [<see cref="ITransitionDetailed"/>] Events which will be triggered as the animation plays. </summary> <summary> The state that was created by this object. Specifically, this is the state that was most recently passed into <see cref="Apply"/> (usually by <see cref="AnimancerPlayable.Play(ITransition)"/>). <para></para> You can use <see cref="AnimancerPlayable.StateDictionary.GetOrCreate(ITransition)"/> or <see cref="AnimancerLayer.GetOrCreateState(ITransition)"/> to get or create the state for a specific object. <para></para> <see cref="State"/> is simply a shorthand for casting this to <typeparamref name="TState"/>. </summary>
- <summary>Is the <see cref="Time"/> automatically advancing?</summary> <summary>Has <see cref="_IsPlaying"/> changed since it was last applied to the <see cref="Playable"/>.</summary> <remarks> Playables start playing by default so we start dirty to pause it during the first update (unless <see cref="IsPlaying"/> is set to true before that). </remarks> <summary>Is the <see cref="Time"/> automatically advancing?</summary> <example><code> void IsPlayingExample(AnimancerComponent animancer, AnimationClip clip) { var state = animancer.States.GetOrCreate(clip); if (state.IsPlaying) Debug.Log(clip + " is playing"); else Debug.Log(clip + " is paused"); state.IsPlaying = false;// Pause the animation. state.IsPlaying = true;// Unpause the animation. }
- <summary>[Pro-Only] The <see cref="NormalizedTime"/> after which the <see cref="AnimancerEvent.Sequence.OnEnd"/> callback will be invoked every frame. </summary> <remarks> This is a wrapper around <see cref="AnimancerEvent.Sequence.NormalizedEndTime"/> so that if the value has not been set (<see cref="float.NaN"/>) it can be determined based on the <see cref="AnimancerNode.EffectiveSpeed"/>: positive speed ends at 1 and negative speed ends at 0. <para></para> <em>Animancer Lite does not allow this value to be changed in runtime builds.</em> </remarks>
- <inheritdoc/>
- <summary>Creates and returns a new <typeparamref name="TState"/>.</summary> <remarks> Note that using methods like <see cref="AnimancerPlayable.Play(ITransition)"/> will also call <see cref="Apply"/>, so if you call this method manually you may want to call that method as well. Or you can just use <see cref="AnimancerUtilities.CreateStateAndApply"/>. </remarks> <summary>[<see cref="ITransition"/>] Sets the <see cref="BaseState"/> and applies any other modifications to the `state`. </summary> <remarks> Called by <see cref="AnimancerPlayable.Play(ITransition)"/>. <para></para> This method also clears the <see cref="State"/> if necessary, so it will re-cast the <see cref="BaseState"/> when it gets accessed again. </remarks>
- <summary>[<see cref="SerializeField"/>] [<see cref="ITransitionDetailed"/>] Events which will be triggered as the animation plays. </summary> <summary> The state that was created by this object. Specifically, this is the state that was most recently passed into <see cref="Apply"/> (usually by <see cref="AnimancerPlayable.Play(ITransition)"/>). <para></para> You can use <see cref="AnimancerPlayable.StateDictionary.GetOrCreate(ITransition)"/> or <see cref="AnimancerLayer.GetOrCreateState(ITransition)"/> to get or create the state for a specific object. <para></para> <see cref="State"/> is simply a shorthand for casting this to <typeparamref name="TState"/>. </summary>
- <summary>Creates and returns a new <typeparamref name="TState"/>.</summary> <remarks> Note that using methods like <see cref="AnimancerPlayable.Play(ITransition)"/> will also call <see cref="Apply"/>, so if you call this method manually you may want to call that method as well. Or you can just use <see cref="AnimancerUtilities.CreateStateAndApply"/>. </remarks> <summary>Creates and returns a new <typeparamref name="TState"/>.</summary> <remarks> Note that using methods like <see cref="AnimancerPlayable.Play(ITransition)"/> will also call <see cref="Apply"/>, so if you call this method manually you may want to call that method as well. Or you can just use <see cref="AnimancerUtilities.CreateStateAndApply"/>. </remarks> <summary>[<see cref="ITransition"/>] Sets the <see cref="BaseState"/> and applies any other modifications to the `state`. </summary> <remarks> Called by <see cref="AnimancerPlayable.Play(ITransition)"/>. <para></para> This method also clears the <see cref="State"/> if necessary, so it will re-cast the <see cref="BaseState"/> when it gets accessed again. </remarks>
- <summary> Returns true if the animation is playing and has not yet passed the <see cref="AnimancerEvent.Sequence.endEvent"/>. </summary> <remarks> This method is called by <see cref="IEnumerator.MoveNext"/> so this object can be used as a custom yield instruction to wait until it finishes. </remarks>
- <summary>[<see cref="ITransition"/>] Sets the <see cref="BaseState"/> and applies any other modifications to the `state`. </summary> <remarks> Called by <see cref="AnimancerPlayable.Play(ITransition)"/>. <para></para> This method also clears the <see cref="State"/> if necessary, so it will re-cast the <see cref="BaseState"/> when it gets accessed again. </remarks>
- <summary> Returns true if this state is not playing and is at 0 <see cref="AnimancerNode.Weight"/>. </summary> <summary>Plays this state immediately, without any blending.</summary> <remarks> Sets <see cref="IsPlaying"/> = true, <see cref="AnimancerNode.Weight"/> = 1, and clears the <see cref="Events"/> (unless <see cref="AutomaticallyClearEvents"/> is disabled). <para></para> This method does not change the <see cref="Time"/> so it will continue from its current value. </remarks>
- <summary>[<see cref="ITransitionDetailed"/>] Determines what <see cref="NormalizedTime"/> to start the animation at. Returns <see cref="float.NaN"/> unless overridden. </summary>
- <summary> Updates the <see cref="AnimancerNode.Weight"/> for fading, applies it to this state's port on the parent mixer, and plays or pauses the <see cref="Playable"/> if its state is dirty. </summary> <remarks> If the <see cref="Parent"/>'s <see cref="AnimancerNode.KeepChildrenConnected"/> is set to false, this method will also connect/disconnect this node from the <see cref="Parent"/> in the playable graph. </remarks>
- <summary>Plays this state immediately, without any blending.</summary> <remarks> Sets <see cref="IsPlaying"/> = true, <see cref="AnimancerNode.Weight"/> = 1, and clears the <see cref="Events"/> (unless <see cref="AutomaticallyClearEvents"/> is disabled). <para></para> This method does not change the <see cref="Time"/> so it will continue from its current value. </remarks>
- <summary>The <see cref="AnimancerState.Key"/> which the created state will be registered with.</summary> <remarks>Returns <c>this</c> unless overridden.</remarks> <summary> When a transition is passed into <see cref="AnimancerPlayable.Play(ITransition)"/>, this property determines which <see cref="Animancer.FadeMode"/> will be used. </summary> <summary>Creates and returns a new <typeparamref name="TState"/>.</summary> <remarks> Note that using methods like <see cref="AnimancerPlayable.Play(ITransition)"/> will also call <see cref="Apply"/>, so if you call this method manually you may want to call that method as well. Or you can just use <see cref="AnimancerUtilities.CreateStateAndApply"/>. </remarks> <summary>Creates and returns a new <typeparamref name="TState"/>.</summary> <remarks> Note that using methods like <see cref="AnimancerPlayable.Play(ITransition)"/> will also call <see cref="Apply"/>, so if you call this method manually you may want to call that method as well. Or you can just use <see cref="AnimancerUtilities.CreateStateAndApply"/>. </remarks> <summary>[<see cref="ITransition"/>] Sets the <see cref="BaseState"/> and applies any other modifications to the `state`. </summary> <remarks> Called by <see cref="AnimancerPlayable.Play(ITransition)"/>. <para></para> This method also clears the <see cref="State"/> if necessary, so it will re-cast the <see cref="BaseState"/> when it gets accessed again. </remarks>
- <summary> When a transition is passed into <see cref="AnimancerPlayable.Play(ITransition)"/>, this property determines which <see cref="Animancer.FadeMode"/> will be used. </summary> <summary>Creates and returns a new <typeparamref name="TState"/>.</summary> <remarks> Note that using methods like <see cref="AnimancerPlayable.Play(ITransition)"/> will also call <see cref="Apply"/>, so if you call this method manually you may want to call that method as well. Or you can just use <see cref="AnimancerUtilities.CreateStateAndApply"/>. </remarks> <summary>Creates and returns a new <typeparamref name="TState"/>.</summary> <remarks> Note that using methods like <see cref="AnimancerPlayable.Play(ITransition)"/> will also call <see cref="Apply"/>, so if you call this method manually you may want to call that method as well. Or you can just use <see cref="AnimancerUtilities.CreateStateAndApply"/>. </remarks> <summary>[<see cref="ITransition"/>] Sets the <see cref="BaseState"/> and applies any other modifications to the `state`. </summary> <remarks> Called by <see cref="AnimancerPlayable.Play(ITransition)"/>. <para></para> This method also clears the <see cref="State"/> if necessary, so it will re-cast the <see cref="BaseState"/> when it gets accessed again. </remarks>
- <summary> The index of the <see cref="AnimancerLayer"/> this state is connected to (determined by the <see cref="Parent"/>). </summary>
- <summary> Base class for all states in an <see cref="AnimancerPlayable"/> graph which manages one or more <see cref="Playable"/>s. </summary> <remarks> This class can be used as a custom yield instruction to wait until the animation either stops playing or reaches its end. <para></para> Documentation: <see href="https://kybernetik.com.au/animancer/docs/manual/playing/states">States</see> </remarks> https://kybernetik.com.au/animancer/api/Animancer/AnimancerState <summary>The <see cref="AnimancerPlayable"/> at the root of the graph.</summary> <summary>The object which receives the output of the <see cref="Playable"/>.</summary> <summary>Connects this state to the `parent` mixer at the specified `index`.</summary> <remarks> Use <see cref="AnimancerLayer.AddChild(AnimancerState)"/> instead of this method to connect a state to an available port on a layer. </remarks> <summary>[Internal] Called by <see cref="AnimancerNode.OnAddChild(IList{AnimancerState}, AnimancerState)"/> if the specified port is already occupied so it can be cleared without triggering any other calls. </summary> <summary> The <see cref="AnimancerNode.Weight"/> of this state multiplied by the <see cref="AnimancerNode.Weight"/> of each of its parents down the hierarchy to determine how much this state affects the final output. </summary> <exception cref="NullReferenceException">This state has no <see cref="AnimancerNode.Parent"/>.</exception> <inheritdoc/> <summary> The index of the <see cref="AnimancerLayer"/> this state is connected to (determined by the <see cref="Parent"/>). </summary> <summary> The object used to identify this state in the root <see cref="AnimancerPlayable.States"/> dictionary. Can be null. </summary> <summary>The <see cref="AnimationClip"/> which this state plays (if any).</summary> <exception cref="NotSupportedException">This state type doesn't have a clip and you try to set it.</exception> <summary>The main object to show in the Inspector for this state (if any).</summary> <exception cref="NotSupportedException">This state type doesn't have a main object and you try to set it.</exception> <exception cref="InvalidCastException">This state can't use the assigned value.</exception> <summary> Sets the `currentObject` and calls <see cref="AnimancerNode.RecreatePlayable"/>. If the `currentObject` was being used as the <see cref="Key"/> then it is changed as well. </summary> <exception cref="ArgumentNullException">The `newObject` is null.</exception> <summary>The average velocity of the root motion caused by this state.</summary> <summary>Is the <see cref="Time"/> automatically advancing?</summary> <summary>Has <see cref="_IsPlaying"/> changed since it was last applied to the <see cref="Playable"/>.</summary> <remarks> Playables start playing by default so we start dirty to pause it during the first update (unless <see cref="IsPlaying"/> is set to true before that). </remarks> <summary>Is the <see cref="Time"/> automatically advancing?</summary> <example><code> void IsPlayingExample(AnimancerComponent animancer, AnimationClip clip) { var state = animancer.States.GetOrCreate(clip); if (state.IsPlaying) Debug.Log(clip + " is playing"); else Debug.Log(clip + " is paused"); state.IsPlaying = false;// Pause the animation. state.IsPlaying = true;// Unpause the animation. } </code></example> <summary>Called when the value of <see cref="IsPlaying"/> is changed.</summary> <summary>Creates and assigns the <see cref="Playable"/> managed by this state.</summary> <remarks>This method also applies the <see cref="AnimancerNode.Speed"/> and <see cref="IsPlaying"/>.</remarks> <summary> Returns true if this state is playing and is at or fading towards a non-zero <see cref="AnimancerNode.Weight"/>. </summary> <summary> Returns true if this state is not playing and is at 0 <see cref="AnimancerNode.Weight"/>. </summary> <summary>Plays this state immediately, without any blending.</summary> <remarks> Sets <see cref="IsPlaying"/> = true, <see cref="AnimancerNode.Weight"/> = 1, and clears the <see cref="Events"/> (unless <see cref="AutomaticallyClearEvents"/> is disabled). <para></para> This method does not change the <see cref="Time"/> so it will continue from its current value. </remarks> <summary>Stops the animation and makes it inactive immediately so it no longer affects the output.</summary> <remarks> Sets <see cref="AnimancerNode.Weight"/> = 0, <see cref="IsPlaying"/> = false, <see cref="Time"/> = 0, and clears the <see cref="Events"/> (unless <see cref="AutomaticallyClearEvents"/> is disabled). <para></para> To freeze the animation in place without ending it, you only need to set <see cref="IsPlaying"/> = false instead. Or to freeze all animations, you can call <see cref="AnimancerPlayable.PauseGraph"/>. </remarks> <summary> Called by <see cref="AnimancerNode.StartFade"/>. Clears the <see cref="Events"/> (unless <see cref="AutomaticallyClearEvents"/> is disabled). </summary> <summary> The current time of the <see cref="Playable"/>, retrieved by <see cref="Time"/> whenever the <see cref="_TimeFrameID"/> is different from the <see cref="AnimancerPlayable.FrameID"/>. </summary> <summary> Indicates whether the <see cref="_Time"/> needs to be assigned to the <see cref="Playable"/> next update. </summary> <remarks> <see cref="EventDispatcher"/> executes after all other playables, at which point changes can still be made to their time but not their weight which means that if we set the time immediately then it can be out of sync with the weight. For example, if an animation ends and you play another, the first animation would be stopped and rewinded to the start but would still be at full weight so it would show its first frame before the new animation actually takes effect (even if the previous animation was not looping). <para></para> So instead, we simply delay setting the actual playable time until the next update so that time and weight are always in sync. </remarks> <summary> The <see cref="AnimancerPlayable.FrameID"/> from when the <see cref="Time"/> was last retrieved from the <see cref="Playable"/>. </summary> <summary>The number of seconds that have passed since the start of this animation.</summary> <remarks> This value will continue increasing after the animation passes the end of its <see cref="Length"/> while the animated object either freezes in place or starts again from the beginning according to whether it is looping or not. <para></para> This property internally uses <see cref="RawTime"/> whenever the value is out of date or gets changed. <para></para> <em>Animancer Lite does not allow this value to be changed in runtime builds (except resetting it to 0).</em> </remarks> <example><code> void PlayAnimation(AnimancerComponent animancer, AnimationClip clip) { var state = animancer.Play(clip); // Skip 0.5 seconds into the animation: state.Time = 0.5f; // Skip 50% of the way through the animation (0.5 in a range of 0 to 1): state.NormalizedTime = 0.5f; // Skip to the end of the animation and play backwards. state.NormalizedTime = 1; state.Speed = -1; } </code></example> <summary> The internal implementation of <see cref="Time"/> which directly gets and sets the underlying value. </summary> <remarks> Setting this value actually calls <see cref="PlayableExtensions.SetTime"/> twice to ensure that animation events aren't triggered incorrectly. Calling it only once would trigger any animation events between the previous time and the new time. So if an animation plays to the end and you set the time back to 0 (such as by calling <see cref="Stop"/> or playing a different animation), the next time that animation played it would immediately trigger all of its events, then play through and trigger them normally as well. </remarks> <summary> The <see cref="Time"/> of this state as a portion of the animation's <see cref="Length"/>, meaning the value goes from 0 to 1 as it plays from start to end, regardless of how long that actually takes. </summary> <remarks> This value will continue increasing after the animation passes the end of its <see cref="Length"/> while the animated object either freezes in place or starts again from the beginning according to whether it is looping or not. <para></para> The fractional part of the value (<c>NormalizedTime % 1</c>) is the percentage (0-1) of progress in the current loop while the integer part (<c>(int)NormalizedTime</c>) is the number of times the animation has been looped. <para></para> <em>Animancer Lite does not allow this value to be changed to a value other than 0 in runtime builds.</em> </remarks> <example><code> void PlayAnimation(AnimancerComponent animancer, AnimationClip clip) { var state = animancer.Play(clip); // Skip 0.5 seconds into the animation: state.Time = 0.5f; // Skip 50% of the way through the animation (0.5 in a range of 0 to 1): state.NormalizedTime = 0.5f; // Skip to the end of the animation and play backwards. state.NormalizedTime = 1; state.Speed = -1; } </code></example> <summary>Prevents the <see cref="RawTime"/> from being applied.</summary> <summary>[Pro-Only] The <see cref="NormalizedTime"/> after which the <see cref="AnimancerEvent.Sequence.OnEnd"/> callback will be invoked every frame. </summary> <remarks> This is a wrapper around <see cref="AnimancerEvent.Sequence.NormalizedEndTime"/> so that if the value has not been set (<see cref="float.NaN"/>) it can be determined based on the <see cref="AnimancerNode.EffectiveSpeed"/>: positive speed ends at 1 and negative speed ends at 0. <para></para> <em>Animancer Lite does not allow this value to be changed in runtime builds.</em> </remarks> <summary> The number of seconds the animation will take to play fully at its current <see cref="AnimancerNode.EffectiveSpeed"/>. </summary> <remarks> For the time remaining from now until it reaches the end, use <see cref="RemainingDuration"/> instead. <para></para> Setting this value modifies the <see cref="AnimancerNode.EffectiveSpeed"/>, not the <see cref="Length"/>. <para></para> <em>Animancer Lite does not allow this value to be changed in runtime builds.</em> </remarks> <example><code> void PlayAnimation(AnimancerComponent animancer, AnimationClip clip) { var state = animancer.Play(clip); state.Duration = 1;// Play fully in 1 second. state.Duration = 2;// Play fully in 2 seconds. state.Duration = 0.5f;// Play fully in half a second. state.Duration = -1;// Play backwards fully in 1 second. state.NormalizedTime = 1; state.Duration = -1;// Play backwards from the end in 1 second. } </code></example> <summary> The number of seconds this state will take to go from its current <see cref="NormalizedTime"/> to the <see cref="NormalizedEndTime"/> at its current <see cref="AnimancerNode.EffectiveSpeed"/>. </summary> <remarks> For the time it would take to play fully from the start, use the <see cref="Duration"/> instead. <para></para> Setting this value modifies the <see cref="AnimancerNode.EffectiveSpeed"/>, not the <see cref="Length"/>. <para></para> <em>Animancer Lite does not allow this value to be changed in runtime builds.</em> </remarks> <example><code> void PlayAnimation(AnimancerComponent animancer, AnimationClip clip) { var state = animancer.Play(clip); state.RemainingDuration = 1;// Play from the current time to the end in 1 second. state.RemainingDuration = 2;// Play from the current time to the end in 2 seconds. state.RemainingDuration = 0.5f;// Play from the current time to the end in half a second. state.RemainingDuration = -1;// Play from the current time away from the end. } </code></example> <summary>The total time this state would take to play in seconds when <see cref="AnimancerNode.Speed"/> = 1.</summary> <summary>Will this state loop back to the start when it reaches the end?</summary> <summary> Updates the <see cref="AnimancerNode.Weight"/> for fading, applies it to this state's port on the parent mixer, and plays or pauses the <see cref="Playable"/> if its state is dirty. </summary> <remarks> If the <see cref="Parent"/>'s <see cref="AnimancerNode.KeepChildrenConnected"/> is set to false, this method will also connect/disconnect this node from the <see cref="Parent"/> in the playable graph. </remarks> <summary>Destroys the <see cref="Playable"/> and cleans up this state.</summary> <remarks> This method is NOT called automatically, so when implementing a custom state type you must use <see cref="AnimancerPlayable.Disposables"/> if you need to guarantee that things will get cleaned up. </remarks> <summary>[<see cref="IAnimationClipCollection"/>] Gathers all the animations in this state.</summary> <summary> Returns true if the animation is playing and has not yet passed the <see cref="AnimancerEvent.Sequence.endEvent"/>. </summary> <remarks> This method is called by <see cref="IEnumerator.MoveNext"/> so this object can be used as a custom yield instruction to wait until it finishes. </remarks> <summary> Returns the <see cref="AnimancerNode.DebugName"/> if one is set, otherwise a string describing the type of this state and the name of the <see cref="MainObject"/>. </summary> <summary>[Editor-Only] Returns a custom drawer for this state.</summary> <inheritdoc/> <summary>Returns the hierarchy path of this state through its <see cref="Parent"/>s.</summary> <summary>Appends the hierarchy path of this state through its <see cref="Parent"/>s.</summary> <summary>Appends "[Index] -> GetType().Name".</summary> <summary> Base class for serializable <see cref="ITransition"/>s which can create a particular type of <see cref="AnimancerState"/> when passed into <see cref="AnimancerPlayable.Play(ITransition)"/>. </summary> <remarks> Unfortunately the tool used to generate this documentation does not currently support nested types with identical names, so only one <c>Transition</c> class will actually have a documentation page. <para></para> Even though it has the <see cref="SerializableAttribute"/>, this class won't actually get serialized by Unity because it's generic and abstract. Each child class still needs to include the attribute. <para></para> Documentation: <see href="https://kybernetik.com.au/animancer/docs/manual/transitions">Transitions</see> </remarks> https://kybernetik.com.au/animancer/api/Animancer/Transition_1 <summary>[<see cref="SerializeField"/>] The amount of time the transition will take (in seconds).</summary> <exception cref="ArgumentOutOfRangeException">Thrown when setting the value to a negative number.</exception> <summary>[<see cref="ITransitionDetailed"/>] Indicates what the value of <see cref="AnimancerState.IsLooping"/> will be for the created state. Returns false unless overridden. </summary> <summary>[<see cref="ITransitionDetailed"/>] Determines what <see cref="NormalizedTime"/> to start the animation at. Returns <see cref="float.NaN"/> unless overridden. </summary> <summary>[<see cref="ITransitionDetailed"/>] Determines how fast the animation plays (1x = normal speed). Returns 1 unless overridden. </summary> <summary>[<see cref="ITransitionDetailed"/>] The maximum amount of time the animation is expected to take (in seconds). </summary> <remarks>The actual duration can vary in states like <see cref="MixerState"/>.</remarks> <summary>[<see cref="ITransitionDetailed"/>] The <see cref="Motion.averageAngularSpeed"/> that the created state will have. </summary> <remarks>The actual average velocity can vary in states like <see cref="MixerState"/>.</remarks> <summary>[<see cref="ITransitionDetailed"/>] The <see cref="Motion.averageSpeed"/> that the created state will have. </summary> <remarks>The actual average velocity can vary in states like <see cref="MixerState"/>.</remarks> <summary>[<see cref="SerializeField"/>] [<see cref="ITransitionDetailed"/>] Events which will be triggered as the animation plays. </summary> <remarks>This property returns the <see cref="AnimancerEvent.Sequence.Serializable.Sequence"/>.</remarks> <summary>[<see cref="SerializeField"/>] [<see cref="ITransitionDetailed"/>] Events which will be triggered as the animation plays. </summary> <summary> The state that was created by this object. Specifically, this is the state that was most recently passed into <see cref="Apply"/> (usually by <see cref="AnimancerPlayable.Play(ITransition)"/>). <para></para> You can use <see cref="AnimancerPlayable.StateDictionary.GetOrCreate(ITransition)"/> or <see cref="AnimancerLayer.GetOrCreateState(ITransition)"/> to get or create the state for a specific object. <para></para> <see cref="State"/> is simply a shorthand for casting this to <typeparamref name="TState"/>. </summary> <summary> The state that was created by this object. Specifically, this is the state that was most recently passed into <see cref="Apply"/> (usually by <see cref="AnimancerPlayable.Play(ITransition)"/>). </summary> <remarks> You can use <see cref="AnimancerPlayable.StateDictionary.GetOrCreate(ITransition)"/> or <see cref="AnimancerLayer.GetOrCreateState(ITransition)"/> to get or create the state for a specific object. <para></para> This property is shorthand for casting the <see cref="BaseState"/> to <typeparamref name="TState"/>. </remarks> <exception cref="InvalidCastException"> The <see cref="BaseState"/> is not actually a <typeparamref name="TState"/>. This should only happen if a different type of state was created by something else and registered using the <see cref="Key"/>, causing this <see cref="AnimancerPlayable.Play(ITransition)"/> to pass that state into <see cref="Apply"/> instead of calling <see cref="CreateState"/> to make the correct type of state. </exception> <summary>Indicates whether this transition can create a valid <see cref="AnimancerState"/>.</summary> <summary>The <see cref="AnimancerState.Key"/> which the created state will be registered with.</summary> <remarks>Returns <c>this</c> unless overridden.</remarks> <summary> When a transition is passed into <see cref="AnimancerPlayable.Play(ITransition)"/>, this property determines which <see cref="Animancer.FadeMode"/> will be used. </summary> <summary>Creates and returns a new <typeparamref name="TState"/>.</summary> <remarks> Note that using methods like <see cref="AnimancerPlayable.Play(ITransition)"/> will also call <see cref="Apply"/>, so if you call this method manually you may want to call that method as well. Or you can just use <see cref="AnimancerUtilities.CreateStateAndApply"/>. </remarks> <summary>Creates and returns a new <typeparamref name="TState"/>.</summary> <remarks> Note that using methods like <see cref="AnimancerPlayable.Play(ITransition)"/> will also call <see cref="Apply"/>, so if you call this method manually you may want to call that method as well. Or you can just use <see cref="AnimancerUtilities.CreateStateAndApply"/>. </remarks> <summary>[<see cref="ITransition"/>] Sets the <see cref="BaseState"/> and applies any other modifications to the `state`. </summary> <remarks> Called by <see cref="AnimancerPlayable.Play(ITransition)"/>. <para></para> This method also clears the <see cref="State"/> if necessary, so it will re-cast the <see cref="BaseState"/> when it gets accessed again. </remarks> <summary>The <see cref="AnimancerState.MainObject"/> that the created state will have.</summary> <summary>The display name of this transition.</summary> <summary>Returns the <see cref="Name"/> and type of this transition.</summary> <summary>[Editor-Only] Don't use Inspector Gadgets Nested Object Drawers.</summary>
- <summary>Connects this state to the `parent` mixer at the specified `index`.</summary> <remarks> Use <see cref="AnimancerLayer.AddChild(AnimancerState)"/> instead of this method to connect a state to an available port on a layer. </remarks>
- <summary> The state that was created by this object. Specifically, this is the state that was most recently passed into <see cref="Apply"/> (usually by <see cref="AnimancerPlayable.Play(ITransition)"/>). <para></para> You can use <see cref="AnimancerPlayable.StateDictionary.GetOrCreate(ITransition)"/> or <see cref="AnimancerLayer.GetOrCreateState(ITransition)"/> to get or create the state for a specific object. <para></para> <see cref="State"/> is simply a shorthand for casting this to <typeparamref name="TState"/>. </summary>
- <summary>[<see cref="SerializeField"/>] The amount of time the transition will take (in seconds).</summary> <exception cref="ArgumentOutOfRangeException">Thrown when setting the value to a negative number.</exception> <summary>[<see cref="ITransitionDetailed"/>] Indicates what the value of <see cref="AnimancerState.IsLooping"/> will be for the created state. Returns false unless overridden. </summary> <summary>[<see cref="ITransitionDetailed"/>] Determines what <see cref="NormalizedTime"/> to start the animation at. Returns <see cref="float.NaN"/> unless overridden. </summary> <summary>[<see cref="ITransitionDetailed"/>] Determines how fast the animation plays (1x = normal speed). Returns 1 unless overridden. </summary> <summary>[<see cref="ITransitionDetailed"/>] The maximum amount of time the animation is expected to take (in seconds). </summary> <remarks>The actual duration can vary in states like <see cref="MixerState"/>.</remarks> <summary>[<see cref="ITransitionDetailed"/>] The <see cref="Motion.averageAngularSpeed"/> that the created state will have. </summary> <remarks>The actual average velocity can vary in states like <see cref="MixerState"/>.</remarks> <summary>[<see cref="ITransitionDetailed"/>] The <see cref="Motion.averageSpeed"/> that the created state will have. </summary> <remarks>The actual average velocity can vary in states like <see cref="MixerState"/>.</remarks> <summary>[<see cref="SerializeField"/>] [<see cref="ITransitionDetailed"/>] Events which will be triggered as the animation plays. </summary> <remarks>This property returns the <see cref="AnimancerEvent.Sequence.Serializable.Sequence"/>.</remarks> <summary>[<see cref="SerializeField"/>] [<see cref="ITransitionDetailed"/>] Events which will be triggered as the animation plays. </summary> <summary> The state that was created by this object. Specifically, this is the state that was most recently passed into <see cref="Apply"/> (usually by <see cref="AnimancerPlayable.Play(ITransition)"/>). <para></para> You can use <see cref="AnimancerPlayable.StateDictionary.GetOrCreate(ITransition)"/> or <see cref="AnimancerLayer.GetOrCreateState(ITransition)"/> to get or create the state for a specific object. <para></para> <see cref="State"/> is simply a shorthand for casting this to <typeparamref name="TState"/>. </summary> <summary> The state that was created by this object. Specifically, this is the state that was most recently passed into <see cref="Apply"/> (usually by <see cref="AnimancerPlayable.Play(ITransition)"/>). </summary> <remarks> You can use <see cref="AnimancerPlayable.StateDictionary.GetOrCreate(ITransition)"/> or <see cref="AnimancerLayer.GetOrCreateState(ITransition)"/> to get or create the state for a specific object. <para></para> This property is shorthand for casting the <see cref="BaseState"/> to <typeparamref name="TState"/>. </remarks> <exception cref="InvalidCastException"> The <see cref="BaseState"/> is not actually a <typeparamref name="TState"/>. This should only happen if a different type of state was created by something else and registered using the <see cref="Key"/>, causing this <see cref="AnimancerPlayable.Play(ITransition)"/> to pass that state into <see cref="Apply"/> instead of calling <see cref="CreateState"/> to make the correct type of state. </exception> <summary>Indicates whether this transition can create a valid <see cref="AnimancerState"/>.</summary> <summary>The <see cref="AnimancerState.Key"/> which the created state will be registered with.</summary> <remarks>Returns <c>this</c> unless overridden.</remarks> <summary> When a transition is passed into <see cref="AnimancerPlayable.Play(ITransition)"/>, this property determines which <see cref="Animancer.FadeMode"/> will be used. </summary> <summary>Creates and returns a new <typeparamref name="TState"/>.</summary> <remarks> Note that using methods like <see cref="AnimancerPlayable.Play(ITransition)"/> will also call <see cref="Apply"/>, so if you call this method manually you may want to call that method as well. Or you can just use <see cref="AnimancerUtilities.CreateStateAndApply"/>. </remarks> <summary>Creates and returns a new <typeparamref name="TState"/>.</summary> <remarks> Note that using methods like <see cref="AnimancerPlayable.Play(ITransition)"/> will also call <see cref="Apply"/>, so if you call this method manually you may want to call that method as well. Or you can just use <see cref="AnimancerUtilities.CreateStateAndApply"/>. </remarks> <summary>[<see cref="ITransition"/>] Sets the <see cref="BaseState"/> and applies any other modifications to the `state`. </summary> <remarks> Called by <see cref="AnimancerPlayable.Play(ITransition)"/>. <para></para> This method also clears the <see cref="State"/> if necessary, so it will re-cast the <see cref="BaseState"/> when it gets accessed again. </remarks> <summary>The <see cref="AnimancerState.MainObject"/> that the created state will have.</summary> <summary>The display name of this transition.</summary> <summary>Returns the <see cref="Name"/> and type of this transition.</summary> <summary>[Editor-Only] Don't use Inspector Gadgets Nested Object Drawers.</summary>
- <summary>[<see cref="SerializeField"/>] [<see cref="ITransitionDetailed"/>] Events which will be triggered as the animation plays. </summary> <remarks>This property returns the <see cref="AnimancerEvent.Sequence.Serializable.Sequence"/>.</remarks> <summary>[<see cref="SerializeField"/>] [<see cref="ITransitionDetailed"/>] Events which will be triggered as the animation plays. </summary> <summary> The state that was created by this object. Specifically, this is the state that was most recently passed into <see cref="Apply"/> (usually by <see cref="AnimancerPlayable.Play(ITransition)"/>). <para></para> You can use <see cref="AnimancerPlayable.StateDictionary.GetOrCreate(ITransition)"/> or <see cref="AnimancerLayer.GetOrCreateState(ITransition)"/> to get or create the state for a specific object. <para></para> <see cref="State"/> is simply a shorthand for casting this to <typeparamref name="TState"/>. </summary>
- <summary>[<see cref="SerializeField"/>] The amount of time the transition will take (in seconds).</summary> <exception cref="ArgumentOutOfRangeException">Thrown when setting the value to a negative number.</exception>
- <summary>Has <see cref="_IsPlaying"/> changed since it was last applied to the <see cref="Playable"/>.</summary> <remarks> Playables start playing by default so we start dirty to pause it during the first update (unless <see cref="IsPlaying"/> is set to true before that). </remarks> <summary>Is the <see cref="Time"/> automatically advancing?</summary> <example><code> void IsPlayingExample(AnimancerComponent animancer, AnimationClip clip) { var state = animancer.States.GetOrCreate(clip); if (state.IsPlaying) Debug.Log(clip + " is playing"); else Debug.Log(clip + " is paused"); state.IsPlaying = false;// Pause the animation. state.IsPlaying = true;// Unpause the animation. }
- <summary>Is the <see cref="Time"/> automatically advancing?</summary> <example><code> void IsPlayingExample(AnimancerComponent animancer, AnimationClip clip) { var state = animancer.States.GetOrCreate(clip); if (state.IsPlaying) Debug.Log(clip + " is playing"); else Debug.Log(clip + " is paused"); state.IsPlaying = false;// Pause the animation. state.IsPlaying = true;// Unpause the animation. }
- <summary> The object used to identify this state in the root <see cref="AnimancerPlayable.States"/> dictionary. Can be null. </summary>
- <summary> The <see cref="AnimancerPlayable.FrameID"/> from when the <see cref="Time"/> was last retrieved from the <see cref="Playable"/>. </summary> <summary>The number of seconds that have passed since the start of this animation.</summary> <remarks> This value will continue increasing after the animation passes the end of its <see cref="Length"/> while the animated object either freezes in place or starts again from the beginning according to whether it is looping or not. <para></para> This property internally uses <see cref="RawTime"/> whenever the value is out of date or gets changed. <para></para> <em>Animancer Lite does not allow this value to be changed in runtime builds (except resetting it to 0).</em> </remarks> <example><code> void PlayAnimation(AnimancerComponent animancer, AnimationClip clip) { var state = animancer.Play(clip); // Skip 0.5 seconds into the animation: state.Time = 0.5f; // Skip 50% of the way through the animation (0.5 in a range of 0 to 1): state.NormalizedTime = 0.5f; // Skip to the end of the animation and play backwards. state.NormalizedTime = 1; state.Speed = -1; }
- <summary>Connects this state to the `parent` mixer at the specified `index`.</summary> <remarks> Use <see cref="AnimancerLayer.AddChild(AnimancerState)"/> instead of this method to connect a state to an available port on a layer. </remarks>
- <summary> The state that was created by this object. Specifically, this is the state that was most recently passed into <see cref="Apply"/> (usually by <see cref="AnimancerPlayable.Play(ITransition)"/>). </summary> <remarks> You can use <see cref="AnimancerPlayable.StateDictionary.GetOrCreate(ITransition)"/> or <see cref="AnimancerLayer.GetOrCreateState(ITransition)"/> to get or create the state for a specific object. <para></para> This property is shorthand for casting the <see cref="BaseState"/> to <typeparamref name="TState"/>. </remarks> <exception cref="InvalidCastException"> The <see cref="BaseState"/> is not actually a <typeparamref name="TState"/>. This should only happen if a different type of state was created by something else and registered using the <see cref="Key"/>, causing this <see cref="AnimancerPlayable.Play(ITransition)"/> to pass that state into <see cref="Apply"/> instead of calling <see cref="CreateState"/> to make the correct type of state. </exception>
- <summary> Indicates whether the <see cref="_Time"/> needs to be assigned to the <see cref="Playable"/> next update. </summary> <remarks> <see cref="EventDispatcher"/> executes after all other playables, at which point changes can still be made to their time but not their weight which means that if we set the time immediately then it can be out of sync with the weight. For example, if an animation ends and you play another, the first animation would be stopped and rewinded to the start but would still be at full weight so it would show its first frame before the new animation actually takes effect (even if the previous animation was not looping). <para></para> So instead, we simply delay setting the actual playable time until the next update so that time and weight are always in sync. </remarks> <summary> The <see cref="AnimancerPlayable.FrameID"/> from when the <see cref="Time"/> was last retrieved from the <see cref="Playable"/>. </summary> <summary>The number of seconds that have passed since the start of this animation.</summary> <remarks> This value will continue increasing after the animation passes the end of its <see cref="Length"/> while the animated object either freezes in place or starts again from the beginning according to whether it is looping or not. <para></para> This property internally uses <see cref="RawTime"/> whenever the value is out of date or gets changed. <para></para> <em>Animancer Lite does not allow this value to be changed in runtime builds (except resetting it to 0).</em> </remarks> <example><code> void PlayAnimation(AnimancerComponent animancer, AnimationClip clip) { var state = animancer.Play(clip); // Skip 0.5 seconds into the animation: state.Time = 0.5f; // Skip 50% of the way through the animation (0.5 in a range of 0 to 1): state.NormalizedTime = 0.5f; // Skip to the end of the animation and play backwards. state.NormalizedTime = 1; state.Speed = -1; }
- <summary>The number of seconds that have passed since the start of this animation.</summary> <remarks> This value will continue increasing after the animation passes the end of its <see cref="Length"/> while the animated object either freezes in place or starts again from the beginning according to whether it is looping or not. <para></para> This property internally uses <see cref="RawTime"/> whenever the value is out of date or gets changed. <para></para> <em>Animancer Lite does not allow this value to be changed in runtime builds (except resetting it to 0).</em> </remarks> <example><code> void PlayAnimation(AnimancerComponent animancer, AnimationClip clip) { var state = animancer.Play(clip); // Skip 0.5 seconds into the animation: state.Time = 0.5f; // Skip 50% of the way through the animation (0.5 in a range of 0 to 1): state.NormalizedTime = 0.5f; // Skip to the end of the animation and play backwards. state.NormalizedTime = 1; state.Speed = -1; }
2024-12-17 11:11:47,664 - INFO Retriever 0 - 

————————————————————————————————————————————————————————————————
2024-12-17 11:11:47,664 - INFO Retriever 0 - 当前窗口总长度：47
2024-12-17 11:11:47,664 - INFO Retriever 0 - 当前更新窗口长度：38
2024-12-17 11:11:47,666 - INFO Retriever 0 - 当前更新窗口长度：38
2024-12-17 11:11:47,667 - INFO Retriever 0 - ————————————————————————————————————————————————————————————————


2024-12-17 11:12:13,689 - INFO Retriever 0 - Agent主脑给出的回答为：{
  "根据文件内容概述": "AnimancerState.cs 脚本定义了一个名为 `AnimancerState` 的抽象类，用于管理动画播放状态的基类。该类继承自 `AnimancerNode` 并实现了 `IAnimationClipCollection` 接口。虽然该脚本没有直接涉及动画控制，但了解动画状态管理机制对于分析如何修改动画状态以实现固定战斗动画是有帮助的。接下来，我将读取其他可能与问题描述相关的文件，以便进一步分析。"
}
2024-12-17 11:12:13,690 - INFO Retriever 0 - 是否成功解析：True
2024-12-17 11:12:13,690 - INFO Retriever 0 - operation_type (__det_dir_action):
2024-12-17 11:12:13,691 - INFO Retriever 0 - 根据文件内容概述
2024-12-17 11:12:13,691 - INFO Retriever 0 - 

——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
2024-12-17 11:12:13,691 - INFO Retriever 0 - Assistant:
2024-12-17 11:12:13,691 - INFO Retriever 0 - {
  "根据文件内容概述": "AnimancerState.cs 脚本定义了一个名为 `AnimancerState` 的抽象类，用于管理动画播放状态的基类。该类继承自 `AnimancerNode` 并实现了 `IAnimationClipCollection` 接口。虽然该脚本没有直接涉及动画控制，但了解动画状态管理机制对于分析如何修改动画状态以实现固定战斗动画是有帮助的。接下来，我将读取其他可能与问题描述相关的文件，以便进一步分析。"
}
2024-12-17 11:12:13,692 - INFO Retriever 0 - dict_keys(['根据文件内容概述'])
2024-12-17 11:12:13,692 - WARNING Retriever 0 - 你给出的操作类型不属于指定的操作类型。可以进行的操作类型有：['get_folder_info', 'read_file', 'read_long_details', 'retrieve_keywords', 'deep_think']，请重新给出你的操作。
2024-12-17 11:12:13,696 - INFO Retriever 0 - 

————————————————————————————————————————————————————————————————
2024-12-17 11:12:13,696 - INFO Retriever 0 - 当前窗口总长度：49
2024-12-17 11:12:13,696 - INFO Retriever 0 - 当前更新窗口长度：40
2024-12-17 11:12:13,696 - INFO Retriever 0 - 当前更新窗口长度：40
2024-12-17 11:12:13,697 - INFO Retriever 0 - -- updated_window_size >= self._compress_window_size --
2024-12-17 11:12:13,697 - INFO Retriever 0 - 进行窗口压缩
2024-12-17 11:12:48,539 - INFO Retriever 0 - window report:
* 文件一：
    * 文件绝对路径：D:\Unity\jyx2\Assets\Scripts\GameSave\RoleInstance.cs
    * 文件内容概述：该脚本定义了`RoleInstance`类，用于管理游戏中的角色实例，涵盖属性、技能、装备和战斗状态。类中方法包括初始化、属性调整、技能学习、装备使用、战斗准备和状态更新等。
    * 是否与问题相关：相关
    * 具体分析：该脚本负责管理角色实例，包括属性、技能、装备和战斗状态。虽然直接修改该脚本可能无法直接实现固定战斗动画，但了解角色实例的属性和技能管理机制有助于进一步分析其他相关脚本。

* 文件二：
    * 文件绝对路径：D:\Unity\jyx2\Assets\LuaScripts\Jyx2Battle\AIManager.lua
    * 文件内容概述：该脚本是金庸群侠传3D重制版游戏的Lua战斗AI模块，负责角色AI逻辑。模块初始化和反初始化，更新角色位置，并通过`GetAIResult`函数决策角色行动，如移动、攻击或休息。
    * 是否与问题相关：相关
    * 具体分析：该脚本负责角色AI逻辑，包括决策角色行动，如移动、攻击或休息。了解角色AI的逻辑有助于分析如何修改角色行动以实现固定战斗动画。

* 文件三：
    * 文件绝对路径：D:\Unity\jyx2\Assets\3rd\Animancer\Internal\Core\AnimancerState.cs
    * 文件内容概述：该脚本定义了`AnimancerState`类，作为动画状态管理的基类，它继承自`AnimancerNode`并实现`IAnimationClipCollection`接口。主要功能包括动画的播放控制、时间管理以及与动画图（Graph）的交互。
    * 是否与问题相关：相关
    * 具体分析：该脚本负责动画状态管理，包括动画的播放控制、时间管理以及与动画图（Graph）的交互。了解动画状态管理机制有助于分析如何修改动画状态以实现固定战斗动画。

* 文件四：
    * 文件绝对路径：D:\Unity\jyx2\Assets\Mods\JYX2\Skills\降龙十八掌.asset
    * 文件内容概述：该文件为Unity游戏中的“降龙十八掌”技能脚本，详细配置了动画（包括攻击、移动、闲置和受击动画）、特效（粒子效果及其参数）和音效（攻击和防御时的音效及其播放延迟）。
    * 是否与问题相关：相关
    * 具体分析：该文件详细配置了“降龙十八掌”技能的动画、特效和音效，了解该技能的配置有助于分析如何修改其他技能的配置以实现固定战斗动画。

* 文件五：
    * 文件绝对路径：D:\Unity\jyx2\Assets\LuaScripts\Jyx2Battle\BattleInit.lua
    * 文件内容概述：该Lua脚本“BattleInit.lua”是金庸群侠传3D重制版战斗模块的初始化脚本。脚本中定义了技能覆盖类型常量，并通过`jy_utils.prequire`加载了伤害计算器、范围逻辑、AI管理和战斗管理器等模块，以供战斗逻辑使用。
    * 是否与问题相关：相关
    * 具体分析：该脚本负责战斗模块的初始化，加载了伤害计算器、范围逻辑、AI管理和战斗管理器等模块。了解战斗模块的初始化过程有助于分析如何修改相关模块以实现固定战斗动画。
2024-12-17 11:12:48,541 - INFO Retriever 0 - 





——————————————————————————————Log compressed history list—————————————————————————————————
2024-12-17 11:12:48,542 - INFO Retriever 0 - ——————————————————————————————————————————order 1————————————————————————————————————————————




2024-12-17 11:12:48,542 - INFO Retriever 0 - user:
请在D:/Unity/jyx2\Assets下各级目录中寻找：我想指定某个角色的所有战斗动画为固定的,而不是跟随技能招式变化应该修改哪个脚本
2024-12-17 11:12:48,542 - INFO Retriever 0 - assistant:
{
    "deep_think": {
        "thoughts": "好的，接下来我将通过深度思考、仔细计划以及逐步执行的方式，来完成该任务。\n\n首先，在阅读详细的代码细节之前，应该先整体把握整个项目。\n\n在提供的可选的action中，可以通过get_folder_info操作，通过将项目顶层路径作为target_folder_path参数进行传入，来获取获取项目中主要文件夹和主要文件的描述，从而能够先大致把握项目文件的主要文件的文件树结构、基本内容、主要代码概述以及大致功能板块的分布。"
    }
}
2024-12-17 11:12:48,542 - INFO Retriever 0 - user:
好的，请继续你的下一步行动或思考。
2024-12-17 11:12:48,543 - INFO Retriever 0 - assistant:
{
    "get_folder_info": {
        "target_folder_path": "D:/Unity/jyx2\\Assets"
    }
}
2024-12-17 11:12:48,543 - INFO Retriever 0 - user:
目标文件夹路径：D:/Unity/jyx2\Assets
文件结构树（该结构树可能不完整，仅返回深度小于等于1层的子文件以及文件夹）：
├── 3D
│   ├── Animal pack deluxe
│   ...
│   ├── juese2
├── 3DScene
│   ├── Animation
│   ├── COMMUNITY_LICENSE_FOR_JYX2.md
│   ...
│   ├── timg.jpg
├── 3rd
│   ├── AmplifyShaderEditor
│   ├── Animancer
│   ...
│   ├── xNode-1.8.0
├── BuildSource
│   ├── AnimationControllers
│   ├── Animations
│   ...
│   ├── sound
├── Easy Save 3
│   ├── Types
├── Editor
│   ├── .DS_Store
│   ├── AddScenesToBuild.cs
│   ...
│   ├── ToolbarExtender
├── Gizmos
├── IFix
│   ├── Editor
├── Jyx2Tools
├── Jyx2UI
│   ├── Res
│   ├── gameicon1.png
│   ...
│   ├── theend.png
├── LuaScripts
│   ├── InitLuaScripts.lua
│   ├── Jyx2Battle
│   ...
│   ├── testLua.lua
├── Mods
│   ├── .gitignore
│   ├── JYX2
│   ├── README.txt
│   ├── SAMPLE
│   ├── xiastart_roguelike
├── Plugins
│   ├── 3rd
│   ├── Android
│   ...
│   ├── xlua.bundle
├── Prefabs
│   ├── BattleRole.prefab
│   ├── BattleboxBlock.prefab
│   ...
│   ├── StorySelectionItem.prefab
├── Resources
│   ├── ABMD5.txt
│   ├── BattleboxBlock.prefab
│   ...
│   ├── icon.jpg
├── Scripts
│   ├── AudioManager.cs
│   ├── BattleBlockData.cs
│   ...
│   ├── VCamManage
├── StaticBakeObj.shader
├── StreamingAssets
│   ├── build_info
├── TapTap
├── TapTapSlogan.png
├── Terrain
│   ├── Terrain Mat.mat
│   ├── Terrain_0_0-20210221-192230.asset
│   ├── Terrain_Copy.asset
├── Terrain2Mesh
│   ├── NewMeshTerrain2
│   ├── NewMeshTerrain3
│   ...
│   ├── Terrain_LOD_2.obj
├── VFX
│   ├── DragonVFX
│   ├── EffectsPackage
│   ├── Hovl Studio
│   ├── JMO Assets
│   ├── Jyx2Effect
│   ├── Toon_Explosion_V1
│   ├── UNAUTH_ASSETS_FOR_JYX2.md
├── XLua
│   ├── CHANGELOG.txt
│   ├── Doc
│   ...
│   ├── util
├── _TerrainAutoUpgrade
│   ├── layer_119f68b03b8b7e8e.terrainlayer
│   ├── layer_793646612c42751.terrainlayer
│   ...
│   ├── layer_stone3d3aba195e4d26ee.terrainlayer
├── csc.rsp
├── icon.jpg
├── link.xml
├── mcs.rsp


其中，部分主要文件及文件夹的信息如下：
1. 3D
# 路径:D:/Unity/jyx2/Assets\3D
# 内容概述:### 文件夹内容概要

“COMMUNITY_LICENSE_FOR_JYX2.md”文件是金庸群侠传3D重制版项目的授权声明，明确指出文件夹内所有内容受特定社区素材协议保护，并要求用户查阅相关协议以了解使用规则，强调未经授权不得使用。

2. 3DScene
# 路径:D:/Unity/jyx2/Assets\3DScene
# 内容概述:在“3DScene”文件夹中，包含了多种动画和控制脚本文件，如“camera.anim”和“Main Camera (1).controller”，用于定义摄像机运动。此外，存在版权声明文件“COMMUNITY_LICENSE_FOR_JYX2.md”，保护了金庸群侠传3D重制版项目的素材使用。图像文件“map.jpg”和“timg.jpg”可能作为视觉参考，而“New Material 1.mat”和“New Material.mat”则是Unity材质文件，用于定义物体外观。

3. 3rd
# 路径:D:/Unity/jyx2/Assets\3rd
# 内容概述:“UNAUTH_ASSETS_FOR_JYX2.md”文件声明，放置该文件目录及其子目录中的素材未经授权，并提醒用户遵守版权规范。此声明与金庸群侠传3D重制版项目无关，如对素材有异议，请与项目方联系。

4. BuildSource
# 路径:D:/Unity/jyx2/Assets\BuildSource
# 内容概述:“BuildSource”文件夹汇集了金庸群侠传3D重制版项目的核心资源，包括动画控制器和动作资源、事件图和Lua脚本、游戏控制器和用户界面设计、角色与武器模型、音乐与音效等。这些资源相互关联，共同支撑起游戏的整体架构，从动画到交互，从视觉到听觉，确保了游戏体验的丰富性和连贯性。此外，文件夹中还包含了必要的文档和授权声明，确保了项目资源的合法使用和标准遵循。

5. Easy Save 3
# 路径:D:/Unity/jyx2/Assets\Easy Save 3
# 内容概述:### 总体概述
“Easy Save 3”文件夹汇集了Unity游戏开发中用于数据持久化的C#脚本，专注于角色、技能和地图等游戏对象的序列化与反序列化，确保游戏数据在保存与加载过程中的稳定性和一致性。

### 目录结构
文件夹内包含针对角色物品、游戏运行数据、角色实例、技能实例、子地图和世界地图数据序列化的脚本。

### 内容关联
这些脚本通过继承通用序列化类，共同构成了一个数据序列化系统，确保不同游戏数据结构在保存和加载过程中的正确转换。

6. Editor
# 路径:D:/Unity/jyx2/Assets\Editor
# 内容概述:### 文件夹内容总结

“Editor”文件夹汇集了Unity编辑器扩展工具，旨在提升开发效率。它包含动画配置工具、贴图格式检查、构建自动化、热更新配置、资源引用查找、工具栏扩展、场景切换、烘培节点控制、纹理格式转换等子文件夹和脚本。这些工具如AnimationTools、AssetToolkits、BuildTools等，通过增强编辑器功能，简化了动画处理、资源管理和构建流程，同时提供了如热修复配置、资源引用查找等特定工具，以优化开发体验。

7. Gizmos
# 路径:D:/Unity/jyx2/Assets\Gizmos
# 内容概述:该文件夹内容为空。

8. IFix
# 路径:D:/Unity/jyx2/Assets\IFix
# 内容概述:“IFix”文件夹汇集了Unity编辑器脚本，专注于实现热补丁注入与资源备份，通过`Configure.cs`定义配置属性和方法，`ILFixEditor.cs`则作为编辑器扩展，利用这些配置来管理热补丁和资源，从而提升游戏开发和维护的效率。

9. Jyx2Tools
# 路径:D:/Unity/jyx2/Assets\Jyx2Tools
# 内容概述:Jyx2Tools文件夹是一个综合性的工具集文件夹，主要包含用于不同目的的工具文件和资源。其目录结构清晰，包括多个子文件和子文件夹，如“add git 指定类型文件夹”提供Git版本控制相关工具，“RTMPose关键点检测-安装MMDetection和MMPose-总结”涉及计算机视觉算法的安装与使用指南，“文言文内容分析概括题”课件则针对文言文学习提供教学材料，“construction worker safety dataset (cws)”则是一个用于AI风险评估的数据集。这些文件和子文件夹相互关联，共同构成了一个支持多种应用场景的工具和资源集合。

10. Jyx2UI
# 路径:D:/Unity/jyx2/Assets\Jyx2UI
# 内容概述:### 总体概述
“Jyx2UI”文件夹汇集了游戏或软件UI设计的视觉资源，包括装饰贴图、纹理图像以及一系列图标，如游戏图标、主菜单和结束画面等，旨在增强界面美观和用户体验。

### 目录结构
- **Decal文件夹**：存储游戏装饰和标识的贴图及预制体，如不同颜色和形状的装饰元素。
- **Textures文件夹**：包含用于界面背景和环境的颜色块纹理图像。
- **新增文件**：包括游戏图标、主菜单、结束画面等图标文件，用于界面关键元素和提示。

### 内容关联
文件夹内文件共同服务于游戏或软件的界面设计，其中“Decal”和“Textures”提供装饰和纹理，而新增图标文件则丰富了UI元素，确保了视觉元素的协调一致。

11. LuaScripts
# 路径:D:/Unity/jyx2/Assets\LuaScripts
# 内容概述:该Lua脚本执行了简单的数学运算和打印输出。变量`mm`被赋值为`-4`，随后`uu`和`pp`分别通过取反和减法运算得到`4`。脚本还打印了`uu`的值`4`，一个介于0和0.5之间的随机数（实际输出为`0`），以及字符串`"test end"`。

12. Mods
# 路径:D:/Unity/jyx2/Assets\Mods
# 内容概述:### 文件夹内容总结

“Mods”文件夹汇集了多个游戏开发资源，包括更新日志、配置文件、地图、模型、预制体、脚本和Mod设置等。主要子文件夹如“JYX2”包含游戏资源与更新记录，“SAMPLE”提供动画、配置和脚本资源，“xiastart_roguelike”则聚焦于“roguelike武侠战斗”的游戏开发资源。此外，存在Git忽略文件和README.txt，分别用于版本控制和MOD编辑指导。这些资源相互关联，共同支持游戏开发流程。

13. Plugins
# 路径:D:/Unity/jyx2/Assets\Plugins
# 内容概述:“Plugins”文件夹汇集了Unity游戏开发所需的多样化工具和插件，包括日志报告工具、Android应用开发资源、辅助开发组件、图像处理和动画库、数据管理插件、后处理效果插件、Excel支持库、Steamworks集成、iOS开发工具、UI组件资源包、响应式编程库、异步任务管理工具、WebGL交互接口、Lua脚本支持库等。这些资源覆盖了从设计到发布的各个阶段，旨在提升开发效率和游戏质量。

14. Prefabs
# 路径:D:/Unity/jyx2/Assets\Prefabs
# 内容概述:### 总体概述：
“Prefabs”文件夹汇集了游戏开发所需的各种预制体资源，包括角色、场景元素、用户界面和控制组件，旨在支持游戏场景的构建和交互设计。

### 目录结构：
文件夹内包含多种预制体，如**BattleboxBlock**、**BattleRole**、**DialogPanel**等，涵盖了角色、UI、灯光和导航指针等元素。

### 内容关联：
这些预制体相互关联，共同构成了游戏的核心元素，从角色和场景到用户界面和交互控制，为游戏开发提供了全面的资源支持。

15. Resources
# 路径:D:/Unity/jyx2/Assets\Resources
# 内容概述:### 文本分析员AI

#### 文本文件内容总结

该“RewiredInputManager”文件是Unity3D预制体配置，定义了Rewired输入管理器的设置和映射。它包含预制体基本信息，如名称和版本，以及详细的输入管理器配置，包括输入轴、按钮和摇杆等，以及针对不同玩家ID和控制器的输入映射。此文件便于Unity3D开发者集成Rewired，以实现复杂的输入处理。

16. Scripts
# 路径:D:/Unity/jyx2/Assets\Scripts
# 内容概述:“Scripts”文件夹汇集了Unity游戏开发的核心脚本，涵盖战斗管理、地图交互、角色控制、UI开发、资源管理和编辑器工具。其中，战斗系统涉及战斗区域设置、战斗逻辑与角色控制；地图交互和导航则通过角色移动、地图宝箱和地点名称显示实现；玩家输入与UI交互通过角色选择、物品管理和UI导航脚本处理；资源管理和工具函数则支持游戏资源的加载与辅助功能实现。此外，编辑器插件、控制台命令、日志记录、技能播放、游戏设置等关键功能也在此文件夹中得到了体现。

17. StreamingAssets
# 路径:D:/Unity/jyx2/Assets\StreamingAssets
# 内容概述:“StreamingAssets”文件夹主要存放流媒体资源，其中包含一个名为“build_info”的文件，可能记录构建配置信息。

18. TapTap
# 路径:D:/Unity/jyx2/Assets\TapTap
# 内容概述:该文件夹内容为空。

19. Terrain
# 路径:D:/Unity/jyx2/Assets\Terrain
# 内容概述:“Terrain”文件夹汇集了与地形处理相关的文件，包括Terrain Mat.mat可能的地形材质数据，以及两个遭遇解码错误的资产文件Terrain_0_0-20210221-192230.asset和Terrain_Copy.asset，后者可能为前者的副本。这些文件关联紧密，均涉及地形数据的处理，但存在编码问题。

20. Terrain2Mesh
# 路径:D:/Unity/jyx2/Assets\Terrain2Mesh
# 内容概述:## 文件夹内容总结

“Terrain2Mesh”文件夹汇集了多个与3D地形模型相关的文件，旨在支持游戏开发与3D动画项目。包含地形模型的基本几何数据（如NewMeshTerrain2.obj和Terrain2Mesh.obj），配置文件（如NewMeshTerrain2.prefab和Terrain2Mesh.prefab），以及用于优化渲染性能的LOD（Level of Detail）模型（如TerrainLOD.FBX）。此外，还有纹理贴图（如SplatAlpha 0.png）和材质文件（如Terrain2Mesh.mat），共同构成了一个完整的地形模型资源集。

21. VFX
# 路径:D:/Unity/jyx2/Assets\VFX
# 内容概述:“VFX”文件夹汇集了多种游戏和动画制作资源，包括3D模型、动画、特效和预制体。其中，“DragonVFX”提供黑色龙的详细模型与动画，“Hovl Studio”和“JMO Assets”分别包含动画、游戏开发与视觉效果资源，而“Jyx2Effect”和“Toon_Explosion_V1”则专注于特定效果的资源包。此外，文件夹中还包含版权声明文件，如“UNAUTH_ASSETS_FOR_JYX2.md”，提醒用户注意授权和使用规范。

22. XLua
# 路径:D:/Unity/jyx2/Assets\XLua
# 内容概述:“XLua”文件夹是Unity游戏开发者的宝贵资源库，集成了xLua框架的文档、配置、示例代码和工具类。其中，文档详细介绍了xLua的配置和使用方法；编辑器文件夹提供了Unity编辑器相关的配置资源；示例文件夹则通过实际案例展示了xLua在Unity项目中的应用；生成文件夹包含用于生成Lua代码的工具；资源文件夹汇集了性能分析、内存管理和TDR库交互的Lua脚本；核心资源库提供了Unity项目开发所需的脚本和工具；教程文件夹则提供了xLua在Unity中使用的教学示例；加密工具文件夹实现了XXTEA加密算法；更新日志文件则记录了xLua库的版本更新和改进。这些内容相互关联，共同构成了一个全面、实用的xLua开发资源集合。

23. _TerrainAutoUpgrade
# 路径:D:/Unity/jyx2/Assets\_TerrainAutoUpgrade
# 内容概述:该文件夹“_TerrainAutoUpgrade”内含多个地形层文件，用于游戏或模拟环境的地形数据更新。文件包括不同地形元素如草地、泥土、山和石头，以及特定纹理和示例层，旨在创建或升级地形环境。

24. 0_GameStart.unity
# 路径:D:/Unity/jyx2/Assets\0_GameStart.unity
# 内容概述:这是一个名为“0_GameStart.unity”的文件。

25. 0_Init.unity
# 路径:D:/Unity/jyx2/Assets\0_Init.unity
# 内容概述:这是一个名为“0_Init.unity”的文件。

26. 0_MainMenu.unity
# 路径:D:/Unity/jyx2/Assets\0_MainMenu.unity
# 内容概述:这是一个名为“0_MainMenu.unity”的文件。

27. 0_MODLoaderScene.unity
# 路径:D:/Unity/jyx2/Assets\0_MODLoaderScene.unity
# 内容概述:这是一个名为“0_MODLoaderScene.unity”的文件。

28. csc.rsp
# 路径:D:/Unity/jyx2/Assets\csc.rsp
# 内容概述:这是一个名为“csc.rsp”的文件。

29. icon.jpg
# 路径:D:/Unity/jyx2/Assets\icon.jpg
# 内容概述:这是一个名为“icon.jpg”的文件。

30. link.xml
# 路径:D:/Unity/jyx2/Assets\link.xml
# 内容概述:这是一个名为“link.xml”的文件。

31. mcs.rsp
# 路径:D:/Unity/jyx2/Assets\mcs.rsp
# 内容概述:这是一个名为“mcs.rsp”的文件。

32. StaticBakeObj.shader
# 路径:D:/Unity/jyx2/Assets\StaticBakeObj.shader
# 内容概述:该Shader文件“StaticBakeObj.shader”为Unity引擎中的自定义材质着色器，主要功能包括定义一系列视觉属性如轮廓颜色、宽度、发射纹理等，并在SubShader模块中实现渲染逻辑。它通过顶点处理和表面处理计算，结合Perlin噪声生成复杂纹理效果，支持轮廓、发光和溶解等视觉效果的渲染。


33. TapTapSlogan.png
# 路径:D:/Unity/jyx2/Assets\TapTapSlogan.png
# 内容概述:这是一个名为“TapTapSlogan.png”的文件。


2024-12-17 11:12:48,545 - INFO Retriever 0 - assistant:
{
    "deep_think": {
        "thoughts": "在获取了项目文件的顶层结构后，我还需要结合待查询的问题描述，对于项目中的文件和目录进行一些深度关键词检索。根据任务描述：“请在D:/Unity/jyx2\\Assets下各级目录中寻找：我想指定某个角色的所有战斗动画为固定的,而不是跟随技能招式变化应该修改哪个脚本”，我总结出如下可能会出现在各个文件名或者文件内容中的关键词：“['Battle animation', '技能招式', 'skill move', '技能', 'role', 'stuck', 'skill', 'fixed', '动画', '角色', 'animation', 'move', 'talent', 'Combat animation', '战斗', '招式', 'battle', '固定', '战斗动画', 'warfare', 'character']”，“['Battle animation', '技能招式', 'skill move', '技能', 'role', 'stuck', 'combat', 'skill', 'fixed', '动画', '角色', 'animation', 'move', 'talent', 'Combat animation', '战斗', '招式', 'battle', '固定', '战斗动画', 'character']”，“['combat animation', '技能招式', 'skill move', '技能', 'role', 'stuck', 'skill', 'fixed', '动画', '角色', 'animation', 'move', 'battle animation', 'talent', '战斗', '招式', 'battle', '固定', '战斗动画', 'warfare', 'character']”。\n接下来，我将使用retrieve_keywords操作，在项目顶层路径“D:/Unity/jyx2\\Assets”下检索这些关键词，从而大致把握可能与问题描述相关的文件或目录的路径。"
    }
}
2024-12-17 11:12:48,546 - INFO Retriever 0 - user:
好的，请继续你的下一步行动或思考。
2024-12-17 11:12:48,546 - INFO Retriever 0 - assistant:
{
    "retrieve_keywords": {
        "keyword_list": [
            [
                "Battle animation",
                "技能招式",
                "skill move",
                "技能",
                "role",
                "stuck",
                "skill",
                "fixed",
                "动画",
                "角色",
                "animation",
                "move",
                "talent",
                "Combat animation",
                "战斗",
                "招式",
                "battle",
                "固定",
                "战斗动画",
                "warfare",
                "character"
            ],
            [
                "Battle animation",
                "技能招式",
                "skill move",
                "技能",
                "role",
                "stuck",
                "combat",
                "skill",
                "fixed",
                "动画",
                "角色",
                "animation",
                "move",
                "talent",
                "Combat animation",
                "战斗",
                "招式",
                "battle",
                "固定",
                "战斗动画",
                "character"
            ],
            [
                "combat animation",
                "技能招式",
                "skill move",
                "技能",
                "role",
                "stuck",
                "skill",
                "fixed",
                "动画",
                "角色",
                "animation",
                "move",
                "battle animation",
                "talent",
                "战斗",
                "招式",
                "battle",
                "固定",
                "战斗动画",
                "warfare",
                "character"
            ]
        ]
    }
}
2024-12-17 11:12:48,547 - INFO Retriever 0 - user:
* 文件一：
    * 文件绝对路径：D:\Unity\jyx2\Assets\Scripts\GameSave\RoleInstance.cs
    * 文件内容概述：该脚本定义了`RoleInstance`类，用于管理游戏中的角色实例，涵盖属性、技能、装备和战斗状态。类中方法包括初始化、属性调整、技能学习、装备使用、战斗准备和状态更新等。角色属性如等级、攻击力、防御力等通过`InitData`和`AddAttr`等方法管理，技能和装备通过`GetSkillsList`和`AddItem`等方法操作。战斗状态通过`EnterBattle`和`LeaveBattle`等方法控制，同时处理晕眩、复活和休息等状态变化。
    * 是否与问题相关：相关
    * 具体分析：该脚本负责管理角色实例，包括属性、技能、装备和战斗状态。虽然直接修改该脚本可能无法直接实现固定战斗动画，但了解角色实例的属性和技能管理机制有助于进一步分析其他相关脚本。

* 文件二：
    * 文件绝对路径：D:\Unity\jyx2\Assets\LuaScripts\Jyx2Battle\AIManager.lua
    * 文件内容概述：该脚本是金庸群侠传3D重制版游戏的Lua战斗AI模块，负责角色AI逻辑。模块初始化和反初始化，更新角色位置，并通过`GetAIResult`函数决策角色行动，如移动、攻击或休息。核心功能包括物品和技能管理，以及与敌人交互的策略计算。
    * 是否与问题相关：相关
    * 具体分析：该脚本负责角色AI逻辑，包括决策角色行动，如移动、攻击或休息。了解角色AI的逻辑有助于分析如何修改角色行动以实现固定战斗动画。

* 文件三：
    * 文件绝对路径：D:\Unity\jyx2\Assets\3rd\Animancer\Internal\Core\AnimancerState.cs
    * 文件内容概述：该脚本定义了`AnimancerState`类，作为动画状态管理的基类，它继承自`AnimancerNode`并实现`IAnimationClipCollection`接口。主要功能包括动画的播放控制、时间管理以及与动画图（Graph）的交互。类中实现了设置根节点、父节点、播放、停止动画，以及获取和设置动画时间等核心方法，支持动画的精确控制。此外，还定义了`Transition<TState>`类用于创建和管理特定类型的动画状态转换。
    * 是否与问题相关：相关
    * 具体分析：该脚本负责动画状态管理，包括动画的播放控制、时间管理以及与动画图（Graph）的交互。了解动画状态管理机制有助于分析如何修改动画状态以实现固定战斗动画。

* 文件四：
    * 文件绝对路径：D:\Unity\jyx2\Assets\Mods\JYX2\Skills\降龙十八掌.asset
    * 文件内容概述：该文件为Unity游戏中的“降龙十八掌”技能脚本，详细配置了动画（包括攻击、移动、闲置和受击动画）、特效（粒子效果及其参数）和音效（攻击和防御时的音效及其播放延迟）。此外，还设置了控制器和鬼影效果等属性。
    * 是否与问题相关：相关
    * 具体分析：该文件详细配置了“降龙十八掌”技能的动画、特效和音效，了解该技能的配置有助于分析如何修改其他技能的配置以实现固定战斗动画。

* 文件五：
    * 文件绝对路径：D:\Unity\jyx2\Assets\LuaScripts\Jyx2Battle\BattleInit.lua
    * 文件内容概述：该Lua脚本“BattleInit.lua”是金庸群侠传3D重制版战斗模块的初始化脚本。脚本中定义了技能覆盖类型常量，并通过`jy_utils.prequire`加载了伤害计算器、范围逻辑、AI管理和战斗管理器等模块，以供战斗逻辑使用。这些模块和常量被封装在`battle`表中，便于后续在游戏中调用。
    * 是否与问题相关：相关
    * 具体分析：该脚本负责战斗模块的初始化，加载了伤害计算器、范围逻辑、AI管理和战斗管理器等模块。了解战斗模块的初始化过程有助于分析如何修改相关模块以实现固定战斗动画。
2024-12-17 11:12:48,547 - INFO Retriever 0 - assistant:
好的。在我进行下一步行动或思考前，我又回顾了一下，以下是之前已经遍历过的文件信息：

* 文件一：
    * 文件绝对路径：D:\Unity\jyx2\Assets\Scripts\GameSave\RoleInstance.cs
    * 文件内容概述：该脚本定义了`RoleInstance`类，用于管理游戏中的角色实例，涵盖属性、技能、装备和战斗状态。类中方法包括初始化、属性调整、技能学习、装备使用、战斗准备和状态更新等。
    * 是否与问题相关：相关
    * 具体分析：该脚本负责管理角色实例，包括属性、技能、装备和战斗状态。虽然直接修改该脚本可能无法直接实现固定战斗动画，但了解角色实例的属性和技能管理机制有助于进一步分析其他相关脚本。

* 文件二：
    * 文件绝对路径：D:\Unity\jyx2\Assets\LuaScripts\Jyx2Battle\AIManager.lua
    * 文件内容概述：该脚本是金庸群侠传3D重制版游戏的Lua战斗AI模块，负责角色AI逻辑。模块初始化和反初始化，更新角色位置，并通过`GetAIResult`函数决策角色行动，如移动、攻击或休息。
    * 是否与问题相关：相关
    * 具体分析：该脚本负责角色AI逻辑，包括决策角色行动，如移动、攻击或休息。了解角色AI的逻辑有助于分析如何修改角色行动以实现固定战斗动画。

* 文件三：
    * 文件绝对路径：D:\Unity\jyx2\Assets\3rd\Animancer\Internal\Core\AnimancerState.cs
    * 文件内容概述：该脚本定义了`AnimancerState`类，作为动画状态管理的基类，它继承自`AnimancerNode`并实现`IAnimationClipCollection`接口。主要功能包括动画的播放控制、时间管理以及与动画图（Graph）的交互。
    * 是否与问题相关：相关
    * 具体分析：该脚本负责动画状态管理，包括动画的播放控制、时间管理以及与动画图（Graph）的交互。了解动画状态管理机制有助于分析如何修改动画状态以实现固定战斗动画。

* 文件四：
    * 文件绝对路径：D:\Unity\jyx2\Assets\Mods\JYX2\Skills\降龙十八掌.asset
    * 文件内容概述：该文件为Unity游戏中的“降龙十八掌”技能脚本，详细配置了动画（包括攻击、移动、闲置和受击动画）、特效（粒子效果及其参数）和音效（攻击和防御时的音效及其播放延迟）。
    * 是否与问题相关：相关
    * 具体分析：该文件详细配置了“降龙十八掌”技能的动画、特效和音效，了解该技能的配置有助于分析如何修改其他技能的配置以实现固定战斗动画。

* 文件五：
    * 文件绝对路径：D:\Unity\jyx2\Assets\LuaScripts\Jyx2Battle\BattleInit.lua
    * 文件内容概述：该Lua脚本“BattleInit.lua”是金庸群侠传3D重制版战斗模块的初始化脚本。脚本中定义了技能覆盖类型常量，并通过`jy_utils.prequire`加载了伤害计算器、范围逻辑、AI管理和战斗管理器等模块，以供战斗逻辑使用。
    * 是否与问题相关：相关
    * 具体分析：该脚本负责战斗模块的初始化，加载了伤害计算器、范围逻辑、AI管理和战斗管理器等模块。了解战斗模块的初始化过程有助于分析如何修改相关模块以实现固定战斗动画。

以上是我回顾的之前已经遍历过的文件信息。接下来，我将基于上述的进度，继续进行任务。
2024-12-17 11:12:48,548 - INFO Retriever 0 - user:
好的，请继续你的下一步行动或思考。
2024-12-17 11:12:48,548 - INFO Retriever 0 - 

——————————————————————————————————————————————————————————————————————————————————————————
2024-12-17 11:12:48,548 - INFO Retriever 0 - ——————————————————————————————————————————————————————————————————————————————————————————
2024-12-17 11:12:48,548 - INFO Retriever 0 - ————————————————————————————————————————————————————————————————


2024-12-17 11:13:00,158 - INFO Retriever 0 - Agent主脑给出的回答为：{
    "deep_think": {
        "thoughts": "根据之前检索到的文件信息，我注意到文件三（AnimancerState.cs）似乎与动画状态管理直接相关，这可能是实现固定战斗动画的关键。接下来，我将使用read_file操作，读取文件三的内容，以获取更详细的动画状态管理信息。"
    }
}
2024-12-17 11:13:00,159 - INFO Retriever 0 - 是否成功解析：True
2024-12-17 11:13:00,159 - INFO Retriever 0 - operation_type (__det_dir_action):
2024-12-17 11:13:00,159 - INFO Retriever 0 - deep_think
2024-12-17 11:13:00,159 - INFO Retriever 0 - 

——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
2024-12-17 11:13:00,160 - INFO Retriever 0 - Assistant:
2024-12-17 11:13:00,160 - INFO Retriever 0 - {
    "deep_think": {
        "thoughts": "根据之前检索到的文件信息，我注意到文件三（AnimancerState.cs）似乎与动画状态管理直接相关，这可能是实现固定战斗动画的关键。接下来，我将使用read_file操作，读取文件三的内容，以获取更详细的动画状态管理信息。"
    }
}
2024-12-17 11:13:00,160 - INFO Retriever 0 - dict_keys(['deep_think'])
2024-12-17 11:13:00,160 - INFO Retriever 0 - Agent主脑给出的行动：deep_think
参数：{'thoughts': '根据之前检索到的文件信息，我注意到文件三（AnimancerState.cs）似乎与动画状态管理直接相关，这可能是实现固定战斗动画的关键。接下来，我将使用read_file操作，读取文件三的内容，以获取更详细的动画状态管理信息。', 'repeat_counter': 1, 'continue_think_counter': 1}
2024-12-17 11:13:00,161 - INFO Retriever 0 - Observer: 好的，请继续你的下一步行动或思考。
2024-12-17 11:13:00,162 - INFO Retriever 0 - 

————————————————————————————————————————————————————————————————
2024-12-17 11:13:00,162 - INFO Retriever 0 - 当前窗口总长度：13
2024-12-17 11:13:00,162 - INFO Retriever 0 - 当前更新窗口长度：4
2024-12-17 11:13:00,163 - INFO Retriever 0 - 当前更新窗口长度：4
2024-12-17 11:13:00,163 - INFO Retriever 0 - ————————————————————————————————————————————————————————————————


2024-12-17 11:13:03,479 - INFO Retriever 0 - Agent主脑给出的回答为：{
    "read_file": {
        "file_path": "D:/Unity/jyx2\\Assets\\3rd\\Animancer\\Internal\\Core\\AnimancerState.cs"
    }
}
2024-12-17 11:13:03,479 - INFO Retriever 0 - 是否成功解析：True
2024-12-17 11:13:03,480 - INFO Retriever 0 - operation_type (__det_dir_action):
2024-12-17 11:13:03,480 - INFO Retriever 0 - read_file
2024-12-17 11:13:03,480 - INFO Retriever 0 - 

——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
2024-12-17 11:13:03,480 - INFO Retriever 0 - Assistant:
2024-12-17 11:13:03,481 - INFO Retriever 0 - {
    "read_file": {
        "file_path": "D:/Unity/jyx2\\Assets\\3rd\\Animancer\\Internal\\Core\\AnimancerState.cs"
    }
}
2024-12-17 11:13:03,481 - INFO Retriever 0 - dict_keys(['read_file'])
2024-12-17 11:13:03,481 - INFO Retriever 0 - Agent主脑给出的行动：read_file
参数：{'file_path': 'D:/Unity/jyx2\\Assets\\3rd\\Animancer\\Internal\\Core\\AnimancerState.cs', 'top_path': 'D:/Unity/jyx2\\Assets', 'return_file_sum': <bound method TreeGenerationAction.return_file_sum of <Action.tree_gen_action.TreeGenerationAction object at 0x0000027D71AB0D90>>}
2024-12-17 11:13:03,510 - INFO Retriever 0 - Observer: 这是一个名为“AnimancerState.cs”的文件，该文件里的内容为：
由于脚本文件内容过长，暂时仅给出该脚本文件的内容总结:
- ### 总体概述
- **框架和模块化结构**：该脚本定义了一个名为 `AnimancerState` 的抽象类，它是用于管理动画播放状态的基类。该类继承自 `AnimancerNode` 并实现了 `IAnimationClipCollection` 接口。
- **主要功能和目标**：该脚本的主要目标是提供一个框架，用于在 `AnimancerPlayable` 图中管理一个或多个 `Playable` 对象，以控制动画的播放、暂停、停止和淡入淡出。

### 模块和功能
- **Graph 模块**：管理 `AnimancerPlayable` 图中的节点和连接。
- **Key and Clip 模块**：处理与动画剪辑相关的键和剪辑对象。
- **Playing 模块**：控制动画的播放、暂停和停止。
- **Timing 模块**：处理动画的时间控制和持续时间。
- **Methods 模块**：包含用于更新、销毁和收集动画剪辑的方法。

### 类和函数
- **类**：
  - `AnimancerState`：管理动画状态的基类。
  - `Transition<TState>`：用于创建特定类型 `AnimancerState` 的可序列化转换基类。
- **函数**：
  - `SetRoot`：设置动画图根节点。
  - `SetParent`：设置动画状态的父节点。
  - `Play`：立即播放动画。
  - `Stop`：停止动画。
  - `Time`：获取或设置动画的当前时间。
  - `Duration`：获取或设置动画的持续时间。

### 实现逻辑
- `AnimancerState` 类通过继承 `AnimancerNode` 和实现 `IAnimationClipCollection` 接口，提供了管理动画状态所需的基本功能。
- 通过 `SetRoot` 和 `SetParent` 方法，可以构建和管理动画图。
- `Play` 和 `Stop` 方法控制动画的播放状态。
- `Time` 和 `Duration` 属性允许精确控制动画的时间进度和持续时间。
在这个脚本中存在如下的一些函数：Animancer、AnimancerState、AppendDetails、AppendPath、AppendPortAndType、Apply、AverageAngularSpeed、AverageVelocity、AverageVelocity、BaseState、CancelSetTime、ClearParent、Clip、CreateDrawer、CreatePlayable、CreateState、Destroy、Duration、EffectiveWeight、Events、FadeDuration、FadeMode、GatherAnimationClips、GetPath、ITransition.CreateState、IsActive、IsLooping、IsLooping、IsPlaying、IsPlayingAndNotEnding、IsStopped、IsValid、Key、Key、Layer、LayerIndex、Length、MainObject、MainObject、MaximumDuration、Name、NestedObjectDrawers、NormalizedEndTime、NormalizedStartTime、NormalizedTime、Object、Object、OnSetIsPlaying、OnStartFade、Parent、Play、RawTime、RemainingDuration、SerializedEvents、SetParent、SetRoot、Speed、State、Stop、Time、ToString、ToString、Transition、Update、_Events、_FadeDuration、_IsPlaying、_IsPlayingDirty、_Key、_MustSetTime、_Parent、_State、_Time、_TimeFrameID
这些函数有以下详细信息：
- <summary> Base class for all states in an <see cref="AnimancerPlayable"/> graph which manages one or more <see cref="Playable"/>s. </summary> <remarks> This class can be used as a custom yield instruction to wait until the animation either stops playing or reaches its end. <para></para> Documentation: <see href="https://kybernetik.com.au/animancer/docs/manual/playing/states">States</see> </remarks> https://kybernetik.com.au/animancer/api/Animancer/AnimancerState <summary>The <see cref="AnimancerPlayable"/> at the root of the graph.</summary> <summary>The object which receives the output of the <see cref="Playable"/>.</summary> <summary>Connects this state to the `parent` mixer at the specified `index`.</summary> <remarks> Use <see cref="AnimancerLayer.AddChild(AnimancerState)"/> instead of this method to connect a state to an available port on a layer. </remarks> <summary>[Internal] Called by <see cref="AnimancerNode.OnAddChild(IList{AnimancerState}, AnimancerState)"/> if the specified port is already occupied so it can be cleared without triggering any other calls. </summary> <summary> The <see cref="AnimancerNode.Weight"/> of this state multiplied by the <see cref="AnimancerNode.Weight"/> of each of its parents down the hierarchy to determine how much this state affects the final output. </summary> <exception cref="NullReferenceException">This state has no <see cref="AnimancerNode.Parent"/>.</exception> <inheritdoc/> <summary> The index of the <see cref="AnimancerLayer"/> this state is connected to (determined by the <see cref="Parent"/>). </summary> <summary> The object used to identify this state in the root <see cref="AnimancerPlayable.States"/> dictionary. Can be null. </summary> <summary>The <see cref="AnimationClip"/> which this state plays (if any).</summary> <exception cref="NotSupportedException">This state type doesn't have a clip and you try to set it.</exception> <summary>The main object to show in the Inspector for this state (if any).</summary> <exception cref="NotSupportedException">This state type doesn't have a main object and you try to set it.</exception> <exception cref="InvalidCastException">This state can't use the assigned value.</exception> <summary> Sets the `currentObject` and calls <see cref="AnimancerNode.RecreatePlayable"/>. If the `currentObject` was being used as the <see cref="Key"/> then it is changed as well. </summary> <exception cref="ArgumentNullException">The `newObject` is null.</exception> <summary>The average velocity of the root motion caused by this state.</summary> <summary>Is the <see cref="Time"/> automatically advancing?</summary> <summary>Has <see cref="_IsPlaying"/> changed since it was last applied to the <see cref="Playable"/>.</summary> <remarks> Playables start playing by default so we start dirty to pause it during the first update (unless <see cref="IsPlaying"/> is set to true before that). </remarks> <summary>Is the <see cref="Time"/> automatically advancing?</summary> <example><code> void IsPlayingExample(AnimancerComponent animancer, AnimationClip clip) { var state = animancer.States.GetOrCreate(clip); if (state.IsPlaying) Debug.Log(clip + " is playing"); else Debug.Log(clip + " is paused"); state.IsPlaying = false;// Pause the animation. state.IsPlaying = true;// Unpause the animation. } </code></example> <summary>Called when the value of <see cref="IsPlaying"/> is changed.</summary> <summary>Creates and assigns the <see cref="Playable"/> managed by this state.</summary> <remarks>This method also applies the <see cref="AnimancerNode.Speed"/> and <see cref="IsPlaying"/>.</remarks> <summary> Returns true if this state is playing and is at or fading towards a non-zero <see cref="AnimancerNode.Weight"/>. </summary> <summary> Returns true if this state is not playing and is at 0 <see cref="AnimancerNode.Weight"/>. </summary> <summary>Plays this state immediately, without any blending.</summary> <remarks> Sets <see cref="IsPlaying"/> = true, <see cref="AnimancerNode.Weight"/> = 1, and clears the <see cref="Events"/> (unless <see cref="AutomaticallyClearEvents"/> is disabled). <para></para> This method does not change the <see cref="Time"/> so it will continue from its current value. </remarks> <summary>Stops the animation and makes it inactive immediately so it no longer affects the output.</summary> <remarks> Sets <see cref="AnimancerNode.Weight"/> = 0, <see cref="IsPlaying"/> = false, <see cref="Time"/> = 0, and clears the <see cref="Events"/> (unless <see cref="AutomaticallyClearEvents"/> is disabled). <para></para> To freeze the animation in place without ending it, you only need to set <see cref="IsPlaying"/> = false instead. Or to freeze all animations, you can call <see cref="AnimancerPlayable.PauseGraph"/>. </remarks> <summary> Called by <see cref="AnimancerNode.StartFade"/>. Clears the <see cref="Events"/> (unless <see cref="AutomaticallyClearEvents"/> is disabled). </summary> <summary> The current time of the <see cref="Playable"/>, retrieved by <see cref="Time"/> whenever the <see cref="_TimeFrameID"/> is different from the <see cref="AnimancerPlayable.FrameID"/>. </summary> <summary> Indicates whether the <see cref="_Time"/> needs to be assigned to the <see cref="Playable"/> next update. </summary> <remarks> <see cref="EventDispatcher"/> executes after all other playables, at which point changes can still be made to their time but not their weight which means that if we set the time immediately then it can be out of sync with the weight. For example, if an animation ends and you play another, the first animation would be stopped and rewinded to the start but would still be at full weight so it would show its first frame before the new animation actually takes effect (even if the previous animation was not looping). <para></para> So instead, we simply delay setting the actual playable time until the next update so that time and weight are always in sync. </remarks> <summary> The <see cref="AnimancerPlayable.FrameID"/> from when the <see cref="Time"/> was last retrieved from the <see cref="Playable"/>. </summary> <summary>The number of seconds that have passed since the start of this animation.</summary> <remarks> This value will continue increasing after the animation passes the end of its <see cref="Length"/> while the animated object either freezes in place or starts again from the beginning according to whether it is looping or not. <para></para> This property internally uses <see cref="RawTime"/> whenever the value is out of date or gets changed. <para></para> <em>Animancer Lite does not allow this value to be changed in runtime builds (except resetting it to 0).</em> </remarks> <example><code> void PlayAnimation(AnimancerComponent animancer, AnimationClip clip) { var state = animancer.Play(clip); // Skip 0.5 seconds into the animation: state.Time = 0.5f; // Skip 50% of the way through the animation (0.5 in a range of 0 to 1): state.NormalizedTime = 0.5f; // Skip to the end of the animation and play backwards. state.NormalizedTime = 1; state.Speed = -1; } </code></example> <summary> The internal implementation of <see cref="Time"/> which directly gets and sets the underlying value. </summary> <remarks> Setting this value actually calls <see cref="PlayableExtensions.SetTime"/> twice to ensure that animation events aren't triggered incorrectly. Calling it only once would trigger any animation events between the previous time and the new time. So if an animation plays to the end and you set the time back to 0 (such as by calling <see cref="Stop"/> or playing a different animation), the next time that animation played it would immediately trigger all of its events, then play through and trigger them normally as well. </remarks> <summary> The <see cref="Time"/> of this state as a portion of the animation's <see cref="Length"/>, meaning the value goes from 0 to 1 as it plays from start to end, regardless of how long that actually takes. </summary> <remarks> This value will continue increasing after the animation passes the end of its <see cref="Length"/> while the animated object either freezes in place or starts again from the beginning according to whether it is looping or not. <para></para> The fractional part of the value (<c>NormalizedTime % 1</c>) is the percentage (0-1) of progress in the current loop while the integer part (<c>(int)NormalizedTime</c>) is the number of times the animation has been looped. <para></para> <em>Animancer Lite does not allow this value to be changed to a value other than 0 in runtime builds.</em> </remarks> <example><code> void PlayAnimation(AnimancerComponent animancer, AnimationClip clip) { var state = animancer.Play(clip); // Skip 0.5 seconds into the animation: state.Time = 0.5f; // Skip 50% of the way through the animation (0.5 in a range of 0 to 1): state.NormalizedTime = 0.5f; // Skip to the end of the animation and play backwards. state.NormalizedTime = 1; state.Speed = -1; } </code></example> <summary>Prevents the <see cref="RawTime"/> from being applied.</summary> <summary>[Pro-Only] The <see cref="NormalizedTime"/> after which the <see cref="AnimancerEvent.Sequence.OnEnd"/> callback will be invoked every frame. </summary> <remarks> This is a wrapper around <see cref="AnimancerEvent.Sequence.NormalizedEndTime"/> so that if the value has not been set (<see cref="float.NaN"/>) it can be determined based on the <see cref="AnimancerNode.EffectiveSpeed"/>: positive speed ends at 1 and negative speed ends at 0. <para></para> <em>Animancer Lite does not allow this value to be changed in runtime builds.</em> </remarks> <summary> The number of seconds the animation will take to play fully at its current <see cref="AnimancerNode.EffectiveSpeed"/>. </summary> <remarks> For the time remaining from now until it reaches the end, use <see cref="RemainingDuration"/> instead. <para></para> Setting this value modifies the <see cref="AnimancerNode.EffectiveSpeed"/>, not the <see cref="Length"/>. <para></para> <em>Animancer Lite does not allow this value to be changed in runtime builds.</em> </remarks> <example><code> void PlayAnimation(AnimancerComponent animancer, AnimationClip clip) { var state = animancer.Play(clip); state.Duration = 1;// Play fully in 1 second. state.Duration = 2;// Play fully in 2 seconds. state.Duration = 0.5f;// Play fully in half a second. state.Duration = -1;// Play backwards fully in 1 second. state.NormalizedTime = 1; state.Duration = -1;// Play backwards from the end in 1 second. } </code></example> <summary> The number of seconds this state will take to go from its current <see cref="NormalizedTime"/> to the <see cref="NormalizedEndTime"/> at its current <see cref="AnimancerNode.EffectiveSpeed"/>. </summary> <remarks> For the time it would take to play fully from the start, use the <see cref="Duration"/> instead. <para></para> Setting this value modifies the <see cref="AnimancerNode.EffectiveSpeed"/>, not the <see cref="Length"/>. <para></para> <em>Animancer Lite does not allow this value to be changed in runtime builds.</em> </remarks> <example><code> void PlayAnimation(AnimancerComponent animancer, AnimationClip clip) { var state = animancer.Play(clip); state.RemainingDuration = 1;// Play from the current time to the end in 1 second. state.RemainingDuration = 2;// Play from the current time to the end in 2 seconds. state.RemainingDuration = 0.5f;// Play from the current time to the end in half a second. state.RemainingDuration = -1;// Play from the current time away from the end. } </code></example> <summary>The total time this state would take to play in seconds when <see cref="AnimancerNode.Speed"/> = 1.</summary> <summary>Will this state loop back to the start when it reaches the end?</summary> <summary> Updates the <see cref="AnimancerNode.Weight"/> for fading, applies it to this state's port on the parent mixer, and plays or pauses the <see cref="Playable"/> if its state is dirty. </summary> <remarks> If the <see cref="Parent"/>'s <see cref="AnimancerNode.KeepChildrenConnected"/> is set to false, this method will also connect/disconnect this node from the <see cref="Parent"/> in the playable graph. </remarks> <summary>Destroys the <see cref="Playable"/> and cleans up this state.</summary> <remarks> This method is NOT called automatically, so when implementing a custom state type you must use <see cref="AnimancerPlayable.Disposables"/> if you need to guarantee that things will get cleaned up. </remarks> <summary>[<see cref="IAnimationClipCollection"/>] Gathers all the animations in this state.</summary> <summary> Returns true if the animation is playing and has not yet passed the <see cref="AnimancerEvent.Sequence.endEvent"/>. </summary> <remarks> This method is called by <see cref="IEnumerator.MoveNext"/> so this object can be used as a custom yield instruction to wait until it finishes. </remarks> <summary> Returns the <see cref="AnimancerNode.DebugName"/> if one is set, otherwise a string describing the type of this state and the name of the <see cref="MainObject"/>. </summary> <summary>[Editor-Only] Returns a custom drawer for this state.</summary> <inheritdoc/> <summary>Returns the hierarchy path of this state through its <see cref="Parent"/>s.</summary> <summary>Appends the hierarchy path of this state through its <see cref="Parent"/>s.</summary> <summary>Appends "[Index] -> GetType().Name".</summary> <summary> Base class for serializable <see cref="ITransition"/>s which can create a particular type of <see cref="AnimancerState"/> when passed into <see cref="AnimancerPlayable.Play(ITransition)"/>. </summary> <remarks> Unfortunately the tool used to generate this documentation does not currently support nested types with identical names, so only one <c>Transition</c> class will actually have a documentation page. <para></para> Even though it has the <see cref="SerializableAttribute"/>, this class won't actually get serialized by Unity because it's generic and abstract. Each child class still needs to include the attribute. <para></para> Documentation: <see href="https://kybernetik.com.au/animancer/docs/manual/transitions">Transitions</see> </remarks> https://kybernetik.com.au/animancer/api/Animancer/Transition_1 <summary>[<see cref="SerializeField"/>] The amount of time the transition will take (in seconds).</summary> <exception cref="ArgumentOutOfRangeException">Thrown when setting the value to a negative number.</exception> <summary>[<see cref="ITransitionDetailed"/>] Indicates what the value of <see cref="AnimancerState.IsLooping"/> will be for the created state. Returns false unless overridden. </summary> <summary>[<see cref="ITransitionDetailed"/>] Determines what <see cref="NormalizedTime"/> to start the animation at. Returns <see cref="float.NaN"/> unless overridden. </summary> <summary>[<see cref="ITransitionDetailed"/>] Determines how fast the animation plays (1x = normal speed). Returns 1 unless overridden. </summary> <summary>[<see cref="ITransitionDetailed"/>] The maximum amount of time the animation is expected to take (in seconds). </summary> <remarks>The actual duration can vary in states like <see cref="MixerState"/>.</remarks> <summary>[<see cref="ITransitionDetailed"/>] The <see cref="Motion.averageAngularSpeed"/> that the created state will have. </summary> <remarks>The actual average velocity can vary in states like <see cref="MixerState"/>.</remarks> <summary>[<see cref="ITransitionDetailed"/>] The <see cref="Motion.averageSpeed"/> that the created state will have. </summary> <remarks>The actual average velocity can vary in states like <see cref="MixerState"/>.</remarks> <summary>[<see cref="SerializeField"/>] [<see cref="ITransitionDetailed"/>] Events which will be triggered as the animation plays. </summary> <remarks>This property returns the <see cref="AnimancerEvent.Sequence.Serializable.Sequence"/>.</remarks> <summary>[<see cref="SerializeField"/>] [<see cref="ITransitionDetailed"/>] Events which will be triggered as the animation plays. </summary> <summary> The state that was created by this object. Specifically, this is the state that was most recently passed into <see cref="Apply"/> (usually by <see cref="AnimancerPlayable.Play(ITransition)"/>). <para></para> You can use <see cref="AnimancerPlayable.StateDictionary.GetOrCreate(ITransition)"/> or <see cref="AnimancerLayer.GetOrCreateState(ITransition)"/> to get or create the state for a specific object. <para></para> <see cref="State"/> is simply a shorthand for casting this to <typeparamref name="TState"/>. </summary> <summary> The state that was created by this object. Specifically, this is the state that was most recently passed into <see cref="Apply"/> (usually by <see cref="AnimancerPlayable.Play(ITransition)"/>). </summary> <remarks> You can use <see cref="AnimancerPlayable.StateDictionary.GetOrCreate(ITransition)"/> or <see cref="AnimancerLayer.GetOrCreateState(ITransition)"/> to get or create the state for a specific object. <para></para> This property is shorthand for casting the <see cref="BaseState"/> to <typeparamref name="TState"/>. </remarks> <exception cref="InvalidCastException"> The <see cref="BaseState"/> is not actually a <typeparamref name="TState"/>. This should only happen if a different type of state was created by something else and registered using the <see cref="Key"/>, causing this <see cref="AnimancerPlayable.Play(ITransition)"/> to pass that state into <see cref="Apply"/> instead of calling <see cref="CreateState"/> to make the correct type of state. </exception> <summary>Indicates whether this transition can create a valid <see cref="AnimancerState"/>.</summary> <summary>The <see cref="AnimancerState.Key"/> which the created state will be registered with.</summary> <remarks>Returns <c>this</c> unless overridden.</remarks> <summary> When a transition is passed into <see cref="AnimancerPlayable.Play(ITransition)"/>, this property determines which <see cref="Animancer.FadeMode"/> will be used. </summary> <summary>Creates and returns a new <typeparamref name="TState"/>.</summary> <remarks> Note that using methods like <see cref="AnimancerPlayable.Play(ITransition)"/> will also call <see cref="Apply"/>, so if you call this method manually you may want to call that method as well. Or you can just use <see cref="AnimancerUtilities.CreateStateAndApply"/>. </remarks> <summary>Creates and returns a new <typeparamref name="TState"/>.</summary> <remarks> Note that using methods like <see cref="AnimancerPlayable.Play(ITransition)"/> will also call <see cref="Apply"/>, so if you call this method manually you may want to call that method as well. Or you can just use <see cref="AnimancerUtilities.CreateStateAndApply"/>. </remarks> <summary>[<see cref="ITransition"/>] Sets the <see cref="BaseState"/> and applies any other modifications to the `state`. </summary> <remarks> Called by <see cref="AnimancerPlayable.Play(ITransition)"/>. <para></para> This method also clears the <see cref="State"/> if necessary, so it will re-cast the <see cref="BaseState"/> when it gets accessed again. </remarks> <summary>The <see cref="AnimancerState.MainObject"/> that the created state will have.</summary> <summary>The display name of this transition.</summary> <summary>Returns the <see cref="Name"/> and type of this transition.</summary> <summary>[Editor-Only] Don't use Inspector Gadgets Nested Object Drawers.</summary>
- <summary>The <see cref="AnimancerPlayable"/> at the root of the graph.</summary> <summary>The object which receives the output of the <see cref="Playable"/>.</summary> <summary>Connects this state to the `parent` mixer at the specified `index`.</summary> <remarks> Use <see cref="AnimancerLayer.AddChild(AnimancerState)"/> instead of this method to connect a state to an available port on a layer. </remarks> <summary>[Internal] Called by <see cref="AnimancerNode.OnAddChild(IList{AnimancerState}, AnimancerState)"/> if the specified port is already occupied so it can be cleared without triggering any other calls. </summary> <summary> The <see cref="AnimancerNode.Weight"/> of this state multiplied by the <see cref="AnimancerNode.Weight"/> of each of its parents down the hierarchy to determine how much this state affects the final output. </summary> <exception cref="NullReferenceException">This state has no <see cref="AnimancerNode.Parent"/>.</exception> <inheritdoc/> <summary> The index of the <see cref="AnimancerLayer"/> this state is connected to (determined by the <see cref="Parent"/>). </summary> <summary> The object used to identify this state in the root <see cref="AnimancerPlayable.States"/> dictionary. Can be null. </summary> <summary>The <see cref="AnimationClip"/> which this state plays (if any).</summary> <exception cref="NotSupportedException">This state type doesn't have a clip and you try to set it.</exception> <summary>The main object to show in the Inspector for this state (if any).</summary> <exception cref="NotSupportedException">This state type doesn't have a main object and you try to set it.</exception> <exception cref="InvalidCastException">This state can't use the assigned value.</exception> <summary> Sets the `currentObject` and calls <see cref="AnimancerNode.RecreatePlayable"/>. If the `currentObject` was being used as the <see cref="Key"/> then it is changed as well. </summary> <exception cref="ArgumentNullException">The `newObject` is null.</exception> <summary>The average velocity of the root motion caused by this state.</summary> <summary>Is the <see cref="Time"/> automatically advancing?</summary> <summary>Has <see cref="_IsPlaying"/> changed since it was last applied to the <see cref="Playable"/>.</summary> <remarks> Playables start playing by default so we start dirty to pause it during the first update (unless <see cref="IsPlaying"/> is set to true before that). </remarks> <summary>Is the <see cref="Time"/> automatically advancing?</summary> <example><code> void IsPlayingExample(AnimancerComponent animancer, AnimationClip clip) { var state = animancer.States.GetOrCreate(clip); if (state.IsPlaying) Debug.Log(clip + " is playing"); else Debug.Log(clip + " is paused"); state.IsPlaying = false;// Pause the animation. state.IsPlaying = true;// Unpause the animation. } </code></example> <summary>Called when the value of <see cref="IsPlaying"/> is changed.</summary> <summary>Creates and assigns the <see cref="Playable"/> managed by this state.</summary> <remarks>This method also applies the <see cref="AnimancerNode.Speed"/> and <see cref="IsPlaying"/>.</remarks> <summary> Returns true if this state is playing and is at or fading towards a non-zero <see cref="AnimancerNode.Weight"/>. </summary> <summary> Returns true if this state is not playing and is at 0 <see cref="AnimancerNode.Weight"/>. </summary> <summary>Plays this state immediately, without any blending.</summary> <remarks> Sets <see cref="IsPlaying"/> = true, <see cref="AnimancerNode.Weight"/> = 1, and clears the <see cref="Events"/> (unless <see cref="AutomaticallyClearEvents"/> is disabled). <para></para> This method does not change the <see cref="Time"/> so it will continue from its current value. </remarks> <summary>Stops the animation and makes it inactive immediately so it no longer affects the output.</summary> <remarks> Sets <see cref="AnimancerNode.Weight"/> = 0, <see cref="IsPlaying"/> = false, <see cref="Time"/> = 0, and clears the <see cref="Events"/> (unless <see cref="AutomaticallyClearEvents"/> is disabled). <para></para> To freeze the animation in place without ending it, you only need to set <see cref="IsPlaying"/> = false instead. Or to freeze all animations, you can call <see cref="AnimancerPlayable.PauseGraph"/>. </remarks> <summary> Called by <see cref="AnimancerNode.StartFade"/>. Clears the <see cref="Events"/> (unless <see cref="AutomaticallyClearEvents"/> is disabled). </summary> <summary> The current time of the <see cref="Playable"/>, retrieved by <see cref="Time"/> whenever the <see cref="_TimeFrameID"/> is different from the <see cref="AnimancerPlayable.FrameID"/>. </summary> <summary> Indicates whether the <see cref="_Time"/> needs to be assigned to the <see cref="Playable"/> next update. </summary> <remarks> <see cref="EventDispatcher"/> executes after all other playables, at which point changes can still be made to their time but not their weight which means that if we set the time immediately then it can be out of sync with the weight. For example, if an animation ends and you play another, the first animation would be stopped and rewinded to the start but would still be at full weight so it would show its first frame before the new animation actually takes effect (even if the previous animation was not looping). <para></para> So instead, we simply delay setting the actual playable time until the next update so that time and weight are always in sync. </remarks> <summary> The <see cref="AnimancerPlayable.FrameID"/> from when the <see cref="Time"/> was last retrieved from the <see cref="Playable"/>. </summary> <summary>The number of seconds that have passed since the start of this animation.</summary> <remarks> This value will continue increasing after the animation passes the end of its <see cref="Length"/> while the animated object either freezes in place or starts again from the beginning according to whether it is looping or not. <para></para> This property internally uses <see cref="RawTime"/> whenever the value is out of date or gets changed. <para></para> <em>Animancer Lite does not allow this value to be changed in runtime builds (except resetting it to 0).</em> </remarks> <example><code> void PlayAnimation(AnimancerComponent animancer, AnimationClip clip) { var state = animancer.Play(clip); // Skip 0.5 seconds into the animation: state.Time = 0.5f; // Skip 50% of the way through the animation (0.5 in a range of 0 to 1): state.NormalizedTime = 0.5f; // Skip to the end of the animation and play backwards. state.NormalizedTime = 1; state.Speed = -1; } </code></example> <summary> The internal implementation of <see cref="Time"/> which directly gets and sets the underlying value. </summary> <remarks> Setting this value actually calls <see cref="PlayableExtensions.SetTime"/> twice to ensure that animation events aren't triggered incorrectly. Calling it only once would trigger any animation events between the previous time and the new time. So if an animation plays to the end and you set the time back to 0 (such as by calling <see cref="Stop"/> or playing a different animation), the next time that animation played it would immediately trigger all of its events, then play through and trigger them normally as well. </remarks> <summary> The <see cref="Time"/> of this state as a portion of the animation's <see cref="Length"/>, meaning the value goes from 0 to 1 as it plays from start to end, regardless of how long that actually takes. </summary> <remarks> This value will continue increasing after the animation passes the end of its <see cref="Length"/> while the animated object either freezes in place or starts again from the beginning according to whether it is looping or not. <para></para> The fractional part of the value (<c>NormalizedTime % 1</c>) is the percentage (0-1) of progress in the current loop while the integer part (<c>(int)NormalizedTime</c>) is the number of times the animation has been looped. <para></para> <em>Animancer Lite does not allow this value to be changed to a value other than 0 in runtime builds.</em> </remarks> <example><code> void PlayAnimation(AnimancerComponent animancer, AnimationClip clip) { var state = animancer.Play(clip); // Skip 0.5 seconds into the animation: state.Time = 0.5f; // Skip 50% of the way through the animation (0.5 in a range of 0 to 1): state.NormalizedTime = 0.5f; // Skip to the end of the animation and play backwards. state.NormalizedTime = 1; state.Speed = -1; } </code></example> <summary>Prevents the <see cref="RawTime"/> from being applied.</summary> <summary>[Pro-Only] The <see cref="NormalizedTime"/> after which the <see cref="AnimancerEvent.Sequence.OnEnd"/> callback will be invoked every frame. </summary> <remarks> This is a wrapper around <see cref="AnimancerEvent.Sequence.NormalizedEndTime"/> so that if the value has not been set (<see cref="float.NaN"/>) it can be determined based on the <see cref="AnimancerNode.EffectiveSpeed"/>: positive speed ends at 1 and negative speed ends at 0. <para></para> <em>Animancer Lite does not allow this value to be changed in runtime builds.</em> </remarks> <summary> The number of seconds the animation will take to play fully at its current <see cref="AnimancerNode.EffectiveSpeed"/>. </summary> <remarks> For the time remaining from now until it reaches the end, use <see cref="RemainingDuration"/> instead. <para></para> Setting this value modifies the <see cref="AnimancerNode.EffectiveSpeed"/>, not the <see cref="Length"/>. <para></para> <em>Animancer Lite does not allow this value to be changed in runtime builds.</em> </remarks> <example><code> void PlayAnimation(AnimancerComponent animancer, AnimationClip clip) { var state = animancer.Play(clip); state.Duration = 1;// Play fully in 1 second. state.Duration = 2;// Play fully in 2 seconds. state.Duration = 0.5f;// Play fully in half a second. state.Duration = -1;// Play backwards fully in 1 second. state.NormalizedTime = 1; state.Duration = -1;// Play backwards from the end in 1 second. } </code></example> <summary> The number of seconds this state will take to go from its current <see cref="NormalizedTime"/> to the <see cref="NormalizedEndTime"/> at its current <see cref="AnimancerNode.EffectiveSpeed"/>. </summary> <remarks> For the time it would take to play fully from the start, use the <see cref="Duration"/> instead. <para></para> Setting this value modifies the <see cref="AnimancerNode.EffectiveSpeed"/>, not the <see cref="Length"/>. <para></para> <em>Animancer Lite does not allow this value to be changed in runtime builds.</em> </remarks> <example><code> void PlayAnimation(AnimancerComponent animancer, AnimationClip clip) { var state = animancer.Play(clip); state.RemainingDuration = 1;// Play from the current time to the end in 1 second. state.RemainingDuration = 2;// Play from the current time to the end in 2 seconds. state.RemainingDuration = 0.5f;// Play from the current time to the end in half a second. state.RemainingDuration = -1;// Play from the current time away from the end. } </code></example> <summary>The total time this state would take to play in seconds when <see cref="AnimancerNode.Speed"/> = 1.</summary> <summary>Will this state loop back to the start when it reaches the end?</summary> <summary> Updates the <see cref="AnimancerNode.Weight"/> for fading, applies it to this state's port on the parent mixer, and plays or pauses the <see cref="Playable"/> if its state is dirty. </summary> <remarks> If the <see cref="Parent"/>'s <see cref="AnimancerNode.KeepChildrenConnected"/> is set to false, this method will also connect/disconnect this node from the <see cref="Parent"/> in the playable graph. </remarks> <summary>Destroys the <see cref="Playable"/> and cleans up this state.</summary> <remarks> This method is NOT called automatically, so when implementing a custom state type you must use <see cref="AnimancerPlayable.Disposables"/> if you need to guarantee that things will get cleaned up. </remarks> <summary>[<see cref="IAnimationClipCollection"/>] Gathers all the animations in this state.</summary> <summary> Returns true if the animation is playing and has not yet passed the <see cref="AnimancerEvent.Sequence.endEvent"/>. </summary> <remarks> This method is called by <see cref="IEnumerator.MoveNext"/> so this object can be used as a custom yield instruction to wait until it finishes. </remarks> <summary> Returns the <see cref="AnimancerNode.DebugName"/> if one is set, otherwise a string describing the type of this state and the name of the <see cref="MainObject"/>. </summary> <summary>[Editor-Only] Returns a custom drawer for this state.</summary> <inheritdoc/> <summary>Returns the hierarchy path of this state through its <see cref="Parent"/>s.</summary> <summary>Appends the hierarchy path of this state through its <see cref="Parent"/>s.</summary> <summary>Appends "[Index] -> GetType().Name".</summary> <summary> Base class for serializable <see cref="ITransition"/>s which can create a particular type of <see cref="AnimancerState"/> when passed into <see cref="AnimancerPlayable.Play(ITransition)"/>. </summary> <remarks> Unfortunately the tool used to generate this documentation does not currently support nested types with identical names, so only one <c>Transition</c> class will actually have a documentation page. <para></para> Even though it has the <see cref="SerializableAttribute"/>, this class won't actually get serialized by Unity because it's generic and abstract. Each child class still needs to include the attribute. <para></para> Documentation: <see href="https://kybernetik.com.au/animancer/docs/manual/transitions">Transitions</see> </remarks> https://kybernetik.com.au/animancer/api/Animancer/Transition_1 <summary>[<see cref="SerializeField"/>] The amount of time the transition will take (in seconds).</summary> <exception cref="ArgumentOutOfRangeException">Thrown when setting the value to a negative number.</exception> <summary>[<see cref="ITransitionDetailed"/>] Indicates what the value of <see cref="AnimancerState.IsLooping"/> will be for the created state. Returns false unless overridden. </summary> <summary>[<see cref="ITransitionDetailed"/>] Determines what <see cref="NormalizedTime"/> to start the animation at. Returns <see cref="float.NaN"/> unless overridden. </summary> <summary>[<see cref="ITransitionDetailed"/>] Determines how fast the animation plays (1x = normal speed). Returns 1 unless overridden. </summary> <summary>[<see cref="ITransitionDetailed"/>] The maximum amount of time the animation is expected to take (in seconds). </summary> <remarks>The actual duration can vary in states like <see cref="MixerState"/>.</remarks> <summary>[<see cref="ITransitionDetailed"/>] The <see cref="Motion.averageAngularSpeed"/> that the created state will have. </summary> <remarks>The actual average velocity can vary in states like <see cref="MixerState"/>.</remarks> <summary>[<see cref="ITransitionDetailed"/>] The <see cref="Motion.averageSpeed"/> that the created state will have. </summary> <remarks>The actual average velocity can vary in states like <see cref="MixerState"/>.</remarks> <summary>[<see cref="SerializeField"/>] [<see cref="ITransitionDetailed"/>] Events which will be triggered as the animation plays. </summary> <remarks>This property returns the <see cref="AnimancerEvent.Sequence.Serializable.Sequence"/>.</remarks> <summary>[<see cref="SerializeField"/>] [<see cref="ITransitionDetailed"/>] Events which will be triggered as the animation plays. </summary> <summary> The state that was created by this object. Specifically, this is the state that was most recently passed into <see cref="Apply"/> (usually by <see cref="AnimancerPlayable.Play(ITransition)"/>). <para></para> You can use <see cref="AnimancerPlayable.StateDictionary.GetOrCreate(ITransition)"/> or <see cref="AnimancerLayer.GetOrCreateState(ITransition)"/> to get or create the state for a specific object. <para></para> <see cref="State"/> is simply a shorthand for casting this to <typeparamref name="TState"/>. </summary> <summary> The state that was created by this object. Specifically, this is the state that was most recently passed into <see cref="Apply"/> (usually by <see cref="AnimancerPlayable.Play(ITransition)"/>). </summary> <remarks> You can use <see cref="AnimancerPlayable.StateDictionary.GetOrCreate(ITransition)"/> or <see cref="AnimancerLayer.GetOrCreateState(ITransition)"/> to get or create the state for a specific object. <para></para> This property is shorthand for casting the <see cref="BaseState"/> to <typeparamref name="TState"/>. </remarks> <exception cref="InvalidCastException"> The <see cref="BaseState"/> is not actually a <typeparamref name="TState"/>. This should only happen if a different type of state was created by something else and registered using the <see cref="Key"/>, causing this <see cref="AnimancerPlayable.Play(ITransition)"/> to pass that state into <see cref="Apply"/> instead of calling <see cref="CreateState"/> to make the correct type of state. </exception> <summary>Indicates whether this transition can create a valid <see cref="AnimancerState"/>.</summary> <summary>The <see cref="AnimancerState.Key"/> which the created state will be registered with.</summary> <remarks>Returns <c>this</c> unless overridden.</remarks> <summary> When a transition is passed into <see cref="AnimancerPlayable.Play(ITransition)"/>, this property determines which <see cref="Animancer.FadeMode"/> will be used. </summary> <summary>Creates and returns a new <typeparamref name="TState"/>.</summary> <remarks> Note that using methods like <see cref="AnimancerPlayable.Play(ITransition)"/> will also call <see cref="Apply"/>, so if you call this method manually you may want to call that method as well. Or you can just use <see cref="AnimancerUtilities.CreateStateAndApply"/>. </remarks> <summary>Creates and returns a new <typeparamref name="TState"/>.</summary> <remarks> Note that using methods like <see cref="AnimancerPlayable.Play(ITransition)"/> will also call <see cref="Apply"/>, so if you call this method manually you may want to call that method as well. Or you can just use <see cref="AnimancerUtilities.CreateStateAndApply"/>. </remarks> <summary>[<see cref="ITransition"/>] Sets the <see cref="BaseState"/> and applies any other modifications to the `state`. </summary> <remarks> Called by <see cref="AnimancerPlayable.Play(ITransition)"/>. <para></para> This method also clears the <see cref="State"/> if necessary, so it will re-cast the <see cref="BaseState"/> when it gets accessed again. </remarks> <summary>The <see cref="AnimancerState.MainObject"/> that the created state will have.</summary> <summary>The display name of this transition.</summary> <summary>Returns the <see cref="Name"/> and type of this transition.</summary> <summary>[Editor-Only] Don't use Inspector Gadgets Nested Object Drawers.</summary>
- <summary>[<see cref="ITransitionDetailed"/>] The <see cref="Motion.averageSpeed"/> that the created state will have. </summary> <remarks>The actual average velocity can vary in states like <see cref="MixerState"/>.</remarks> <summary>[<see cref="SerializeField"/>] [<see cref="ITransitionDetailed"/>] Events which will be triggered as the animation plays. </summary> <remarks>This property returns the <see cref="AnimancerEvent.Sequence.Serializable.Sequence"/>.</remarks> <summary>[<see cref="SerializeField"/>] [<see cref="ITransitionDetailed"/>] Events which will be triggered as the animation plays. </summary> <summary> The state that was created by this object. Specifically, this is the state that was most recently passed into <see cref="Apply"/> (usually by <see cref="AnimancerPlayable.Play(ITransition)"/>). <para></para> You can use <see cref="AnimancerPlayable.StateDictionary.GetOrCreate(ITransition)"/> or <see cref="AnimancerLayer.GetOrCreateState(ITransition)"/> to get or create the state for a specific object. <para></para> <see cref="State"/> is simply a shorthand for casting this to <typeparamref name="TState"/>. </summary>
- <summary>[<see cref="SerializeField"/>] [<see cref="ITransitionDetailed"/>] Events which will be triggered as the animation plays. </summary> <remarks>This property returns the <see cref="AnimancerEvent.Sequence.Serializable.Sequence"/>.</remarks> <summary>[<see cref="SerializeField"/>] [<see cref="ITransitionDetailed"/>] Events which will be triggered as the animation plays. </summary> <summary> The state that was created by this object. Specifically, this is the state that was most recently passed into <see cref="Apply"/> (usually by <see cref="AnimancerPlayable.Play(ITransition)"/>). <para></para> You can use <see cref="AnimancerPlayable.StateDictionary.GetOrCreate(ITransition)"/> or <see cref="AnimancerLayer.GetOrCreateState(ITransition)"/> to get or create the state for a specific object. <para></para> <see cref="State"/> is simply a shorthand for casting this to <typeparamref name="TState"/>. </summary>
- <summary>Is the <see cref="Time"/> automatically advancing?</summary> <summary>Has <see cref="_IsPlaying"/> changed since it was last applied to the <see cref="Playable"/>.</summary> <remarks> Playables start playing by default so we start dirty to pause it during the first update (unless <see cref="IsPlaying"/> is set to true before that). </remarks> <summary>Is the <see cref="Time"/> automatically advancing?</summary> <example><code> void IsPlayingExample(AnimancerComponent animancer, AnimationClip clip) { var state = animancer.States.GetOrCreate(clip); if (state.IsPlaying) Debug.Log(clip + " is playing"); else Debug.Log(clip + " is paused"); state.IsPlaying = false;// Pause the animation. state.IsPlaying = true;// Unpause the animation. }
- <summary>[Pro-Only] The <see cref="NormalizedTime"/> after which the <see cref="AnimancerEvent.Sequence.OnEnd"/> callback will be invoked every frame. </summary> <remarks> This is a wrapper around <see cref="AnimancerEvent.Sequence.NormalizedEndTime"/> so that if the value has not been set (<see cref="float.NaN"/>) it can be determined based on the <see cref="AnimancerNode.EffectiveSpeed"/>: positive speed ends at 1 and negative speed ends at 0. <para></para> <em>Animancer Lite does not allow this value to be changed in runtime builds.</em> </remarks>
- <inheritdoc/>
- <summary>Creates and returns a new <typeparamref name="TState"/>.</summary> <remarks> Note that using methods like <see cref="AnimancerPlayable.Play(ITransition)"/> will also call <see cref="Apply"/>, so if you call this method manually you may want to call that method as well. Or you can just use <see cref="AnimancerUtilities.CreateStateAndApply"/>. </remarks> <summary>[<see cref="ITransition"/>] Sets the <see cref="BaseState"/> and applies any other modifications to the `state`. </summary> <remarks> Called by <see cref="AnimancerPlayable.Play(ITransition)"/>. <para></para> This method also clears the <see cref="State"/> if necessary, so it will re-cast the <see cref="BaseState"/> when it gets accessed again. </remarks>
- <summary>[<see cref="SerializeField"/>] [<see cref="ITransitionDetailed"/>] Events which will be triggered as the animation plays. </summary> <summary> The state that was created by this object. Specifically, this is the state that was most recently passed into <see cref="Apply"/> (usually by <see cref="AnimancerPlayable.Play(ITransition)"/>). <para></para> You can use <see cref="AnimancerPlayable.StateDictionary.GetOrCreate(ITransition)"/> or <see cref="AnimancerLayer.GetOrCreateState(ITransition)"/> to get or create the state for a specific object. <para></para> <see cref="State"/> is simply a shorthand for casting this to <typeparamref name="TState"/>. </summary>
- <summary>Creates and returns a new <typeparamref name="TState"/>.</summary> <remarks> Note that using methods like <see cref="AnimancerPlayable.Play(ITransition)"/> will also call <see cref="Apply"/>, so if you call this method manually you may want to call that method as well. Or you can just use <see cref="AnimancerUtilities.CreateStateAndApply"/>. </remarks> <summary>Creates and returns a new <typeparamref name="TState"/>.</summary> <remarks> Note that using methods like <see cref="AnimancerPlayable.Play(ITransition)"/> will also call <see cref="Apply"/>, so if you call this method manually you may want to call that method as well. Or you can just use <see cref="AnimancerUtilities.CreateStateAndApply"/>. </remarks> <summary>[<see cref="ITransition"/>] Sets the <see cref="BaseState"/> and applies any other modifications to the `state`. </summary> <remarks> Called by <see cref="AnimancerPlayable.Play(ITransition)"/>. <para></para> This method also clears the <see cref="State"/> if necessary, so it will re-cast the <see cref="BaseState"/> when it gets accessed again. </remarks>
- <summary> Returns true if the animation is playing and has not yet passed the <see cref="AnimancerEvent.Sequence.endEvent"/>. </summary> <remarks> This method is called by <see cref="IEnumerator.MoveNext"/> so this object can be used as a custom yield instruction to wait until it finishes. </remarks>
- <summary>[<see cref="ITransition"/>] Sets the <see cref="BaseState"/> and applies any other modifications to the `state`. </summary> <remarks> Called by <see cref="AnimancerPlayable.Play(ITransition)"/>. <para></para> This method also clears the <see cref="State"/> if necessary, so it will re-cast the <see cref="BaseState"/> when it gets accessed again. </remarks>
- <summary> Returns true if this state is not playing and is at 0 <see cref="AnimancerNode.Weight"/>. </summary> <summary>Plays this state immediately, without any blending.</summary> <remarks> Sets <see cref="IsPlaying"/> = true, <see cref="AnimancerNode.Weight"/> = 1, and clears the <see cref="Events"/> (unless <see cref="AutomaticallyClearEvents"/> is disabled). <para></para> This method does not change the <see cref="Time"/> so it will continue from its current value. </remarks>
- <summary>[<see cref="ITransitionDetailed"/>] Determines what <see cref="NormalizedTime"/> to start the animation at. Returns <see cref="float.NaN"/> unless overridden. </summary>
- <summary> Updates the <see cref="AnimancerNode.Weight"/> for fading, applies it to this state's port on the parent mixer, and plays or pauses the <see cref="Playable"/> if its state is dirty. </summary> <remarks> If the <see cref="Parent"/>'s <see cref="AnimancerNode.KeepChildrenConnected"/> is set to false, this method will also connect/disconnect this node from the <see cref="Parent"/> in the playable graph. </remarks>
- <summary>Plays this state immediately, without any blending.</summary> <remarks> Sets <see cref="IsPlaying"/> = true, <see cref="AnimancerNode.Weight"/> = 1, and clears the <see cref="Events"/> (unless <see cref="AutomaticallyClearEvents"/> is disabled). <para></para> This method does not change the <see cref="Time"/> so it will continue from its current value. </remarks>
- <summary>The <see cref="AnimancerState.Key"/> which the created state will be registered with.</summary> <remarks>Returns <c>this</c> unless overridden.</remarks> <summary> When a transition is passed into <see cref="AnimancerPlayable.Play(ITransition)"/>, this property determines which <see cref="Animancer.FadeMode"/> will be used. </summary> <summary>Creates and returns a new <typeparamref name="TState"/>.</summary> <remarks> Note that using methods like <see cref="AnimancerPlayable.Play(ITransition)"/> will also call <see cref="Apply"/>, so if you call this method manually you may want to call that method as well. Or you can just use <see cref="AnimancerUtilities.CreateStateAndApply"/>. </remarks> <summary>Creates and returns a new <typeparamref name="TState"/>.</summary> <remarks> Note that using methods like <see cref="AnimancerPlayable.Play(ITransition)"/> will also call <see cref="Apply"/>, so if you call this method manually you may want to call that method as well. Or you can just use <see cref="AnimancerUtilities.CreateStateAndApply"/>. </remarks> <summary>[<see cref="ITransition"/>] Sets the <see cref="BaseState"/> and applies any other modifications to the `state`. </summary> <remarks> Called by <see cref="AnimancerPlayable.Play(ITransition)"/>. <para></para> This method also clears the <see cref="State"/> if necessary, so it will re-cast the <see cref="BaseState"/> when it gets accessed again. </remarks>
- <summary> When a transition is passed into <see cref="AnimancerPlayable.Play(ITransition)"/>, this property determines which <see cref="Animancer.FadeMode"/> will be used. </summary> <summary>Creates and returns a new <typeparamref name="TState"/>.</summary> <remarks> Note that using methods like <see cref="AnimancerPlayable.Play(ITransition)"/> will also call <see cref="Apply"/>, so if you call this method manually you may want to call that method as well. Or you can just use <see cref="AnimancerUtilities.CreateStateAndApply"/>. </remarks> <summary>Creates and returns a new <typeparamref name="TState"/>.</summary> <remarks> Note that using methods like <see cref="AnimancerPlayable.Play(ITransition)"/> will also call <see cref="Apply"/>, so if you call this method manually you may want to call that method as well. Or you can just use <see cref="AnimancerUtilities.CreateStateAndApply"/>. </remarks> <summary>[<see cref="ITransition"/>] Sets the <see cref="BaseState"/> and applies any other modifications to the `state`. </summary> <remarks> Called by <see cref="AnimancerPlayable.Play(ITransition)"/>. <para></para> This method also clears the <see cref="State"/> if necessary, so it will re-cast the <see cref="BaseState"/> when it gets accessed again. </remarks>
- <summary> The index of the <see cref="AnimancerLayer"/> this state is connected to (determined by the <see cref="Parent"/>). </summary>
- <summary> Base class for all states in an <see cref="AnimancerPlayable"/> graph which manages one or more <see cref="Playable"/>s. </summary> <remarks> This class can be used as a custom yield instruction to wait until the animation either stops playing or reaches its end. <para></para> Documentation: <see href="https://kybernetik.com.au/animancer/docs/manual/playing/states">States</see> </remarks> https://kybernetik.com.au/animancer/api/Animancer/AnimancerState <summary>The <see cref="AnimancerPlayable"/> at the root of the graph.</summary> <summary>The object which receives the output of the <see cref="Playable"/>.</summary> <summary>Connects this state to the `parent` mixer at the specified `index`.</summary> <remarks> Use <see cref="AnimancerLayer.AddChild(AnimancerState)"/> instead of this method to connect a state to an available port on a layer. </remarks> <summary>[Internal] Called by <see cref="AnimancerNode.OnAddChild(IList{AnimancerState}, AnimancerState)"/> if the specified port is already occupied so it can be cleared without triggering any other calls. </summary> <summary> The <see cref="AnimancerNode.Weight"/> of this state multiplied by the <see cref="AnimancerNode.Weight"/> of each of its parents down the hierarchy to determine how much this state affects the final output. </summary> <exception cref="NullReferenceException">This state has no <see cref="AnimancerNode.Parent"/>.</exception> <inheritdoc/> <summary> The index of the <see cref="AnimancerLayer"/> this state is connected to (determined by the <see cref="Parent"/>). </summary> <summary> The object used to identify this state in the root <see cref="AnimancerPlayable.States"/> dictionary. Can be null. </summary> <summary>The <see cref="AnimationClip"/> which this state plays (if any).</summary> <exception cref="NotSupportedException">This state type doesn't have a clip and you try to set it.</exception> <summary>The main object to show in the Inspector for this state (if any).</summary> <exception cref="NotSupportedException">This state type doesn't have a main object and you try to set it.</exception> <exception cref="InvalidCastException">This state can't use the assigned value.</exception> <summary> Sets the `currentObject` and calls <see cref="AnimancerNode.RecreatePlayable"/>. If the `currentObject` was being used as the <see cref="Key"/> then it is changed as well. </summary> <exception cref="ArgumentNullException">The `newObject` is null.</exception> <summary>The average velocity of the root motion caused by this state.</summary> <summary>Is the <see cref="Time"/> automatically advancing?</summary> <summary>Has <see cref="_IsPlaying"/> changed since it was last applied to the <see cref="Playable"/>.</summary> <remarks> Playables start playing by default so we start dirty to pause it during the first update (unless <see cref="IsPlaying"/> is set to true before that). </remarks> <summary>Is the <see cref="Time"/> automatically advancing?</summary> <example><code> void IsPlayingExample(AnimancerComponent animancer, AnimationClip clip) { var state = animancer.States.GetOrCreate(clip); if (state.IsPlaying) Debug.Log(clip + " is playing"); else Debug.Log(clip + " is paused"); state.IsPlaying = false;// Pause the animation. state.IsPlaying = true;// Unpause the animation. } </code></example> <summary>Called when the value of <see cref="IsPlaying"/> is changed.</summary> <summary>Creates and assigns the <see cref="Playable"/> managed by this state.</summary> <remarks>This method also applies the <see cref="AnimancerNode.Speed"/> and <see cref="IsPlaying"/>.</remarks> <summary> Returns true if this state is playing and is at or fading towards a non-zero <see cref="AnimancerNode.Weight"/>. </summary> <summary> Returns true if this state is not playing and is at 0 <see cref="AnimancerNode.Weight"/>. </summary> <summary>Plays this state immediately, without any blending.</summary> <remarks> Sets <see cref="IsPlaying"/> = true, <see cref="AnimancerNode.Weight"/> = 1, and clears the <see cref="Events"/> (unless <see cref="AutomaticallyClearEvents"/> is disabled). <para></para> This method does not change the <see cref="Time"/> so it will continue from its current value. </remarks> <summary>Stops the animation and makes it inactive immediately so it no longer affects the output.</summary> <remarks> Sets <see cref="AnimancerNode.Weight"/> = 0, <see cref="IsPlaying"/> = false, <see cref="Time"/> = 0, and clears the <see cref="Events"/> (unless <see cref="AutomaticallyClearEvents"/> is disabled). <para></para> To freeze the animation in place without ending it, you only need to set <see cref="IsPlaying"/> = false instead. Or to freeze all animations, you can call <see cref="AnimancerPlayable.PauseGraph"/>. </remarks> <summary> Called by <see cref="AnimancerNode.StartFade"/>. Clears the <see cref="Events"/> (unless <see cref="AutomaticallyClearEvents"/> is disabled). </summary> <summary> The current time of the <see cref="Playable"/>, retrieved by <see cref="Time"/> whenever the <see cref="_TimeFrameID"/> is different from the <see cref="AnimancerPlayable.FrameID"/>. </summary> <summary> Indicates whether the <see cref="_Time"/> needs to be assigned to the <see cref="Playable"/> next update. </summary> <remarks> <see cref="EventDispatcher"/> executes after all other playables, at which point changes can still be made to their time but not their weight which means that if we set the time immediately then it can be out of sync with the weight. For example, if an animation ends and you play another, the first animation would be stopped and rewinded to the start but would still be at full weight so it would show its first frame before the new animation actually takes effect (even if the previous animation was not looping). <para></para> So instead, we simply delay setting the actual playable time until the next update so that time and weight are always in sync. </remarks> <summary> The <see cref="AnimancerPlayable.FrameID"/> from when the <see cref="Time"/> was last retrieved from the <see cref="Playable"/>. </summary> <summary>The number of seconds that have passed since the start of this animation.</summary> <remarks> This value will continue increasing after the animation passes the end of its <see cref="Length"/> while the animated object either freezes in place or starts again from the beginning according to whether it is looping or not. <para></para> This property internally uses <see cref="RawTime"/> whenever the value is out of date or gets changed. <para></para> <em>Animancer Lite does not allow this value to be changed in runtime builds (except resetting it to 0).</em> </remarks> <example><code> void PlayAnimation(AnimancerComponent animancer, AnimationClip clip) { var state = animancer.Play(clip); // Skip 0.5 seconds into the animation: state.Time = 0.5f; // Skip 50% of the way through the animation (0.5 in a range of 0 to 1): state.NormalizedTime = 0.5f; // Skip to the end of the animation and play backwards. state.NormalizedTime = 1; state.Speed = -1; } </code></example> <summary> The internal implementation of <see cref="Time"/> which directly gets and sets the underlying value. </summary> <remarks> Setting this value actually calls <see cref="PlayableExtensions.SetTime"/> twice to ensure that animation events aren't triggered incorrectly. Calling it only once would trigger any animation events between the previous time and the new time. So if an animation plays to the end and you set the time back to 0 (such as by calling <see cref="Stop"/> or playing a different animation), the next time that animation played it would immediately trigger all of its events, then play through and trigger them normally as well. </remarks> <summary> The <see cref="Time"/> of this state as a portion of the animation's <see cref="Length"/>, meaning the value goes from 0 to 1 as it plays from start to end, regardless of how long that actually takes. </summary> <remarks> This value will continue increasing after the animation passes the end of its <see cref="Length"/> while the animated object either freezes in place or starts again from the beginning according to whether it is looping or not. <para></para> The fractional part of the value (<c>NormalizedTime % 1</c>) is the percentage (0-1) of progress in the current loop while the integer part (<c>(int)NormalizedTime</c>) is the number of times the animation has been looped. <para></para> <em>Animancer Lite does not allow this value to be changed to a value other than 0 in runtime builds.</em> </remarks> <example><code> void PlayAnimation(AnimancerComponent animancer, AnimationClip clip) { var state = animancer.Play(clip); // Skip 0.5 seconds into the animation: state.Time = 0.5f; // Skip 50% of the way through the animation (0.5 in a range of 0 to 1): state.NormalizedTime = 0.5f; // Skip to the end of the animation and play backwards. state.NormalizedTime = 1; state.Speed = -1; } </code></example> <summary>Prevents the <see cref="RawTime"/> from being applied.</summary> <summary>[Pro-Only] The <see cref="NormalizedTime"/> after which the <see cref="AnimancerEvent.Sequence.OnEnd"/> callback will be invoked every frame. </summary> <remarks> This is a wrapper around <see cref="AnimancerEvent.Sequence.NormalizedEndTime"/> so that if the value has not been set (<see cref="float.NaN"/>) it can be determined based on the <see cref="AnimancerNode.EffectiveSpeed"/>: positive speed ends at 1 and negative speed ends at 0. <para></para> <em>Animancer Lite does not allow this value to be changed in runtime builds.</em> </remarks> <summary> The number of seconds the animation will take to play fully at its current <see cref="AnimancerNode.EffectiveSpeed"/>. </summary> <remarks> For the time remaining from now until it reaches the end, use <see cref="RemainingDuration"/> instead. <para></para> Setting this value modifies the <see cref="AnimancerNode.EffectiveSpeed"/>, not the <see cref="Length"/>. <para></para> <em>Animancer Lite does not allow this value to be changed in runtime builds.</em> </remarks> <example><code> void PlayAnimation(AnimancerComponent animancer, AnimationClip clip) { var state = animancer.Play(clip); state.Duration = 1;// Play fully in 1 second. state.Duration = 2;// Play fully in 2 seconds. state.Duration = 0.5f;// Play fully in half a second. state.Duration = -1;// Play backwards fully in 1 second. state.NormalizedTime = 1; state.Duration = -1;// Play backwards from the end in 1 second. } </code></example> <summary> The number of seconds this state will take to go from its current <see cref="NormalizedTime"/> to the <see cref="NormalizedEndTime"/> at its current <see cref="AnimancerNode.EffectiveSpeed"/>. </summary> <remarks> For the time it would take to play fully from the start, use the <see cref="Duration"/> instead. <para></para> Setting this value modifies the <see cref="AnimancerNode.EffectiveSpeed"/>, not the <see cref="Length"/>. <para></para> <em>Animancer Lite does not allow this value to be changed in runtime builds.</em> </remarks> <example><code> void PlayAnimation(AnimancerComponent animancer, AnimationClip clip) { var state = animancer.Play(clip); state.RemainingDuration = 1;// Play from the current time to the end in 1 second. state.RemainingDuration = 2;// Play from the current time to the end in 2 seconds. state.RemainingDuration = 0.5f;// Play from the current time to the end in half a second. state.RemainingDuration = -1;// Play from the current time away from the end. } </code></example> <summary>The total time this state would take to play in seconds when <see cref="AnimancerNode.Speed"/> = 1.</summary> <summary>Will this state loop back to the start when it reaches the end?</summary> <summary> Updates the <see cref="AnimancerNode.Weight"/> for fading, applies it to this state's port on the parent mixer, and plays or pauses the <see cref="Playable"/> if its state is dirty. </summary> <remarks> If the <see cref="Parent"/>'s <see cref="AnimancerNode.KeepChildrenConnected"/> is set to false, this method will also connect/disconnect this node from the <see cref="Parent"/> in the playable graph. </remarks> <summary>Destroys the <see cref="Playable"/> and cleans up this state.</summary> <remarks> This method is NOT called automatically, so when implementing a custom state type you must use <see cref="AnimancerPlayable.Disposables"/> if you need to guarantee that things will get cleaned up. </remarks> <summary>[<see cref="IAnimationClipCollection"/>] Gathers all the animations in this state.</summary> <summary> Returns true if the animation is playing and has not yet passed the <see cref="AnimancerEvent.Sequence.endEvent"/>. </summary> <remarks> This method is called by <see cref="IEnumerator.MoveNext"/> so this object can be used as a custom yield instruction to wait until it finishes. </remarks> <summary> Returns the <see cref="AnimancerNode.DebugName"/> if one is set, otherwise a string describing the type of this state and the name of the <see cref="MainObject"/>. </summary> <summary>[Editor-Only] Returns a custom drawer for this state.</summary> <inheritdoc/> <summary>Returns the hierarchy path of this state through its <see cref="Parent"/>s.</summary> <summary>Appends the hierarchy path of this state through its <see cref="Parent"/>s.</summary> <summary>Appends "[Index] -> GetType().Name".</summary> <summary> Base class for serializable <see cref="ITransition"/>s which can create a particular type of <see cref="AnimancerState"/> when passed into <see cref="AnimancerPlayable.Play(ITransition)"/>. </summary> <remarks> Unfortunately the tool used to generate this documentation does not currently support nested types with identical names, so only one <c>Transition</c> class will actually have a documentation page. <para></para> Even though it has the <see cref="SerializableAttribute"/>, this class won't actually get serialized by Unity because it's generic and abstract. Each child class still needs to include the attribute. <para></para> Documentation: <see href="https://kybernetik.com.au/animancer/docs/manual/transitions">Transitions</see> </remarks> https://kybernetik.com.au/animancer/api/Animancer/Transition_1 <summary>[<see cref="SerializeField"/>] The amount of time the transition will take (in seconds).</summary> <exception cref="ArgumentOutOfRangeException">Thrown when setting the value to a negative number.</exception> <summary>[<see cref="ITransitionDetailed"/>] Indicates what the value of <see cref="AnimancerState.IsLooping"/> will be for the created state. Returns false unless overridden. </summary> <summary>[<see cref="ITransitionDetailed"/>] Determines what <see cref="NormalizedTime"/> to start the animation at. Returns <see cref="float.NaN"/> unless overridden. </summary> <summary>[<see cref="ITransitionDetailed"/>] Determines how fast the animation plays (1x = normal speed). Returns 1 unless overridden. </summary> <summary>[<see cref="ITransitionDetailed"/>] The maximum amount of time the animation is expected to take (in seconds). </summary> <remarks>The actual duration can vary in states like <see cref="MixerState"/>.</remarks> <summary>[<see cref="ITransitionDetailed"/>] The <see cref="Motion.averageAngularSpeed"/> that the created state will have. </summary> <remarks>The actual average velocity can vary in states like <see cref="MixerState"/>.</remarks> <summary>[<see cref="ITransitionDetailed"/>] The <see cref="Motion.averageSpeed"/> that the created state will have. </summary> <remarks>The actual average velocity can vary in states like <see cref="MixerState"/>.</remarks> <summary>[<see cref="SerializeField"/>] [<see cref="ITransitionDetailed"/>] Events which will be triggered as the animation plays. </summary> <remarks>This property returns the <see cref="AnimancerEvent.Sequence.Serializable.Sequence"/>.</remarks> <summary>[<see cref="SerializeField"/>] [<see cref="ITransitionDetailed"/>] Events which will be triggered as the animation plays. </summary> <summary> The state that was created by this object. Specifically, this is the state that was most recently passed into <see cref="Apply"/> (usually by <see cref="AnimancerPlayable.Play(ITransition)"/>). <para></para> You can use <see cref="AnimancerPlayable.StateDictionary.GetOrCreate(ITransition)"/> or <see cref="AnimancerLayer.GetOrCreateState(ITransition)"/> to get or create the state for a specific object. <para></para> <see cref="State"/> is simply a shorthand for casting this to <typeparamref name="TState"/>. </summary> <summary> The state that was created by this object. Specifically, this is the state that was most recently passed into <see cref="Apply"/> (usually by <see cref="AnimancerPlayable.Play(ITransition)"/>). </summary> <remarks> You can use <see cref="AnimancerPlayable.StateDictionary.GetOrCreate(ITransition)"/> or <see cref="AnimancerLayer.GetOrCreateState(ITransition)"/> to get or create the state for a specific object. <para></para> This property is shorthand for casting the <see cref="BaseState"/> to <typeparamref name="TState"/>. </remarks> <exception cref="InvalidCastException"> The <see cref="BaseState"/> is not actually a <typeparamref name="TState"/>. This should only happen if a different type of state was created by something else and registered using the <see cref="Key"/>, causing this <see cref="AnimancerPlayable.Play(ITransition)"/> to pass that state into <see cref="Apply"/> instead of calling <see cref="CreateState"/> to make the correct type of state. </exception> <summary>Indicates whether this transition can create a valid <see cref="AnimancerState"/>.</summary> <summary>The <see cref="AnimancerState.Key"/> which the created state will be registered with.</summary> <remarks>Returns <c>this</c> unless overridden.</remarks> <summary> When a transition is passed into <see cref="AnimancerPlayable.Play(ITransition)"/>, this property determines which <see cref="Animancer.FadeMode"/> will be used. </summary> <summary>Creates and returns a new <typeparamref name="TState"/>.</summary> <remarks> Note that using methods like <see cref="AnimancerPlayable.Play(ITransition)"/> will also call <see cref="Apply"/>, so if you call this method manually you may want to call that method as well. Or you can just use <see cref="AnimancerUtilities.CreateStateAndApply"/>. </remarks> <summary>Creates and returns a new <typeparamref name="TState"/>.</summary> <remarks> Note that using methods like <see cref="AnimancerPlayable.Play(ITransition)"/> will also call <see cref="Apply"/>, so if you call this method manually you may want to call that method as well. Or you can just use <see cref="AnimancerUtilities.CreateStateAndApply"/>. </remarks> <summary>[<see cref="ITransition"/>] Sets the <see cref="BaseState"/> and applies any other modifications to the `state`. </summary> <remarks> Called by <see cref="AnimancerPlayable.Play(ITransition)"/>. <para></para> This method also clears the <see cref="State"/> if necessary, so it will re-cast the <see cref="BaseState"/> when it gets accessed again. </remarks> <summary>The <see cref="AnimancerState.MainObject"/> that the created state will have.</summary> <summary>The display name of this transition.</summary> <summary>Returns the <see cref="Name"/> and type of this transition.</summary> <summary>[Editor-Only] Don't use Inspector Gadgets Nested Object Drawers.</summary>
- <summary>Connects this state to the `parent` mixer at the specified `index`.</summary> <remarks> Use <see cref="AnimancerLayer.AddChild(AnimancerState)"/> instead of this method to connect a state to an available port on a layer. </remarks>
- <summary> The state that was created by this object. Specifically, this is the state that was most recently passed into <see cref="Apply"/> (usually by <see cref="AnimancerPlayable.Play(ITransition)"/>). <para></para> You can use <see cref="AnimancerPlayable.StateDictionary.GetOrCreate(ITransition)"/> or <see cref="AnimancerLayer.GetOrCreateState(ITransition)"/> to get or create the state for a specific object. <para></para> <see cref="State"/> is simply a shorthand for casting this to <typeparamref name="TState"/>. </summary>
- <summary>[<see cref="SerializeField"/>] The amount of time the transition will take (in seconds).</summary> <exception cref="ArgumentOutOfRangeException">Thrown when setting the value to a negative number.</exception> <summary>[<see cref="ITransitionDetailed"/>] Indicates what the value of <see cref="AnimancerState.IsLooping"/> will be for the created state. Returns false unless overridden. </summary> <summary>[<see cref="ITransitionDetailed"/>] Determines what <see cref="NormalizedTime"/> to start the animation at. Returns <see cref="float.NaN"/> unless overridden. </summary> <summary>[<see cref="ITransitionDetailed"/>] Determines how fast the animation plays (1x = normal speed). Returns 1 unless overridden. </summary> <summary>[<see cref="ITransitionDetailed"/>] The maximum amount of time the animation is expected to take (in seconds). </summary> <remarks>The actual duration can vary in states like <see cref="MixerState"/>.</remarks> <summary>[<see cref="ITransitionDetailed"/>] The <see cref="Motion.averageAngularSpeed"/> that the created state will have. </summary> <remarks>The actual average velocity can vary in states like <see cref="MixerState"/>.</remarks> <summary>[<see cref="ITransitionDetailed"/>] The <see cref="Motion.averageSpeed"/> that the created state will have. </summary> <remarks>The actual average velocity can vary in states like <see cref="MixerState"/>.</remarks> <summary>[<see cref="SerializeField"/>] [<see cref="ITransitionDetailed"/>] Events which will be triggered as the animation plays. </summary> <remarks>This property returns the <see cref="AnimancerEvent.Sequence.Serializable.Sequence"/>.</remarks> <summary>[<see cref="SerializeField"/>] [<see cref="ITransitionDetailed"/>] Events which will be triggered as the animation plays. </summary> <summary> The state that was created by this object. Specifically, this is the state that was most recently passed into <see cref="Apply"/> (usually by <see cref="AnimancerPlayable.Play(ITransition)"/>). <para></para> You can use <see cref="AnimancerPlayable.StateDictionary.GetOrCreate(ITransition)"/> or <see cref="AnimancerLayer.GetOrCreateState(ITransition)"/> to get or create the state for a specific object. <para></para> <see cref="State"/> is simply a shorthand for casting this to <typeparamref name="TState"/>. </summary> <summary> The state that was created by this object. Specifically, this is the state that was most recently passed into <see cref="Apply"/> (usually by <see cref="AnimancerPlayable.Play(ITransition)"/>). </summary> <remarks> You can use <see cref="AnimancerPlayable.StateDictionary.GetOrCreate(ITransition)"/> or <see cref="AnimancerLayer.GetOrCreateState(ITransition)"/> to get or create the state for a specific object. <para></para> This property is shorthand for casting the <see cref="BaseState"/> to <typeparamref name="TState"/>. </remarks> <exception cref="InvalidCastException"> The <see cref="BaseState"/> is not actually a <typeparamref name="TState"/>. This should only happen if a different type of state was created by something else and registered using the <see cref="Key"/>, causing this <see cref="AnimancerPlayable.Play(ITransition)"/> to pass that state into <see cref="Apply"/> instead of calling <see cref="CreateState"/> to make the correct type of state. </exception> <summary>Indicates whether this transition can create a valid <see cref="AnimancerState"/>.</summary> <summary>The <see cref="AnimancerState.Key"/> which the created state will be registered with.</summary> <remarks>Returns <c>this</c> unless overridden.</remarks> <summary> When a transition is passed into <see cref="AnimancerPlayable.Play(ITransition)"/>, this property determines which <see cref="Animancer.FadeMode"/> will be used. </summary> <summary>Creates and returns a new <typeparamref name="TState"/>.</summary> <remarks> Note that using methods like <see cref="AnimancerPlayable.Play(ITransition)"/> will also call <see cref="Apply"/>, so if you call this method manually you may want to call that method as well. Or you can just use <see cref="AnimancerUtilities.CreateStateAndApply"/>. </remarks> <summary>Creates and returns a new <typeparamref name="TState"/>.</summary> <remarks> Note that using methods like <see cref="AnimancerPlayable.Play(ITransition)"/> will also call <see cref="Apply"/>, so if you call this method manually you may want to call that method as well. Or you can just use <see cref="AnimancerUtilities.CreateStateAndApply"/>. </remarks> <summary>[<see cref="ITransition"/>] Sets the <see cref="BaseState"/> and applies any other modifications to the `state`. </summary> <remarks> Called by <see cref="AnimancerPlayable.Play(ITransition)"/>. <para></para> This method also clears the <see cref="State"/> if necessary, so it will re-cast the <see cref="BaseState"/> when it gets accessed again. </remarks> <summary>The <see cref="AnimancerState.MainObject"/> that the created state will have.</summary> <summary>The display name of this transition.</summary> <summary>Returns the <see cref="Name"/> and type of this transition.</summary> <summary>[Editor-Only] Don't use Inspector Gadgets Nested Object Drawers.</summary>
- <summary>[<see cref="SerializeField"/>] [<see cref="ITransitionDetailed"/>] Events which will be triggered as the animation plays. </summary> <remarks>This property returns the <see cref="AnimancerEvent.Sequence.Serializable.Sequence"/>.</remarks> <summary>[<see cref="SerializeField"/>] [<see cref="ITransitionDetailed"/>] Events which will be triggered as the animation plays. </summary> <summary> The state that was created by this object. Specifically, this is the state that was most recently passed into <see cref="Apply"/> (usually by <see cref="AnimancerPlayable.Play(ITransition)"/>). <para></para> You can use <see cref="AnimancerPlayable.StateDictionary.GetOrCreate(ITransition)"/> or <see cref="AnimancerLayer.GetOrCreateState(ITransition)"/> to get or create the state for a specific object. <para></para> <see cref="State"/> is simply a shorthand for casting this to <typeparamref name="TState"/>. </summary>
- <summary>[<see cref="SerializeField"/>] The amount of time the transition will take (in seconds).</summary> <exception cref="ArgumentOutOfRangeException">Thrown when setting the value to a negative number.</exception>
- <summary>Has <see cref="_IsPlaying"/> changed since it was last applied to the <see cref="Playable"/>.</summary> <remarks> Playables start playing by default so we start dirty to pause it during the first update (unless <see cref="IsPlaying"/> is set to true before that). </remarks> <summary>Is the <see cref="Time"/> automatically advancing?</summary> <example><code> void IsPlayingExample(AnimancerComponent animancer, AnimationClip clip) { var state = animancer.States.GetOrCreate(clip); if (state.IsPlaying) Debug.Log(clip + " is playing"); else Debug.Log(clip + " is paused"); state.IsPlaying = false;// Pause the animation. state.IsPlaying = true;// Unpause the animation. }
- <summary>Is the <see cref="Time"/> automatically advancing?</summary> <example><code> void IsPlayingExample(AnimancerComponent animancer, AnimationClip clip) { var state = animancer.States.GetOrCreate(clip); if (state.IsPlaying) Debug.Log(clip + " is playing"); else Debug.Log(clip + " is paused"); state.IsPlaying = false;// Pause the animation. state.IsPlaying = true;// Unpause the animation. }
- <summary> The object used to identify this state in the root <see cref="AnimancerPlayable.States"/> dictionary. Can be null. </summary>
- <summary> The <see cref="AnimancerPlayable.FrameID"/> from when the <see cref="Time"/> was last retrieved from the <see cref="Playable"/>. </summary> <summary>The number of seconds that have passed since the start of this animation.</summary> <remarks> This value will continue increasing after the animation passes the end of its <see cref="Length"/> while the animated object either freezes in place or starts again from the beginning according to whether it is looping or not. <para></para> This property internally uses <see cref="RawTime"/> whenever the value is out of date or gets changed. <para></para> <em>Animancer Lite does not allow this value to be changed in runtime builds (except resetting it to 0).</em> </remarks> <example><code> void PlayAnimation(AnimancerComponent animancer, AnimationClip clip) { var state = animancer.Play(clip); // Skip 0.5 seconds into the animation: state.Time = 0.5f; // Skip 50% of the way through the animation (0.5 in a range of 0 to 1): state.NormalizedTime = 0.5f; // Skip to the end of the animation and play backwards. state.NormalizedTime = 1; state.Speed = -1; }
- <summary>Connects this state to the `parent` mixer at the specified `index`.</summary> <remarks> Use <see cref="AnimancerLayer.AddChild(AnimancerState)"/> instead of this method to connect a state to an available port on a layer. </remarks>
- <summary> The state that was created by this object. Specifically, this is the state that was most recently passed into <see cref="Apply"/> (usually by <see cref="AnimancerPlayable.Play(ITransition)"/>). </summary> <remarks> You can use <see cref="AnimancerPlayable.StateDictionary.GetOrCreate(ITransition)"/> or <see cref="AnimancerLayer.GetOrCreateState(ITransition)"/> to get or create the state for a specific object. <para></para> This property is shorthand for casting the <see cref="BaseState"/> to <typeparamref name="TState"/>. </remarks> <exception cref="InvalidCastException"> The <see cref="BaseState"/> is not actually a <typeparamref name="TState"/>. This should only happen if a different type of state was created by something else and registered using the <see cref="Key"/>, causing this <see cref="AnimancerPlayable.Play(ITransition)"/> to pass that state into <see cref="Apply"/> instead of calling <see cref="CreateState"/> to make the correct type of state. </exception>
- <summary> Indicates whether the <see cref="_Time"/> needs to be assigned to the <see cref="Playable"/> next update. </summary> <remarks> <see cref="EventDispatcher"/> executes after all other playables, at which point changes can still be made to their time but not their weight which means that if we set the time immediately then it can be out of sync with the weight. For example, if an animation ends and you play another, the first animation would be stopped and rewinded to the start but would still be at full weight so it would show its first frame before the new animation actually takes effect (even if the previous animation was not looping). <para></para> So instead, we simply delay setting the actual playable time until the next update so that time and weight are always in sync. </remarks> <summary> The <see cref="AnimancerPlayable.FrameID"/> from when the <see cref="Time"/> was last retrieved from the <see cref="Playable"/>. </summary> <summary>The number of seconds that have passed since the start of this animation.</summary> <remarks> This value will continue increasing after the animation passes the end of its <see cref="Length"/> while the animated object either freezes in place or starts again from the beginning according to whether it is looping or not. <para></para> This property internally uses <see cref="RawTime"/> whenever the value is out of date or gets changed. <para></para> <em>Animancer Lite does not allow this value to be changed in runtime builds (except resetting it to 0).</em> </remarks> <example><code> void PlayAnimation(AnimancerComponent animancer, AnimationClip clip) { var state = animancer.Play(clip); // Skip 0.5 seconds into the animation: state.Time = 0.5f; // Skip 50% of the way through the animation (0.5 in a range of 0 to 1): state.NormalizedTime = 0.5f; // Skip to the end of the animation and play backwards. state.NormalizedTime = 1; state.Speed = -1; }
- <summary>The number of seconds that have passed since the start of this animation.</summary> <remarks> This value will continue increasing after the animation passes the end of its <see cref="Length"/> while the animated object either freezes in place or starts again from the beginning according to whether it is looping or not. <para></para> This property internally uses <see cref="RawTime"/> whenever the value is out of date or gets changed. <para></para> <em>Animancer Lite does not allow this value to be changed in runtime builds (except resetting it to 0).</em> </remarks> <example><code> void PlayAnimation(AnimancerComponent animancer, AnimationClip clip) { var state = animancer.Play(clip); // Skip 0.5 seconds into the animation: state.Time = 0.5f; // Skip 50% of the way through the animation (0.5 in a range of 0 to 1): state.NormalizedTime = 0.5f; // Skip to the end of the animation and play backwards. state.NormalizedTime = 1; state.Speed = -1; }
2024-12-17 11:13:03,518 - INFO Retriever 0 - 

————————————————————————————————————————————————————————————————
2024-12-17 11:13:03,518 - INFO Retriever 0 - 当前窗口总长度：15
2024-12-17 11:13:03,518 - INFO Retriever 0 - 当前更新窗口长度：6
2024-12-17 11:13:03,518 - INFO Retriever 0 - 当前更新窗口长度：6
2024-12-17 11:13:03,519 - INFO Retriever 0 - ————————————————————————————————————————————————————————————————


2024-12-17 11:13:19,496 - INFO Retriever 0 - Agent主脑给出的回答为：根据文件三（AnimancerState.cs）的内容，该脚本负责动画状态管理，包括动画的播放控制、时间管理以及与动画图（Graph）的交互。了解动画状态管理机制有助于分析如何修改动画状态以实现固定战斗动画。接下来，我将使用read_long_details操作，读取文件三的细节内容，以获取更详细的动画状态管理信息。
2024-12-17 11:13:19,496 - INFO Retriever 0 - 是否成功解析：True
2024-12-17 11:13:19,496 - INFO Retriever 0 - operation_type (__det_dir_action):
2024-12-17 11:13:19,497 - INFO Retriever 0 - 根据文件三（AnimancerState.cs）的内容，该脚本负责动画状态管理，包括动画的播放控制、时间管理以及与动画图（Graph）的交互。了解动画状态管理机制有助于分析如何修改动画状态以实现固定战斗动画。接下来，我将使用read_long_details操作，读取文件三的细节内容，以获取更详细的动画状态管理信息。
2024-12-17 11:13:19,497 - INFO Retriever 0 - 

——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
2024-12-17 11:13:19,497 - INFO Retriever 0 - Assistant:
2024-12-17 11:13:19,497 - INFO Retriever 0 - {
  "根据文件三（AnimancerState.cs）的内容，该脚本负责动画状态管理，包括动画的播放控制、时间管理以及与动画图（Graph）的交互。了解动画状态管理机制有助于分析如何修改动画状态以实现固定战斗动画。接下来，我将使用read_long_details操作，读取文件三的细节内容，以获取更详细的动画状态管理信息。": ""
}
2024-12-17 11:13:19,497 - INFO Retriever 0 - dict_keys(['根据文件三（AnimancerState.cs）的内容，该脚本负责动画状态管理，包括动画的播放控制、时间管理以及与动画图（Graph）的交互。了解动画状态管理机制有助于分析如何修改动画状态以实现固定战斗动画。接下来，我将使用read_long_details操作，读取文件三的细节内容，以获取更详细的动画状态管理信息。'])
2024-12-17 11:13:19,498 - WARNING Retriever 0 - 你给出的操作类型不属于指定的操作类型。可以进行的操作类型有：['get_folder_info', 'read_file', 'read_long_details', 'retrieve_keywords', 'deep_think']，请重新给出你的操作。
2024-12-17 11:13:19,500 - INFO Retriever 0 - 

————————————————————————————————————————————————————————————————
2024-12-17 11:13:19,500 - INFO Retriever 0 - 当前窗口总长度：17
2024-12-17 11:13:19,500 - INFO Retriever 0 - 当前更新窗口长度：8
2024-12-17 11:13:19,501 - INFO Retriever 0 - 当前更新窗口长度：8
2024-12-17 11:13:19,501 - INFO Retriever 0 - ————————————————————————————————————————————————————————————————


2024-12-17 11:13:29,811 - INFO Retriever 0 - Agent主脑给出的回答为：{
    "deep_think": {
        "thoughts": "根据文件三（AnimancerState.cs）的内容，该脚本负责动画状态管理，包括动画的播放控制、时间管理以及与动画图（Graph）的交互。了解动画状态管理机制有助于分析如何修改动画状态以实现固定战斗动画。接下来，我将使用read_long_details操作，读取文件三的细节内容，以获取更详细的动画状态管理信息。"
    }
}
2024-12-17 11:13:29,812 - INFO Retriever 0 - 是否成功解析：True
2024-12-17 11:13:29,812 - INFO Retriever 0 - operation_type (__det_dir_action):
2024-12-17 11:13:29,812 - INFO Retriever 0 - deep_think
2024-12-17 11:13:29,813 - INFO Retriever 0 - 

——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
2024-12-17 11:13:29,813 - INFO Retriever 0 - Assistant:
2024-12-17 11:13:29,813 - INFO Retriever 0 - {
    "deep_think": {
        "thoughts": "根据文件三（AnimancerState.cs）的内容，该脚本负责动画状态管理，包括动画的播放控制、时间管理以及与动画图（Graph）的交互。了解动画状态管理机制有助于分析如何修改动画状态以实现固定战斗动画。接下来，我将使用read_long_details操作，读取文件三的细节内容，以获取更详细的动画状态管理信息。"
    }
}
2024-12-17 11:13:29,813 - INFO Retriever 0 - dict_keys(['deep_think'])
2024-12-17 11:13:29,813 - INFO Retriever 0 - Agent主脑给出的行动：deep_think
参数：{'thoughts': '根据文件三（AnimancerState.cs）的内容，该脚本负责动画状态管理，包括动画的播放控制、时间管理以及与动画图（Graph）的交互。了解动画状态管理机制有助于分析如何修改动画状态以实现固定战斗动画。接下来，我将使用read_long_details操作，读取文件三的细节内容，以获取更详细的动画状态管理信息。', 'repeat_counter': 1, 'continue_think_counter': 1}
2024-12-17 11:13:29,814 - INFO Retriever 0 - Observer: 好的，请继续你的下一步行动或思考。
2024-12-17 11:13:29,815 - INFO Retriever 0 - 

————————————————————————————————————————————————————————————————
2024-12-17 11:13:29,816 - INFO Retriever 0 - 当前窗口总长度：19
2024-12-17 11:13:29,816 - INFO Retriever 0 - 当前更新窗口长度：10
2024-12-17 11:13:29,816 - INFO Retriever 0 - 当前更新窗口长度：10
2024-12-17 11:13:29,816 - INFO Retriever 0 - ————————————————————————————————————————————————————————————————


2024-12-17 11:13:38,834 - INFO Retriever 0 - Agent主脑给出的回答为：{
    "read_long_details": {
        "file_path": "D:/Unity/jyx2\\Assets\\3rd\\Animancer\\Internal\\Core\\AnimancerState.cs"
    }
}
2024-12-17 11:13:38,835 - INFO Retriever 0 - 是否成功解析：True
2024-12-17 11:13:38,835 - INFO Retriever 0 - operation_type (__det_dir_action):
2024-12-17 11:13:38,835 - INFO Retriever 0 - read_long_details
2024-12-17 11:13:38,836 - INFO Retriever 0 - 

——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
2024-12-17 11:13:38,836 - INFO Retriever 0 - Assistant:
2024-12-17 11:13:38,836 - INFO Retriever 0 - {
    "read_long_details": {
        "file_path": "D:/Unity/jyx2\\Assets\\3rd\\Animancer\\Internal\\Core\\AnimancerState.cs"
    }
}
2024-12-17 11:13:38,836 - INFO Retriever 0 - dict_keys(['read_long_details'])
2024-12-17 11:13:38,836 - INFO Retriever 0 - Agent主脑给出的行动：read_long_details
参数：{'file_path': 'D:/Unity/jyx2\\Assets\\3rd\\Animancer\\Internal\\Core\\AnimancerState.cs', 'top_path': 'D:/Unity/jyx2\\Assets', 'return_file_sum': <bound method TreeGenerationAction.return_file_sum of <Action.tree_gen_action.TreeGenerationAction object at 0x0000027D71AB0D90>>}
2024-12-17 11:13:38,838 - INFO Retriever 0 - Observer: 这是一个名为“AnimancerState.cs”的文件，该文件里的内容为：
   1|// Animancer // https://kybernetik.com.au/animancer // Copyright 2021 Kybernetik //
   2|
   3|using System;
   4|using System.Collections;
   5|using System.Collections.Generic;
   6|using System.Text;
   7|using UnityEngine;
   8|using UnityEngine.Playables;
   9|using Object = UnityEngine.Object;
  10|
  11|#if UNITY_EDITOR
  12|using UnityEditor;
  13|using Animancer.Editor;
  14|#endif
  15|
  16|namespace Animancer
  17|{
  18|    /// <summary>
  19|    /// Base class for all states in an <see cref="AnimancerPlayable"/> graph which manages one or more
  20|    /// <see cref="Playable"/>s.
  21|    /// </summary>
  22|    /// 
  23|    /// <remarks>
  24|    /// This class can be used as a custom yield instruction to wait until the animation either stops playing or
  25|    /// reaches its end.
  26|    /// <para></para>
  27|    /// Documentation: <see href="https://kybernetik.com.au/animancer/docs/manual/playing/states">States</see>
  28|    /// </remarks>
  29|    /// https://kybernetik.com.au/animancer/api/Animancer/AnimancerState
  30|    /// 
  31|    public abstract partial class AnimancerState : AnimancerNode, IAnimationClipCollection
  32|    {
  33|        /************************************************************************************************************************/
  34|        #region Graph
  35|        /************************************************************************************************************************/
  36|
  37|        /// <summary>The <see cref="AnimancerPlayable"/> at the root of the graph.</summary>
  38|        public void SetRoot(AnimancerPlayable root)
  39|        {
  40|            if (Root == root)
  41|                return;
  42|
  43|            if (Root != null)
  44|            {
  45|                Root.CancelUpdate(this);
  46|                Root.States.Unregister(this);
  47|
  48|                if (_Parent != null)
  49|                {
  50|                    _Parent.OnRemoveChild(this);
  51|                    _Parent = null;
  52|                }
  53|
  54|                Index = -1;
  55|
  56|                DestroyPlayable();
  57|            }
  58|
  59|            Root = root;
  60|
  61|            if (root != null)
  62|            {
  63|                root.States.Register(_Key, this);
  64|                CreatePlayable();
  65|            }
  66|
  67|            for (int i = ChildCount - 1; i >= 0; i--)
  68|                GetChild(i)?.SetRoot(root);
  69|
  70|            if (_Parent != null)
  71|                CopyIKFlags(_Parent);
  72|        }
  73|
  74|        /************************************************************************************************************************/
  75|
  76|        /// <summary>The object which receives the output of the <see cref="Playable"/>.</summary>
  77|        public sealed override IPlayableWrapper Parent => _Parent;
  78|        private AnimancerNode _Parent;
  79|
  80|        /// <summary>Connects this state to the `parent` mixer at the specified `index`.</summary>
  81|        /// <remarks>
  82|        /// Use <see cref="AnimancerLayer.AddChild(AnimancerState)"/> instead of this method to connect a state to an
  83|        /// available port on a layer.
  84|        /// </remarks>
  85|        public void SetParent(AnimancerNode parent, int index)
  86|        {
  87|            if (_Parent != null)
  88|            {
  89|                _Parent.OnRemoveChild(this);
  90|                _Parent = null;
  91|            }
  92|
  93|            if (parent == null)
  94|            {
  95|                Index = -1;
  96|                return;
  97|            }
  98|
  99|            SetRoot(parent.Root);
 100|            Index = index;
 101|            _Parent = parent;
 102|            parent.OnAddChild(this);
 103|            CopyIKFlags(parent);
 104|        }
 105|
 106|        /// <summary>[Internal]
 107|        /// Called by <see cref="AnimancerNode.OnAddChild(IList{AnimancerState}, AnimancerState)"/> if the specified
 108|        /// port is already occupied so it can be cleared without triggering any other calls.
 109|        /// </summary>
 110|        internal void ClearParent()
 111|        {
 112|            Index = -1;
 113|            _Parent = null;
 114|        }
 115|
 116|        /************************************************************************************************************************/
 117|
 118|        /// <summary>
 119|        /// The <see cref="AnimancerNode.Weight"/> of this state multiplied by the <see cref="AnimancerNode.Weight"/> of each of
 120|        /// its parents down the hierarchy to determine how much this state affects the final output.
 121|        /// </summary>
 122|        /// <exception cref="NullReferenceException">This state has no <see cref="AnimancerNode.Parent"/>.</exception>
 123|        public float EffectiveWeight
 124|        {
 125|            get
 126|            {
 127|                var weight = Weight;
 128|
 129|                var parent = _Parent;
 130|                while (parent != null)
 131|                {
 132|                    weight *= parent.Weight;
 133|                    parent = parent.Parent as AnimancerNode;
 134|                }
 135|
 136|                return weight;
 137|            }
 138|        }
 139|
 140|        /************************************************************************************************************************/
 141|        // Layer.
 142|        /************************************************************************************************************************/
 143|
 144|        /// <inheritdoc/>
 145|        public override AnimancerLayer Layer => _Parent?.Layer;
 146|
 147|        /// <summary>
 148|        /// The index of the <see cref="AnimancerLayer"/> this state is connected to (determined by the
 149|        /// <see cref="Parent"/>).
 150|        /// </summary>
 151|        public int LayerIndex
 152|        {
 153|            get
 154|            {
 155|                if (_Parent == null)
 156|                    return -1;
 157|
 158|                var layer = _Parent.Layer;
 159|                if (layer == null)
 160|                    return -1;
 161|
 162|                return layer.Index;
 163|            }
 164|            set
 165|            {
 166|                Root.Layers[value].AddChild(this);
 167|            }
 168|        }
 169|
 170|        /************************************************************************************************************************/
 171|        #endregion
 172|        /************************************************************************************************************************/
 173|        #region Key and Clip
 174|        /************************************************************************************************************************/
 175|
 176|        internal object _Key;
 177|
 178|        /// <summary>
 179|        /// The object used to identify this state in the root <see cref="AnimancerPlayable.States"/> dictionary.
 180|        /// Can be null.
 181|        /// </summary>
 182|        public object Key
 183|        {
 184|            get => _Key;
 185|            set
 186|            {
 187|                Root.States.Unregister(this);
 188|                Root.States.Register(value, this);
 189|            }
 190|        }
 191|
 192|        /************************************************************************************************************************/
 193|
 194|        /// <summary>The <see cref="AnimationClip"/> which this state plays (if any).</summary>
 195|        /// <exception cref="NotSupportedException">This state type doesn't have a clip and you try to set it.</exception>
 196|        public virtual AnimationClip Clip
 197|        {
 198|            get => null;
 199|            set => throw new NotSupportedException($"{GetType()} does not support setting the {nameof(Clip)}.");
 200|        }
 201|
 202|        /// <summary>The main object to show in the Inspector for this state (if any).</summary>
 203|        /// <exception cref="NotSupportedException">This state type doesn't have a main object and you try to set it.</exception>
 204|        /// <exception cref="InvalidCastException">This state can't use the assigned value.</exception>
 205|        public virtual Object MainObject
 206|        {
 207|            get => null;
 208|            set => throw new NotSupportedException($"{GetType()} does not support setting the {nameof(MainObject)}.");
 209|        }
 210|
 211|        /************************************************************************************************************************/
 212|
 213|        /// <summary>
 214|        /// Sets the `currentObject` and calls <see cref="AnimancerNode.RecreatePlayable"/>. If the `currentObject` was
 215|        /// being used as the <see cref="Key"/> then it is changed as well.
 216|        /// </summary>
 217|        /// <exception cref="ArgumentNullException">The `newObject` is null.</exception>
 218|        protected void ChangeMainObject<T>(ref T currentObject, T newObject) where T : Object
 219|        {
 220|            if (newObject == null)
 221|                throw new ArgumentNullException(nameof(newObject));
 222|
 223|            if (ReferenceEquals(currentObject, newObject))
 224|                return;
 225|
 226|            if (ReferenceEquals(_Key, currentObject))
 227|                Key = newObject;
 228|
 229|            currentObject = newObject;
 230|            RecreatePlayable();
 231|        }
 232|
 233|        /************************************************************************************************************************/
 234|
 235|        /// <summary>The average velocity of the root motion caused by this state.</summary>
 236|        public virtual Vector3 AverageVelocity => default;
 237|
 238|        /************************************************************************************************************************/
 239|        #endregion
 240|        /************************************************************************************************************************/
 241|        #region Playing
 242|        /************************************************************************************************************************/
 243|
 244|        /// <summary>Is the <see cref="Time"/> automatically advancing?</summary>
 245|        private bool _IsPlaying;
 246|
 247|        /// <summary>Has <see cref="_IsPlaying"/> changed since it was last applied to the <see cref="Playable"/>.</summary>
 248|        /// <remarks>
 249|        /// Playables start playing by default so we start dirty to pause it during the first update (unless
 250|        /// <see cref="IsPlaying"/> is set to true before that).
 251|        /// </remarks>
 252|        private bool _IsPlayingDirty = true;
 253|
 254|        /************************************************************************************************************************/
 255|
 256|        /// <summary>Is the <see cref="Time"/> automatically advancing?</summary>
 257|        ///
 258|        /// <example><code>
 259|        /// void IsPlayingExample(AnimancerComponent animancer, AnimationClip clip)
 260|        /// {
 261|        ///     var state = animancer.States.GetOrCreate(clip);
 262|        ///
 263|        ///     if (state.IsPlaying)
 264|        ///         Debug.Log(clip + " is playing");
 265|        ///     else
 266|        ///         Debug.Log(clip + " is paused");
 267|        ///
 268|        ///     state.IsPlaying = false;// Pause the animation.
 269|        ///
 270|        ///     state.IsPlaying = true;// Unpause the animation.
 271|        /// }
 272|        /// </code></example>
 273|        public bool IsPlaying
 274|        {
 275|            get => _IsPlaying;
 276|            set
 277|            {
 278|                if (_IsPlaying == value)
 279|                    return;
 280|
 281|                _IsPlaying = value;
 282|
 283|                // If it was already dirty then we just returned to the previous state so it is no longer dirty.
 284|                if (_IsPlayingDirty)
 285|                {
 286|                    _IsPlayingDirty = false;
 287|                    // We may still need to be updated for other reasons (such as Weight),
 288|                    // but if not then we will be removed from the update list next update.
 289|                }
 290|                else// Otherwise we are now dirty so we need to be updated.
 291|                {
 292|                    _IsPlayingDirty = true;
 293|                    RequireUpdate();
 294|                }
 295|
 296|                OnSetIsPlaying();
 297|            }
 298|        }
 299|
 300|        /// <summary>Called when the value of <see cref="IsPlaying"/> is changed.</summary>
 301|        protected virtual void OnSetIsPlaying() { }
 302|
 303|        /// <summary>Creates and assigns the <see cref="Playable"/> managed by this state.</summary>
 304|        /// <remarks>This method also applies the <see cref="AnimancerNode.Speed"/> and <see cref="IsPlaying"/>.</remarks>
 305|        public sealed override void CreatePlayable()
 306|        {
 307|            base.CreatePlayable();
 308|
 309|            if (!_IsPlaying)
 310|                _Playable.Pause();
 311|            _IsPlayingDirty = false;
 312|        }
 313|
 314|        /************************************************************************************************************************/
 315|
 316|        /// <summary>
 317|        /// Returns true if this state is playing and is at or fading towards a non-zero
 318|        /// <see cref="AnimancerNode.Weight"/>.
 319|        /// </summary>
 320|        public bool IsActive => _IsPlaying && TargetWeight > 0;
 321|
 322|        /// <summary>
 323|        /// Returns true if this state is not playing and is at 0 <see cref="AnimancerNode.Weight"/>.
 324|        /// </summary>
 325|        public bool IsStopped => !_IsPlaying && Weight == 0;
 326|
 327|        /************************************************************************************************************************/
 328|
 329|        /// <summary>Plays this state immediately, without any blending.</summary>
 330|        /// <remarks>
 331|        /// Sets <see cref="IsPlaying"/> = true, <see cref="AnimancerNode.Weight"/> = 1, and clears the
 332|        /// <see cref="Events"/> (unless <see cref="AutomaticallyClearEvents"/> is disabled).
 333|        /// <para></para>
 334|        /// This method does not change the <see cref="Time"/> so it will continue from its current value.
 335|        /// </remarks>
 336|        public void Play()
 337|        {
 338|            IsPlaying = true;
 339|            Weight = 1;
 340|            if (AutomaticallyClearEvents)
 341|                EventDispatcher.TryClear(_EventRunner);
 342|        }
 343|
 344|        /************************************************************************************************************************/
 345|
 346|        /// <summary>Stops the animation and makes it inactive immediately so it no longer affects the output.</summary>
 347|        /// <remarks>
 348|        /// Sets <see cref="AnimancerNode.Weight"/> = 0, <see cref="IsPlaying"/> = false, <see cref="Time"/> = 0, and
 349|        /// clears the <see cref="Events"/> (unless <see cref="AutomaticallyClearEvents"/> is disabled).
 350|        /// <para></para>
 351|        /// To freeze the animation in place without ending it, you only need to set <see cref="IsPlaying"/> = false
 352|        /// instead. Or to freeze all animations, you can call <see cref="AnimancerPlayable.PauseGraph"/>.
 353|        /// </remarks>
 354|        public override void Stop()
 355|        {
 356|            base.Stop();
 357|
 358|            IsPlaying = false;
 359|            Time = 0;
 360|            if (AutomaticallyClearEvents)
 361|                EventDispatcher.TryClear(_EventRunner);
 362|        }
 363|
 364|        /************************************************************************************************************************/
 365|
 366|        /// <summary>
 367|        /// Called by <see cref="AnimancerNode.StartFade"/>.
 368|        /// Clears the <see cref="Events"/> (unless <see cref="AutomaticallyClearEvents"/> is disabled).
 369|        /// </summary>
 370|        protected internal override void OnStartFade()
 371|        {
 372|            if (AutomaticallyClearEvents)
 373|                EventDispatcher.TryClear(_EventRunner);
 374|        }
 375|
 376|        /************************************************************************************************************************/
 377|        #endregion
 378|        /************************************************************************************************************************/
 379|        #region Timing
 380|        /************************************************************************************************************************/
 381|        // Time.
 382|        /************************************************************************************************************************/
 383|
 384|        /// <summary>
 385|        /// The current time of the <see cref="Playable"/>, retrieved by <see cref="Time"/> whenever the
 386|        /// <see cref="_TimeFrameID"/> is different from the <see cref="AnimancerPlayable.FrameID"/>.
 387|        /// </summary>
 388|        private float _Time;
 389|
 390|        /// <summary>
 391|        /// Indicates whether the <see cref="_Time"/> needs to be assigned to the <see cref="Playable"/> next update.
 392|        /// </summary>
 393|        /// <remarks>
 394|        /// <see cref="EventDispatcher"/> executes after all other playables, at which point changes can still be made to
 395|        /// their time but not their weight which means that if we set the time immediately then it can be out of sync
 396|        /// with the weight. For example, if an animation ends and you play another, the first animation would be
 397|        /// stopped and rewinded to the start but would still be at full weight so it would show its first frame before
 398|        /// the new animation actually takes effect (even if the previous animation was not looping).
 399|        /// <para></para>
 400|        /// So instead, we simply delay setting the actual playable time until the next update so that time and weight
 401|        /// are always in sync.
 402|        /// </remarks>
 403|        private bool _MustSetTime;
 404|
 405|        /// <summary>
 406|        /// The <see cref="AnimancerPlayable.FrameID"/> from when the <see cref="Time"/> was last retrieved from the
 407|        /// <see cref="Playable"/>.
 408|        /// </summary>
 409|        private ulong _TimeFrameID;
 410|
 411|        /************************************************************************************************************************/
 412|
 413|        /// <summary>The number of seconds that have passed since the start of this animation.</summary>
 414|        ///
 415|        /// <remarks>
 416|        /// This value will continue increasing after the animation passes the end of its <see cref="Length"/> while
 417|        /// the animated object either freezes in place or starts again from the beginning according to whether it is
 418|        /// looping or not.
 419|        /// <para></para>
 420|        /// This property internally uses <see cref="RawTime"/> whenever the value is out of date or gets changed.
 421|        /// <para></para>
 422|        /// <em>Animancer Lite does not allow this value to be changed in runtime builds (except resetting it to 0).</em>
 423|        /// </remarks>
 424|        ///
 425|        /// <example><code>
 426|        /// void PlayAnimation(AnimancerComponent animancer, AnimationClip clip)
 427|        /// {
 428|        ///     var state = animancer.Play(clip);
 429|        ///
 430|        ///     // Skip 0.5 seconds into the animation:
 431|        ///     state.Time = 0.5f;
 432|        ///
 433|        ///     // Skip 50% of the way through the animation (0.5 in a range of 0 to 1):
 434|        ///     state.NormalizedTime = 0.5f;
 435|        ///
 436|        ///     // Skip to the end of the animation and play backwards.
 437|        ///     state.NormalizedTime = 1;
 438|        ///     state.Speed = -1;
 439|        /// }
 440|        /// </code></example>
 441|        public float Time
 442|        {
 443|            get
 444|            {
 445|                var root = Root;
 446|                if (root == null || _MustSetTime)
 447|                    return _Time;
 448|
 449|                var frameID = root.FrameID;
 450|                if (_TimeFrameID != frameID)
 451|                {
 452|                    _TimeFrameID = frameID;
 453|                    _Time = RawTime;
 454|                }
 455|
 456|                return _Time;
 457|            }
 458|            set
 459|            {
 460|#if UNITY_ASSERTIONS
 461|                if (!value.IsFinite())
 462|                    throw new ArgumentOutOfRangeException(nameof(value), value, $"{nameof(Time)} must be finite");
 463|#endif
 464|
 465|                var root = Root;
 466|                if (root != null)
 467|                    _TimeFrameID = root.FrameID;
 468|
 469|                _Time = value;
 470|
 471|                if (AnimancerPlayable.IsRunningLateUpdate(root))
 472|                {
 473|                    _MustSetTime = true;
 474|                    RequireUpdate();
 475|                }
 476|                else
 477|                {
 478|                    RawTime = value;
 479|                }
 480|
 481|                _EventRunner?.OnTimeChanged();
 482|            }
 483|        }
 484|
 485|        /************************************************************************************************************************/
 486|
 487|        /// <summary>
 488|        /// The internal implementation of <see cref="Time"/> which directly gets and sets the underlying value.
 489|        /// </summary>
 490|        /// <remarks>
 491|        /// Setting this value actually calls <see cref="PlayableExtensions.SetTime"/> twice to ensure that animation
 492|        /// events aren't triggered incorrectly. Calling it only once would trigger any animation events between the
 493|        /// previous time and the new time. So if an animation plays to the end and you set the time back to 0 (such as
 494|        /// by calling <see cref="Stop"/> or playing a different animation), the next time that animation played it
 495|        /// would immediately trigger all of its events, then play through and trigger them normally as well.
 496|        /// </remarks>
 497|        protected virtual float RawTime
 498|        {
 499|            get
 500|            {
 501|                Validate.AssertPlayable(this);
 502|                return (float)_Playable.GetTime();
 503|            }
 504|            set
 505|            {
 506|                Validate.AssertPlayable(this);
 507|                var time = (double)value;
 508|                _Playable.SetTime(time);
 509|                _Playable.SetTime(time);
 510|            }
 511|        }
 512|
 513|        /************************************************************************************************************************/
 514|
 515|        /// <summary>
 516|        /// The <see cref="Time"/> of this state as a portion of the animation's <see cref="Length"/>, meaning the
 517|        /// value goes from 0 to 1 as it plays from start to end, regardless of how long that actually takes.
 518|        /// </summary>
 519|        /// 
 520|        /// <remarks>
 521|        /// This value will continue increasing after the animation passes the end of its <see cref="Length"/> while
 522|        /// the animated object either freezes in place or starts again from the beginning according to whether it is
 523|        /// looping or not.
 524|        /// <para></para>
 525|        /// The fractional part of the value (<c>NormalizedTime % 1</c>) is the percentage (0-1) of progress in the
 526|        /// current loop while the integer part (<c>(int)NormalizedTime</c>) is the number of times the animation has
 527|        /// been looped.
 528|        /// <para></para>
 529|        /// <em>Animancer Lite does not allow this value to be changed to a value other than 0 in runtime builds.</em>
 530|        /// </remarks>
 531|        ///
 532|        /// <example><code>
 533|        /// void PlayAnimation(AnimancerComponent animancer, AnimationClip clip)
 534|        /// {
 535|        ///     var state = animancer.Play(clip);
 536|        ///
 537|        ///     // Skip 0.5 seconds into the animation:
 538|        ///     state.Time = 0.5f;
 539|        ///
 540|        ///     // Skip 50% of the way through the animation (0.5 in a range of 0 to 1):
 541|        ///     state.NormalizedTime = 0.5f;
 542|        ///
 543|        ///     // Skip to the end of the animation and play backwards.
 544|        ///     state.NormalizedTime = 1;
 545|        ///     state.Speed = -1;
 546|        /// }
 547|        /// </code></example>
 548|        public float NormalizedTime
 549|        {
 550|            get
 551|            {
 552|                var length = Length;
 553|                if (length != 0)
 554|                    return Time / Length;
 555|                else
 556|                    return 0;
 557|            }
 558|            set => Time = value * Length;
 559|        }
 560|
 561|        /************************************************************************************************************************/
 562|
 563|        /// <summary>Prevents the <see cref="RawTime"/> from being applied.</summary>
 564|        protected void CancelSetTime() => _MustSetTime = false;
 565|
 566|        /************************************************************************************************************************/
 567|        // Duration.
 568|        /************************************************************************************************************************/
 569|
 570|        /// <summary>[Pro-Only]
 571|        /// The <see cref="NormalizedTime"/> after which the <see cref="AnimancerEvent.Sequence.OnEnd"/> callback will
 572|        /// be invoked every frame.
 573|        /// </summary>
 574|        /// <remarks>
 575|        /// This is a wrapper around <see cref="AnimancerEvent.Sequence.NormalizedEndTime"/> so that if the value has
 576|        /// not been set (<see cref="float.NaN"/>) it can be determined based on the
 577|        /// <see cref="AnimancerNode.EffectiveSpeed"/>: positive speed ends at 1 and negative speed ends at 0.
 578|        /// <para></para>
 579|        /// <em>Animancer Lite does not allow this value to be changed in runtime builds.</em>
 580|        /// </remarks>
 581|        public float NormalizedEndTime
 582|        {
 583|            get
 584|            {
 585|                if (_EventRunner != null)
 586|                {
 587|                    var time = _EventRunner.Events.NormalizedEndTime;
 588|                    if (!float.IsNaN(time))
 589|                        return time;
 590|                }
 591|
 592|                return AnimancerEvent.Sequence.GetDefaultNormalizedEndTime(EffectiveSpeed);
 593|            }
 594|            set => Events.NormalizedEndTime = value;
 595|        }
 596|
 597|        /************************************************************************************************************************/
 598|
 599|        /// <summary>
 600|        /// The number of seconds the animation will take to play fully at its current
 601|        /// <see cref="AnimancerNode.EffectiveSpeed"/>.
 602|        /// </summary>
 603|        /// 
 604|        /// <remarks>
 605|        /// For the time remaining from now until it reaches the end, use <see cref="RemainingDuration"/> instead.
 606|        /// <para></para>
 607|        /// Setting this value modifies the <see cref="AnimancerNode.EffectiveSpeed"/>, not the <see cref="Length"/>.
 608|        /// <para></para>
 609|        /// <em>Animancer Lite does not allow this value to be changed in runtime builds.</em>
 610|        /// </remarks>
 611|        ///
 612|        /// <example><code>
 613|        /// void PlayAnimation(AnimancerComponent animancer, AnimationClip clip)
 614|        /// {
 615|        ///     var state = animancer.Play(clip);
 616|        ///
 617|        ///     state.Duration = 1;// Play fully in 1 second.
 618|        ///     state.Duration = 2;// Play fully in 2 seconds.
 619|        ///     state.Duration = 0.5f;// Play fully in half a second.
 620|        ///     state.Duration = -1;// Play backwards fully in 1 second.
 621|        ///     state.NormalizedTime = 1; state.Duration = -1;// Play backwards from the end in 1 second.
 622|        /// }
 623|        /// </code></example>
 624|        public float Duration
 625|        {
 626|            get
 627|            {
 628|                var speed = EffectiveSpeed;
 629|                if (_EventRunner != null)
 630|                {
 631|                    var endTime = _EventRunner.Events.NormalizedEndTime;
 632|                    if (!float.IsNaN(endTime))
 633|                    {
 634|                        if (speed > 0)
 635|                            return Length * endTime / speed;
 636|                        else
 637|                            return Length * (1 - endTime) / -speed;
 638|                    }
 639|                }
 640|
 641|                return Length / Math.Abs(speed);
 642|            }
 643|            set
 644|            {
 645|                var length = Length;
 646|                if (_EventRunner != null)
 647|                {
 648|                    var endTime = _EventRunner.Events.NormalizedEndTime;
 649|                    if (!float.IsNaN(endTime))
 650|                    {
 651|                        if (EffectiveSpeed > 0)
 652|                            length *= endTime;
 653|                        else
 654|                            length *= 1 - endTime;
 655|                    }
 656|                }
 657|
 658|                EffectiveSpeed = length / value;
 659|            }
 660|        }
 661|
 662|        /************************************************************************************************************************/
 663|
 664|        /// <summary>
 665|        /// The number of seconds this state will take to go from its current <see cref="NormalizedTime"/> to the
 666|        /// <see cref="NormalizedEndTime"/> at its current <see cref="AnimancerNode.EffectiveSpeed"/>.
 667|        /// </summary>
 668|        /// 
 669|        /// <remarks>
 670|        /// For the time it would take to play fully from the start, use the <see cref="Duration"/> instead.
 671|        /// <para></para>
 672|        /// Setting this value modifies the <see cref="AnimancerNode.EffectiveSpeed"/>, not the <see cref="Length"/>.
 673|        /// <para></para>
 674|        /// <em>Animancer Lite does not allow this value to be changed in runtime builds.</em>
 675|        /// </remarks>
 676|        ///
 677|        /// <example><code>
 678|        /// void PlayAnimation(AnimancerComponent animancer, AnimationClip clip)
 679|        /// {
 680|        ///     var state = animancer.Play(clip);
 681|        ///
 682|        ///     state.RemainingDuration = 1;// Play from the current time to the end in 1 second.
 683|        ///     state.RemainingDuration = 2;// Play from the current time to the end in 2 seconds.
 684|        ///     state.RemainingDuration = 0.5f;// Play from the current time to the end in half a second.
 685|        ///     state.RemainingDuration = -1;// Play from the current time away from the end.
 686|        /// }
 687|        /// </code></example>
 688|        public float RemainingDuration
 689|        {
 690|            get => (Length * NormalizedEndTime - Time) / EffectiveSpeed;
 691|            set => EffectiveSpeed = (Length * NormalizedEndTime - Time) / value;
 692|        }
 693|
 694|        /************************************************************************************************************************/
 695|        // Length.
 696|        /************************************************************************************************************************/
 697|
 698|        /// <summary>The total time this state would take to play in seconds when <see cref="AnimancerNode.Speed"/> = 1.</summary>
 699|        public abstract float Length { get; }
 700|
 701|        /// <summary>Will this state loop back to the start when it reaches the end?</summary>
 702|        public virtual bool IsLooping => false;
 703|
 704|        /************************************************************************************************************************/
 705|        #endregion
 706|        /************************************************************************************************************************/
 707|        #region Methods
 708|        /************************************************************************************************************************/
 709|
 710|        /// <summary>
 711|        /// Updates the <see cref="AnimancerNode.Weight"/> for fading, applies it to this state's port on the parent
 712|        /// mixer, and plays or pauses the <see cref="Playable"/> if its state is dirty.
 713|        /// </summary>
 714|        /// <remarks>
 715|        /// If the <see cref="Parent"/>'s <see cref="AnimancerNode.KeepChildrenConnected"/> is set to false, this
 716|        /// method will also connect/disconnect this node from the <see cref="Parent"/> in the playable graph.
 717|        /// </remarks>
 718|        protected internal override void Update(out bool needsMoreUpdates)
 719|        {
 720|            base.Update(out needsMoreUpdates);
 721|
 722|            if (_IsPlayingDirty)
 723|            {
 724|                _IsPlayingDirty = false;
 725|
 726|                if (_IsPlaying)
 727|                    _Playable.Play();
 728|                else
 729|                    _Playable.Pause();
 730|            }
 731|
 732|            if (_MustSetTime)
 733|            {
 734|                _MustSetTime = false;
 735|                RawTime = _Time;
 736|            }
 737|        }
 738|
 739|        /************************************************************************************************************************/
 740|
 741|        /// <summary>Destroys the <see cref="Playable"/> and cleans up this state.</summary>
 742|        /// <remarks>
 743|        /// This method is NOT called automatically, so when implementing a custom state type you must use
 744|        /// <see cref="AnimancerPlayable.Disposables"/> if you need to guarantee that things will get cleaned up.
 745|        /// </remarks>
 746|        public virtual void Destroy()
 747|        {
 748|            if (_Parent != null)
 749|            {
 750|                _Parent.OnRemoveChild(this);
 751|                _Parent = null;
 752|            }
 753|
 754|            Index = -1;
 755|            EventDispatcher.TryClear(_EventRunner);
 756|
 757|            var root = Root;
 758|            if (root != null)
 759|            {
 760|                root.States.Unregister(this);
 761|
 762|                // For some reason this is slightly faster than _Playable.Destroy().
 763|                if (_Playable.IsValid())
 764|                    root._Graph.DestroyPlayable(_Playable);
 765|            }
 766|        }
 767|
 768|        /************************************************************************************************************************/
 769|
 770|        /// <summary>[<see cref="IAnimationClipCollection"/>] Gathers all the animations in this state.</summary>
 771|        public virtual void GatherAnimationClips(ICollection<AnimationClip> clips) => clips.Gather(Clip);
 772|
 773|        /************************************************************************************************************************/
 774|
 775|        /// <summary>
 776|        /// Returns true if the animation is playing and has not yet passed the
 777|        /// <see cref="AnimancerEvent.Sequence.endEvent"/>.
 778|        /// </summary>
 779|        /// <remarks>
 780|        /// This method is called by <see cref="IEnumerator.MoveNext"/> so this object can be used as a custom yield
 781|        /// instruction to wait until it finishes.
 782|        /// </remarks>
 783|        protected internal override bool IsPlayingAndNotEnding()
 784|        {
 785|            if (!IsPlaying)
 786|                return false;
 787|
 788|            var speed = EffectiveSpeed;
 789|            if (speed > 0)
 790|            {
 791|                float endTime;
 792|                if (_EventRunner != null)
 793|                {
 794|                    endTime = _EventRunner.Events.endEvent.normalizedTime;
 795|                    if (float.IsNaN(endTime))
 796|                        endTime = Length;
 797|                    else
 798|                        endTime *= Length;
 799|                }
 800|                else endTime = Length;
 801|
 802|                return Time <= endTime;
 803|            }
 804|            else if (speed < 0)
 805|            {
 806|                float endTime;
 807|                if (_EventRunner != null)
 808|                {
 809|                    endTime = _EventRunner.Events.endEvent.normalizedTime;
 810|                    if (float.IsNaN(endTime))
 811|                        endTime = 0;
 812|                    else
 813|                        endTime *= Length;
 814|                }
 815|                else endTime = 0;
 816|
 817|                return Time >= endTime;
 818|            }
 819|            else return true;
 820|        }
 821|
 822|        /************************************************************************************************************************/
 823|
 824|        /// <summary>
 825|        /// Returns the <see cref="AnimancerNode.DebugName"/> if one is set, otherwise a string describing the type of this
 826|        /// state and the name of the <see cref="MainObject"/>.
 827|        /// </summary>
 828|        public override string ToString()
 829|        {
 830|#if UNITY_ASSERTIONS
 831|            if (DebugName != null)
 832|                return DebugName;
 833|#endif
 834|
 835|            var type = GetType().Name;
 836|            var mainObject = MainObject;
 837|            if (mainObject != null)
 838|                return $"{mainObject.name} ({type})";
 839|            else
 840|                return type;
 841|        }
 842|
 843|        /************************************************************************************************************************/
 844|        #region Descriptions
 845|        /************************************************************************************************************************/
 846|
 847|#if UNITY_EDITOR
 848|
 849|        /// <summary>[Editor-Only] Returns a custom drawer for this state.</summary>
 850|        protected internal virtual IAnimancerNodeDrawer CreateDrawer()
 851|            => new AnimancerStateDrawer<AnimancerState>(this);
 852|#endif
 853|
 854|        /************************************************************************************************************************/
 855|
 856|        /// <inheritdoc/>
 857|        protected override void AppendDetails(StringBuilder text, string separator)
 858|        {
 859|            text.Append(separator).Append($"{nameof(Key)}: ").Append(AnimancerUtilities.ToStringOrNull(_Key));
 860|
 861|            var mainObject = MainObject;
 862|            if (mainObject != _Key as Object)
 863|                text.Append(separator).Append($"{nameof(MainObject)}: ").Append(AnimancerUtilities.ToStringOrNull(mainObject));
 864|
 865|#if UNITY_EDITOR
 866|            if (mainObject != null)
 867|                text.Append(separator).Append("AssetPath: ").Append(AssetDatabase.GetAssetPath(mainObject));
 868|#endif
 869|
 870|            base.AppendDetails(text, separator);
 871|
 872|            text.Append(separator).Append($"{nameof(IsPlaying)}: ").Append(IsPlaying);
 873|
 874|            try
 875|            {
 876|                var time = Time;
 877|                var normalizedTime = NormalizedTime;
 878|                var length = Length;
 879|                var isLooping = IsLooping;
 880|                text.Append(separator).Append($"{nameof(Time)} (Normalized): ").Append(time);
 881|                text.Append(" (").Append(normalizedTime).Append(')');
 882|                text.Append(separator).Append($"{nameof(Length)}: ").Append(length);
 883|                text.Append(separator).Append($"{nameof(IsLooping)}: ").Append(isLooping);
 884|            }
 885|            catch { }// Ignore any exceptions.
 886|
 887|            if (_EventRunner != null && _EventRunner.Events != null)
 888|                _EventRunner.Events.endEvent.AppendDetails(text, "EndEvent", separator);
 889|        }
 890|
 891|        /************************************************************************************************************************/
 892|
 893|        /// <summary>Returns the hierarchy path of this state through its <see cref="Parent"/>s.</summary>
 894|        public string GetPath()
 895|        {
 896|            if (_Parent == null)
 897|                return null;
 898|
 899|            var path = ObjectPool.AcquireStringBuilder();
 900|
 901|            AppendPath(path, _Parent);
 902|            AppendPortAndType(path);
 903|
 904|            return path.ReleaseToString();
 905|        }
 906|
 907|        /// <summary>Appends the hierarchy path of this state through its <see cref="Parent"/>s.</summary>
 908|        private static void AppendPath(StringBuilder path, AnimancerNode parent)
 909|        {
 910|            var parentState = parent as AnimancerState;
 911|            if (parentState != null && parentState._Parent != null)
 912|            {
 913|                AppendPath(path, parentState._Parent);
 914|            }
 915|            else
 916|            {
 917|                path.Append("Layers[")
 918|                    .Append(parent.Layer.Index)
 919|                    .Append("].States");
 920|                return;
 921|            }
 922|
 923|            var state = parent as AnimancerState;
 924|            if (state != null)
 925|            {
 926|                state.AppendPortAndType(path);
 927|            }
 928|            else
 929|            {
 930|                path.Append(" -> ")
 931|                    .Append(parent.GetType());
 932|            }
 933|        }
 934|
 935|        /// <summary>Appends "[Index] -> GetType().Name".</summary>
 936|        private void AppendPortAndType(StringBuilder path)
 937|        {
 938|            path.Append('[')
 939|                .Append(Index)
 940|                .Append("] -> ")
 941|                .Append(GetType().Name);
 942|        }
 943|
 944|        /************************************************************************************************************************/
 945|        #endregion
 946|        /************************************************************************************************************************/
 947|        #endregion
 948|        /************************************************************************************************************************/
 949|        #region Transition
 950|        /************************************************************************************************************************/
 951|
 952|        /// <summary>
 953|        /// Base class for serializable <see cref="ITransition"/>s which can create a particular type of
 954|        /// <see cref="AnimancerState"/> when passed into <see cref="AnimancerPlayable.Play(ITransition)"/>.
 955|        /// </summary>
 956|        /// <remarks>
 957|        /// Unfortunately the tool used to generate this documentation does not currently support nested types with
 958|        /// identical names, so only one <c>Transition</c> class will actually have a documentation page.
 959|        /// <para></para>
 960|        /// Even though it has the <see cref="SerializableAttribute"/>, this class won't actually get serialized
 961|        /// by Unity because it's generic and abstract. Each child class still needs to include the attribute.
 962|        /// <para></para>
 963|        /// Documentation: <see href="https://kybernetik.com.au/animancer/docs/manual/transitions">Transitions</see>
 964|        /// </remarks>
 965|        /// https://kybernetik.com.au/animancer/api/Animancer/Transition_1
 966|        /// 
 967|        [Serializable]
 968|        public abstract class Transition<TState> : ITransitionDetailed where TState : AnimancerState
 969|        {
 970|            /************************************************************************************************************************/
 971|
 972|            [SerializeField, Tooltip(Strings.ProOnlyTag + "The amount of time the transition will take (in seconds)")]
 973|            private float _FadeDuration = AnimancerPlayable.DefaultFadeDuration;
 974|
 975|            /// <summary>[<see cref="SerializeField"/>] The amount of time the transition will take (in seconds).</summary>
 976|            /// <exception cref="ArgumentOutOfRangeException">Thrown when setting the value to a negative number.</exception>
 977|            public float FadeDuration
 978|            {
 979|                get => _FadeDuration;
 980|                set
 981|                {
 982|                    if (value < 0)
 983|                        throw new ArgumentOutOfRangeException(nameof(value), $"{nameof(FadeDuration)} must not be negative");
 984|
 985|                    _FadeDuration = value;
 986|                }
 987|            }
 988|
 989|            /************************************************************************************************************************/
 990|
 991|            /// <summary>[<see cref="ITransitionDetailed"/>]
 992|            /// Indicates what the value of <see cref="AnimancerState.IsLooping"/> will be for the created state.
 993|            /// Returns false unless overridden.
 994|            /// </summary>
 995|            public virtual bool IsLooping => false;
 996|
 997|            /// <summary>[<see cref="ITransitionDetailed"/>]
 998|            /// Determines what <see cref="NormalizedTime"/> to start the animation at.
 999|            /// Returns <see cref="float.NaN"/> unless overridden.
1000|            /// </summary>
1001|            public virtual float NormalizedStartTime
1002|            {
1003|                get => float.NaN;
1004|                set { }
1005|            }
1006|
1007|            /// <summary>[<see cref="ITransitionDetailed"/>]
1008|            /// Determines how fast the animation plays (1x = normal speed).
1009|            /// Returns 1 unless overridden.
1010|            /// </summary>
1011|            public virtual float Speed
1012|            {
1013|                get => 1;
1014|                set { }
1015|            }
1016|
1017|            /// <summary>[<see cref="ITransitionDetailed"/>]
1018|            /// The maximum amount of time the animation is expected to take (in seconds).
1019|            /// </summary>
1020|            /// <remarks>The actual duration can vary in states like <see cref="MixerState"/>.</remarks>
1021|            public abstract float MaximumDuration { get; }
1022|
1023|            /// <summary>[<see cref="ITransitionDetailed"/>]
1024|            /// The <see cref="Motion.averageAngularSpeed"/> that the created state will have.
1025|            /// </summary>
1026|            /// <remarks>The actual average velocity can vary in states like <see cref="MixerState"/>.</remarks>
1027|            public virtual float AverageAngularSpeed => 0;
1028|
1029|            /// <summary>[<see cref="ITransitionDetailed"/>]
1030|            /// The <see cref="Motion.averageSpeed"/> that the created state will have.
1031|            /// </summary>
1032|            /// <remarks>The actual average velocity can vary in states like <see cref="MixerState"/>.</remarks>
1033|            public virtual Vector3 AverageVelocity => default;
1034|
1035|            /************************************************************************************************************************/
1036|
1037|            [SerializeField, Tooltip(Strings.ProOnlyTag + "Events which will be triggered as the animation plays")]
1038|            private AnimancerEvent.Sequence.Serializable _Events;
1039|
1040|            /// <summary>[<see cref="SerializeField"/>] [<see cref="ITransitionDetailed"/>]
1041|            /// Events which will be triggered as the animation plays.
1042|            /// </summary>
1043|            /// <remarks>This property returns the <see cref="AnimancerEvent.Sequence.Serializable.Sequence"/>.</remarks>
1044|            public AnimancerEvent.Sequence Events => _Events.Sequence;
1045|
1046|            /// <summary>[<see cref="SerializeField"/>] [<see cref="ITransitionDetailed"/>]
1047|            /// Events which will be triggered as the animation plays.
1048|            /// </summary>
1049|            public ref AnimancerEvent.Sequence.Serializable SerializedEvents => ref _Events;
1050|
1051|            /************************************************************************************************************************/
1052|
1053|            /// <summary>
1054|            /// The state that was created by this object. Specifically, this is the state that was most recently
1055|            /// passed into <see cref="Apply"/> (usually by <see cref="AnimancerPlayable.Play(ITransition)"/>).
1056|            /// <para></para>
1057|            /// You can use <see cref="AnimancerPlayable.StateDictionary.GetOrCreate(ITransition)"/> or
1058|            /// <see cref="AnimancerLayer.GetOrCreateState(ITransition)"/> to get or create the state for a
1059|            /// specific object.
1060|            /// <para></para>
1061|            /// <see cref="State"/> is simply a shorthand for casting this to <typeparamref name="TState"/>.
1062|            /// </summary>
1063|            public AnimancerState BaseState { get; private set; }
1064|
1065|            /************************************************************************************************************************/
1066|
1067|            private TState _State;
1068|
1069|            /// <summary>
1070|            /// The state that was created by this object. Specifically, this is the state that was most recently
1071|            /// passed into <see cref="Apply"/> (usually by <see cref="AnimancerPlayable.Play(ITransition)"/>).
1072|            /// </summary>
1073|            /// 
1074|            /// <remarks>
1075|            /// You can use <see cref="AnimancerPlayable.StateDictionary.GetOrCreate(ITransition)"/> or
1076|            /// <see cref="AnimancerLayer.GetOrCreateState(ITransition)"/> to get or create the state for a
1077|            /// specific object.
1078|            /// <para></para>
1079|            /// This property is shorthand for casting the <see cref="BaseState"/> to <typeparamref name="TState"/>.
1080|            /// </remarks>
1081|            /// 
1082|            /// <exception cref="InvalidCastException">
1083|            /// The <see cref="BaseState"/> is not actually a <typeparamref name="TState"/>. This should only
1084|            /// happen if a different type of state was created by something else and registered using the
1085|            /// <see cref="Key"/>, causing this <see cref="AnimancerPlayable.Play(ITransition)"/> to pass that
1086|            /// state into <see cref="Apply"/> instead of calling <see cref="CreateState"/> to make the correct type of
1087|            /// state.
1088|            /// </exception>
1089|            public TState State
1090|            {
1091|                get
1092|                {
1093|                    if (_State == null)
1094|                        _State = (TState)BaseState;
1095|
1096|                    return _State;
1097|                }
1098|                protected set
1099|                {
1100|                    BaseState = _State = value;
1101|                }
1102|            }
1103|
1104|            /************************************************************************************************************************/
1105|
1106|            /// <summary>Indicates whether this transition can create a valid <see cref="AnimancerState"/>.</summary>
1107|            public virtual bool IsValid => true;
1108|
1109|            /************************************************************************************************************************/
1110|
1111|            /// <summary>The <see cref="AnimancerState.Key"/> which the created state will be registered with.</summary>
1112|            /// <remarks>Returns <c>this</c> unless overridden.</remarks>
1113|            public virtual object Key => this;
1114|
1115|            /// <summary>
1116|            /// When a transition is passed into <see cref="AnimancerPlayable.Play(ITransition)"/>, this property
1117|            /// determines which <see cref="Animancer.FadeMode"/> will be used.
1118|            /// </summary>
1119|            public virtual FadeMode FadeMode => FadeMode.FixedSpeed;
1120|
1121|            /// <summary>Creates and returns a new <typeparamref name="TState"/>.</summary>
1122|            /// <remarks>
1123|            /// Note that using methods like <see cref="AnimancerPlayable.Play(ITransition)"/> will also call
1124|            /// <see cref="Apply"/>, so if you call this method manually you may want to call that method as well. Or you
1125|            /// can just use <see cref="AnimancerUtilities.CreateStateAndApply"/>.
1126|            /// </remarks>
1127|            public abstract TState CreateState();
1128|
1129|            /// <summary>Creates and returns a new <typeparamref name="TState"/>.</summary>
1130|            /// <remarks>
1131|            /// Note that using methods like <see cref="AnimancerPlayable.Play(ITransition)"/> will also call
1132|            /// <see cref="Apply"/>, so if you call this method manually you may want to call that method as well. Or you
1133|            /// can just use <see cref="AnimancerUtilities.CreateStateAndApply"/>.
1134|            /// </remarks>
1135|            AnimancerState ITransition.CreateState() => CreateState();
1136|
1137|            /************************************************************************************************************************/
1138|
1139|            /// <summary>[<see cref="ITransition"/>]
1140|            /// Sets the <see cref="BaseState"/> and applies any other modifications to the `state`.
1141|            /// </summary>
1142|            /// <remarks>
1143|            /// Called by <see cref="AnimancerPlayable.Play(ITransition)"/>.
1144|            /// <para></para>
1145|            /// This method also clears the <see cref="State"/> if necessary, so it will re-cast the
1146|            /// <see cref="BaseState"/> when it gets accessed again.
1147|            /// </remarks>
1148|            public virtual void Apply(AnimancerState state)
1149|            {
1150|                state.Events = _Events;
1151|
1152|                BaseState = state;
1153|
1154|                if (_State != state)
1155|                    _State = null;
1156|            }
1157|
1158|            /************************************************************************************************************************/
1159|
1160|            /// <summary>The <see cref="AnimancerState.MainObject"/> that the created state will have.</summary>
1161|            public virtual Object MainObject { get; }
1162|
1163|            /// <summary>The display name of this transition.</summary>
1164|            public virtual string Name
1165|            {
1166|                get
1167|                {
1168|                    var mainObject = MainObject;
1169|                    return mainObject != null ? mainObject.name : null;
1170|                }
1171|            }
1172|
1173|            /// <summary>Returns the <see cref="Name"/> and type of this transition.</summary>
1174|            public override string ToString()
1175|            {
1176|                var type = GetType().FullName;
1177|
1178|                var name = Name;
1179|                if (name != null)
1180|                    return $"{name} ({type})";
1181|                else
1182|                    return type;
1183|            }
1184|
1185|            /************************************************************************************************************************/
1186|
1187|#if UNITY_EDITOR
1188|            /// <summary>[Editor-Only] Don't use Inspector Gadgets Nested Object Drawers.</summary>
1189|            private const bool NestedObjectDrawers = false;
1190|#endif
1191|
1192|            /************************************************************************************************************************/
1193|        }
1194|
1195|        /************************************************************************************************************************/
1196|        #endregion
1197|        /************************************************************************************************************************/
1198|    }
1199|}
1200|

2024-12-17 11:13:38,849 - INFO Retriever 0 - 

————————————————————————————————————————————————————————————————
2024-12-17 11:13:38,849 - INFO Retriever 0 - 当前窗口总长度：21
2024-12-17 11:13:38,849 - INFO Retriever 0 - 当前更新窗口长度：12
2024-12-17 11:13:38,849 - INFO Retriever 0 - 当前更新窗口长度：12
2024-12-17 11:13:38,851 - INFO Retriever 0 - ————————————————————————————————————————————————————————————————


2024-12-17 11:13:57,271 - INFO Retriever 0 - Agent主脑给出的回答为：{
    "deep_think": {
        "thoughts": "我已经读取了文件三（AnimancerState.cs）的详细内容，该文件定义了动画状态管理的基础类，包括动画的播放控制、时间管理以及与动画图（Graph）的交互。根据文件内容，我了解到可以通过修改`IsPlaying`属性来控制动画的播放状态，通过`Time`属性来控制动画的播放时间，以及通过`NormalizedTime`属性来控制动画的播放进度。此外，`Duration`属性可以用来设置动画的播放时长，而`RemainingDuration`属性可以用来设置动画从当前时间到结束的剩余时长。这些属性和方法可能对于实现固定战斗动画至关重要。接下来，我将使用read_file操作，读取文件二（AIManager.lua）的内容，以获取角色AI逻辑的详细信息。"
    }
}
2024-12-17 11:13:57,271 - INFO Retriever 0 - 是否成功解析：True
2024-12-17 11:13:57,271 - INFO Retriever 0 - operation_type (__det_dir_action):
2024-12-17 11:13:57,272 - INFO Retriever 0 - deep_think
2024-12-17 11:13:57,272 - INFO Retriever 0 - 

——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
2024-12-17 11:13:57,272 - INFO Retriever 0 - Assistant:
2024-12-17 11:13:57,272 - INFO Retriever 0 - {
    "deep_think": {
        "thoughts": "我已经读取了文件三（AnimancerState.cs）的详细内容，该文件定义了动画状态管理的基础类，包括动画的播放控制、时间管理以及与动画图（Graph）的交互。根据文件内容，我了解到可以通过修改`IsPlaying`属性来控制动画的播放状态，通过`Time`属性来控制动画的播放时间，以及通过`NormalizedTime`属性来控制动画的播放进度。此外，`Duration`属性可以用来设置动画的播放时长，而`RemainingDuration`属性可以用来设置动画从当前时间到结束的剩余时长。这些属性和方法可能对于实现固定战斗动画至关重要。接下来，我将使用read_file操作，读取文件二（AIManager.lua）的内容，以获取角色AI逻辑的详细信息。"
    }
}
2024-12-17 11:13:57,272 - INFO Retriever 0 - dict_keys(['deep_think'])
2024-12-17 11:13:57,273 - INFO Retriever 0 - Agent主脑给出的行动：deep_think
参数：{'thoughts': '我已经读取了文件三（AnimancerState.cs）的详细内容，该文件定义了动画状态管理的基础类，包括动画的播放控制、时间管理以及与动画图（Graph）的交互。根据文件内容，我了解到可以通过修改`IsPlaying`属性来控制动画的播放状态，通过`Time`属性来控制动画的播放时间，以及通过`NormalizedTime`属性来控制动画的播放进度。此外，`Duration`属性可以用来设置动画的播放时长，而`RemainingDuration`属性可以用来设置动画从当前时间到结束的剩余时长。这些属性和方法可能对于实现固定战斗动画至关重要。接下来，我将使用read_file操作，读取文件二（AIManager.lua）的内容，以获取角色AI逻辑的详细信息。', 'repeat_counter': 1, 'continue_think_counter': 1}
2024-12-17 11:13:57,273 - INFO Retriever 0 - Observer: 好的，请继续你的下一步行动或思考。
2024-12-17 11:13:57,275 - INFO Retriever 0 - 

————————————————————————————————————————————————————————————————
2024-12-17 11:13:57,276 - INFO Retriever 0 - 当前窗口总长度：23
2024-12-17 11:13:57,276 - INFO Retriever 0 - 当前更新窗口长度：14
2024-12-17 11:13:57,276 - INFO Retriever 0 - 当前更新窗口长度：14
2024-12-17 11:13:57,277 - INFO Retriever 0 - ————————————————————————————————————————————————————————————————


2024-12-17 11:14:29,667 - INFO Retriever 0 - Agent主脑给出的回答为：{
    "read_file": {
        "file_path": "D:/Unity/jyx2\\Assets\\LuaScripts\\Jyx2Battle\\AIManager.lua"
    }
}
2024-12-17 11:14:29,668 - INFO Retriever 0 - 是否成功解析：True
2024-12-17 11:14:29,668 - INFO Retriever 0 - operation_type (__det_dir_action):
2024-12-17 11:14:29,668 - INFO Retriever 0 - read_file
2024-12-17 11:14:29,668 - INFO Retriever 0 - 

——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
2024-12-17 11:14:29,669 - INFO Retriever 0 - Assistant:
2024-12-17 11:14:29,669 - INFO Retriever 0 - {
    "read_file": {
        "file_path": "D:/Unity/jyx2\\Assets\\LuaScripts\\Jyx2Battle\\AIManager.lua"
    }
}
2024-12-17 11:14:29,669 - INFO Retriever 0 - dict_keys(['read_file'])
2024-12-17 11:14:29,669 - INFO Retriever 0 - Agent主脑给出的行动：read_file
参数：{'file_path': 'D:/Unity/jyx2\\Assets\\LuaScripts\\Jyx2Battle\\AIManager.lua', 'top_path': 'D:/Unity/jyx2\\Assets', 'return_file_sum': <bound method TreeGenerationAction.return_file_sum of <Action.tree_gen_action.TreeGenerationAction object at 0x0000027D71AB0D90>>}
2024-12-17 11:14:29,710 - INFO Retriever 0 - Observer: 这是一个名为“AIManager.lua”的文件，该文件里的内容为：
由于脚本文件内容过长，暂时仅给出该脚本文件的内容总结:
- ### 总体概述
该脚本是一个Lua编写的游戏战斗AI模块，用于金庸群侠传3D重制版游戏中。它主要负责处理游戏中的角色AI逻辑，包括初始化、角色位置更新、AI决策和结果反馈。

### 模块和功能
- **初始化和反初始化**：`Init`和`DeInit`函数用于初始化和反初始化AI模块。
- **角色位置更新**：`RefreshRolePos`函数用于更新存活角色的位置信息。
- **AI决策**：`GetAIResult`函数是核心，它根据角色的状态和周围环境做出决策。
- **物品和技能管理**：包括获取可用物品、获取最近敌人、获取技能释放评分等功能。

### 类和函数
- **`ai`**：主要类，包含所有AI相关的函数和方法。
- **`Init`**：初始化AI模块，设置随机种子，加载技能和伤害计算器。
- **`DeInit`**：反初始化AI模块，清除资源。
- **`GetAIResult`**：获取AI决策结果，包括移动、攻击或休息。
- **`GetAvailableItems`**：获取角色可用的物品。
- **`GetNearestEnemy`**：获取最近的敌人角色。
- **`GetNearestEnemyBlock`**：获取最近的敌人位置。
- **`GetFarestEnemyBlock`**：获取离敌人最远的点。
- **`GetMoveAndCastPos`**：获取移动和施放技能的位置。
- **`GetSkillCastResultScore`**：计算技能释放的评分。
- **`MoveToNearestEnemy`**：移动到最近的敌人。
- **`Rest`**：原地休息。

### 实现逻辑
- **初始化**：加载必要的组件和资源。
- **角色位置更新**：定期更新存活角色的位置信息。
- **AI决策**：根据角色状态和周围环境，通过穷举搜索等方式，决定角色的下一步行动（移动、攻击或休息）。
- **结果反馈**：将AI决策的结果反馈给游戏引擎，以执行相应的动作。
在这个脚本中存在如下的一些函数：CheckPosRole、CheckRoleTeam、DeInit、GetAIResult、GetAvailableItems、GetCastScore、GetFarestEnemyBlock、GetMoveAndCastPos、GetNearestEnemy、GetNearestEnemyBlock、GetSkillCastResultScore、Init、MoveToNearestEnemy、RefreshRolePos、Rest、checkTeam
这些函数有以下详细信息：
- 技能是攻击技能时 如果目标位置没有人或者是队友，则跳过 目标格子和移动位置相同，自己包含在施放范围中 如果目标位置有人且是队友 获取技能释放评分 获取场上角色 角色位置 获取场上角色 角色位置 获取攻击方向 技能覆盖的坐标 四个方向循环 普通攻击伤害与距离成反比，需要寻找最近点放 用毒的时候根据角色血量选择策略 丢给自己的，随便乱跑一个地方丢 缓存常用数据 如果是点攻击，使用简化方案 尽量离非目标敌人远 与全部敌人的距离 技能施放位置与移动后位置之距离 如果aimpos == -1，说明这个位置打不到人 如果是攻击型，则远离敌人 非攻击型，靠近队友 如果是攻击型，则优先靠近目标，再次远离其他敌人 非攻击型，靠近队友 带攻击范围的，找最多人丢 最短距离乘以策略，只有策略不是0时，才考虑最短距离问题 打敌人时不打到队友 给队友加血不能加到敌人 还活着 local result = CS.AIManager.Instance:GetSkillResult(caster, targetRole, skill, blockVector); 解毒算分 医疗算分 用毒算分 暗器算分
- print(role.Name) 获得角色移动能力 行动范围 可使用招式 AI算法：穷举每个点，使用招式，取最大收益 profiler.start() 考虑吃药 如果身上有物品，进行物品相关初始化 使用体力药 使用生命药 如果血量太少，吃药优先级将特别高，防止npc沉迷打怪 使用内力药 使用解毒药 使用暗器 print("aqName"..anqiSkillCast.Anqi.Name.."score"..score.."mpos"..tmp[1]:ToInt().."cpos"..tmp[2]:ToInt()) print("No Item Use") 使用武学 print("skname:"..skill.Data.Name.." score"..score.."mpos"..tmp[1]:ToInt().."cpos"..tmp[2]:ToInt()) 如果前面可以得出结果，就反馈 否则靠近自己最近的敌人 否则原地休息 如果角色是玩家战友且是玩家队伍里面的 如果没有给被寻找的角色表，那就获取一份 寻找离自己最近的敌人 寻找离对手最近的一点 寻找一个点离敌人最远 遍历时过滤不可达的位置，以免引发异常 检查格子上是否有角色 返回0表示没有，返回1表示队友，返回2表示敌人 技能是攻击技能时 如果目标位置没有人或者是队友，则跳过 目标格子和移动位置相同，自己包含在施放范围中 如果目标位置有人且是队友 获取技能释放评分 获取场上角色 角色位置 获取场上角色 角色位置 获取攻击方向 技能覆盖的坐标 四个方向循环 普通攻击伤害与距离成反比，需要寻找最近点放 用毒的时候根据角色血量选择策略 丢给自己的，随便乱跑一个地方丢 缓存常用数据 如果是点攻击，使用简化方案 尽量离非目标敌人远 与全部敌人的距离 技能施放位置与移动后位置之距离 如果aimpos == -1，说明这个位置打不到人 如果是攻击型，则远离敌人 非攻击型，靠近队友 如果是攻击型，则优先靠近目标，再次远离其他敌人 非攻击型，靠近队友 带攻击范围的，找最多人丢 最短距离乘以策略，只有策略不是0时，才考虑最短距离问题 打敌人时不打到队友 给队友加血不能加到敌人 还活着 local result = CS.AIManager.Instance:GetSkillResult(caster, targetRole, skill, blockVector); 解毒算分 医疗算分 用毒算分 暗器算分
- 如果角色是玩家战友且是玩家队伍里面的
- 获取场上角色 角色位置 获取场上角色 角色位置 获取攻击方向 技能覆盖的坐标 四个方向循环 普通攻击伤害与距离成反比，需要寻找最近点放 用毒的时候根据角色血量选择策略 丢给自己的，随便乱跑一个地方丢 缓存常用数据 如果是点攻击，使用简化方案 尽量离非目标敌人远 与全部敌人的距离 技能施放位置与移动后位置之距离 如果aimpos == -1，说明这个位置打不到人 如果是攻击型，则远离敌人 非攻击型，靠近队友 如果是攻击型，则优先靠近目标，再次远离其他敌人 非攻击型，靠近队友 带攻击范围的，找最多人丢 最短距离乘以策略，只有策略不是0时，才考虑最短距离问题 打敌人时不打到队友 给队友加血不能加到敌人 还活着 local result = CS.AIManager.Instance:GetSkillResult(caster, targetRole, skill, blockVector); 解毒算分 医疗算分 用毒算分 暗器算分
- 寻找一个点离敌人最远 遍历时过滤不可达的位置，以免引发异常
- 普通攻击伤害与距离成反比，需要寻找最近点放 用毒的时候根据角色血量选择策略 丢给自己的，随便乱跑一个地方丢 缓存常用数据 如果是点攻击，使用简化方案 尽量离非目标敌人远 与全部敌人的距离 技能施放位置与移动后位置之距离 如果aimpos == -1，说明这个位置打不到人 如果是攻击型，则远离敌人 非攻击型，靠近队友 如果是攻击型，则优先靠近目标，再次远离其他敌人 非攻击型，靠近队友 带攻击范围的，找最多人丢 最短距离乘以策略，只有策略不是0时，才考虑最短距离问题 打敌人时不打到队友 给队友加血不能加到敌人 还活着 local result = CS.AIManager.Instance:GetSkillResult(caster, targetRole, skill, blockVector); 解毒算分 医疗算分 用毒算分 暗器算分
- 如果没有给被寻找的角色表，那就获取一份 寻找离自己最近的敌人
- 寻找离对手最近的一点
- 还活着 local result = CS.AIManager.Instance:GetSkillResult(caster, targetRole, skill, blockVector); 解毒算分 医疗算分 用毒算分 暗器算分
- print(role.Name) 获得角色移动能力 行动范围 可使用招式 AI算法：穷举每个点，使用招式，取最大收益 profiler.start() 考虑吃药 如果身上有物品，进行物品相关初始化 使用体力药 使用生命药 如果血量太少，吃药优先级将特别高，防止npc沉迷打怪 使用内力药 使用解毒药 使用暗器 print("aqName"..anqiSkillCast.Anqi.Name.."score"..score.."mpos"..tmp[1]:ToInt().."cpos"..tmp[2]:ToInt()) print("No Item Use") 使用武学 print("skname:"..skill.Data.Name.." score"..score.."mpos"..tmp[1]:ToInt().."cpos"..tmp[2]:ToInt()) 如果前面可以得出结果，就反馈 否则靠近自己最近的敌人 否则原地休息 如果角色是玩家战友且是玩家队伍里面的 如果没有给被寻找的角色表，那就获取一份 寻找离自己最近的敌人 寻找离对手最近的一点 寻找一个点离敌人最远 遍历时过滤不可达的位置，以免引发异常 检查格子上是否有角色 返回0表示没有，返回1表示队友，返回2表示敌人 技能是攻击技能时 如果目标位置没有人或者是队友，则跳过 目标格子和移动位置相同，自己包含在施放范围中 如果目标位置有人且是队友 获取技能释放评分 获取场上角色 角色位置 获取场上角色 角色位置 获取攻击方向 技能覆盖的坐标 四个方向循环 普通攻击伤害与距离成反比，需要寻找最近点放 用毒的时候根据角色血量选择策略 丢给自己的，随便乱跑一个地方丢 缓存常用数据 如果是点攻击，使用简化方案 尽量离非目标敌人远 与全部敌人的距离 技能施放位置与移动后位置之距离 如果aimpos == -1，说明这个位置打不到人 如果是攻击型，则远离敌人 非攻击型，靠近队友 如果是攻击型，则优先靠近目标，再次远离其他敌人 非攻击型，靠近队友 带攻击范围的，找最多人丢 最短距离乘以策略，只有策略不是0时，才考虑最短距离问题 打敌人时不打到队友 给队友加血不能加到敌人 还活着 local result = CS.AIManager.Instance:GetSkillResult(caster, targetRole, skill, blockVector); 解毒算分 医疗算分 用毒算分 暗器算分
- 打敌人时不打到队友 给队友加血不能加到敌人
2024-12-17 11:14:29,715 - INFO Retriever 0 - 

————————————————————————————————————————————————————————————————
2024-12-17 11:14:29,715 - INFO Retriever 0 - 当前窗口总长度：25
2024-12-17 11:14:29,715 - INFO Retriever 0 - 当前更新窗口长度：16
2024-12-17 11:14:29,716 - INFO Retriever 0 - 当前更新窗口长度：16
2024-12-17 11:14:29,716 - INFO Retriever 0 - ————————————————————————————————————————————————————————————————


